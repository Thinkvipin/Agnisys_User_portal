/*

*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
created by          :
generated by        : klee
IDesignSpec ver     :  7.32.0.0

**** This code is generated with the following settings ***
Reg Width                  : 32
Address Unit               : 8
C++ Types int              : hwint
Bus Type                   : APB
BigEndian                  : false
LittleEndian               : true
Dist. Decode and Readback  : false
------------------------------------------------------------ */



module handshake_synchronizer_pulse(
    clk,
    reset_l,
    hw_clk,
    register_fld_q,
    register_fld_r,
    register_fld_read_enb,
    register_fld_busy_out
    );
    parameter field_width = 1;
    
    input clk;
    input hw_clk;
    input reset_l;
    input [field_width - 1 : 0]register_fld_q;
    input register_fld_read_enb;
    output reg [field_width - 1 : 0]register_fld_r;
    output register_fld_busy_out;
    
    reg register_read_req_ff2;
    reg register_read_req_ff1;
    reg register_read_req_ff0;
    reg register_read_ack_ff1;
    reg register_read_ack_ff0;
    reg last_read_req;
    
    
    always @(posedge clk)
        begin
        if(!reset_l)
            begin
                register_read_req_ff2 <= 1'b0;
            end
        else
            begin
            if ((!register_fld_busy_out) && (register_fld_read_enb))
                begin
                    register_read_req_ff2 <= 1'b1;
                end
            else if (register_read_ack_ff0)
                begin
                    register_read_req_ff2 <= 1'b0;
                end
            end
    end // always clk
    
    assign	register_fld_busy_out = (register_read_req_ff2)||(register_read_ack_ff0);
    
    always @(posedge hw_clk)
        begin
        if(!reset_l)always @(posedge hw_clk)
            begin
            if(!reset_l)
                begin
                    register_read_req_ff1 <= 1'b0;
                    register_read_req_ff0 <= 1'b0;
                    last_read_req <= 1'b0;
                end
            else
                begin
                    register_read_req_ff1 <= register_read_req_ff2;
                    register_read_req_ff0 <= register_read_req_ff1;
                    last_read_req <= register_read_req_ff0;
                end
        end // always hw_clk
        
        
        always @(posedge clk)
            begin
            if(!reset_l)
                begin
                    register_read_ack_ff1 <= 1'b0 ;
                    register_read_ack_ff0 <= 1'b0 ;
                end
            else
                begin
                    register_read_ack_ff1 <= register_read_req_ff0 ;
                    register_read_ack_ff0 <= register_read_ack_ff1 ;
                end
        end //always clk
        
        
        always @(posedge hw_clk)
            begin
            if(!reset_l)always @(posedge hw_clk)
                begin
                if(!reset_l)
                    begin
                        register_fld_r <= {field_width{1'b0}};
                    end
                else
                    begin
                        register_fld_r <= (!last_read_req) && (register_read_req_ff0);
                    end
            end //always hw_clk
        endmodule
        
        module handshake_synchronizer_read(
            clk,
            reset_l,
            hw_clk,
            register_fld_q,
            register_fld_r,
            register_fld_read_enb,
            register_fld_busy_out
            );
            parameter field_width = 32;
            localparam read_idle	= 1'b0;
            localparam read_waiting = 1'b1;
            
            input clk;
            input hw_clk;
            input reset_l;
            input [field_width - 1 : 0]register_fld_q;
            input register_fld_read_enb;
            output reg [field_width - 1 : 0]register_fld_r;
            output reg register_fld_busy_out;
            
            reg register_read_state;
            reg [field_width - 1 : 0] register_fld_q_ff;
            reg register_read_req_ff1;
            reg register_read_req_ff0;
            reg register_read_ack_ff1;
            reg register_read_ack_ff0;
            reg toggle_read_req;
            reg toggle_read_load_ff;
            reg load_data;
            reg toggle_read_ack_ff;
            reg req_clear;
            
            // READ FSM
            
            always @(posedge clk)
                begin
                if(!reset_l)
                    begin
                        register_fld_busy_out <= 1'b0;
                        register_fld_q_ff <= {field_width{1'b0}};
                        register_read_state <= read_idle;
                    end
                else
                    begin
                        case(register_read_state)
                            read_idle : begin
                            if(register_fld_read_enb)
                                begin
                                    register_fld_q_ff <= register_fld_q;
                                    register_fld_busy_out <= 1'b1;
                                    register_read_state <= read_waiting;
                                end
                            end
                            read_waiting : begin
                            if(req_clear)
                                begin
                                    register_fld_busy_out <= 1'b0;
                                    register_read_state <= read_idle;
                                end
                            end
                            default : begin
                                register_read_state <= read_idle;
                            end
                        endcase
                    end
            end // always clk
            
            // Toggle Read Req Generator
            
            always @(posedge clk)
                begin
                if(!reset_l)
                    begin
                        
                        
                        toggle_read_req <= 1'b0;
                    end
                else
                    begin
                        toggle_read_req <= toggle_read_req ^ register_fld_read_enb;
                    end
            end // always clk
            
            // Read Req FF chain
            
            always @(posedge hw_clk)
                begin
                if(!reset_l)always @(posedge hw_clk)
                    begin
                    if(!reset_l)
                        begin
                            register_read_req_ff0 <= 1'b0;
                            register_read_req_ff1 <= 1'b0;
                        end
                    else
                        begin
                            register_read_req_ff1 <= toggle_read_req;
                            register_read_req_ff0 <= register_read_req_ff1;
                        end
                end // always hw_clk
                
                // load_pulse
                
                always @(posedge hw_clk)
                    begin
                    if(!reset_l)always @(posedge hw_clk)
                        begin
                        if(!reset_l)
                            
                            begin
                                toggle_read_load_ff <= 1'b0;
                                load_data <= 1'b0;
                            end
                        else
                            begin
                                toggle_read_load_ff <= register_read_req_ff0;
                                load_data <= register_read_req_ff0 ^ toggle_read_load_ff;
                            end
                    end // always hw_clk
                    
                    // Load *_fld_r logic
                    
                    always @(posedge hw_clk)
                        begin
                        if(!reset_l)always @(posedge hw_clk)
                            begin
                            if(!reset_l)
                                begin
                                    register_fld_r <= register_fld_q;
                                end
                            else
                                begin
                                    register_fld_r <= load_data ? register_fld_q_ff : register_fld_r;
                                end
                        end // always hw_clk
                        
                        // Read Ack FF chain
                        
                        always @(posedge clk)
                            begin
                            if(!reset_l)
                                begin
                                    register_read_ack_ff0 <= 1'b0;
                                    register_read_ack_ff1 <= 1'b0;
                                end
                            else
                                begin
                                    register_read_ack_ff1 <= register_read_req_ff0;
                                    register_read_ack_ff0 <= register_read_ack_ff1;
                                end
                        end // always clk
                        
                        // Read Req Clear logic
                        
                        always @(posedge clk)
                            begin
                            if(!reset_l)
                                begin
                                    toggle_read_ack_ff <= 1'b0;
                                    req_clear <= 1'b0;
                                end
                            else
                                begin
                                    toggle_read_ack_ff <= register_read_ack_ff0;
                                    req_clear <= register_read_ack_ff0 ^ toggle_read_ack_ff;
                                end
                        end // always clk
                    endmodule
                    
                    
                    module handshake_synchronizer_write(
                        clk,
                        reset_l,
                        hw_clk,
                        register_fld_in,
                        register_fld_in_enb,
                        register_fld_in_ff,
                        register_fld_in_enb_ff,
                        register_fld_busy_out
                        );
                        parameter field_width = 32;
                        localparam write_idle	= 1'b0;
                        localparam write_waiting = 1'b1;
                        input clk;
                        input hw_clk;
                        input reset_l;
                        input [field_width - 1 : 0]register_fld_in;
                        input register_fld_in_enb;
                        output reg [field_width - 1 : 0]register_fld_in_ff;
                        output register_fld_in_enb_ff;
                        output register_fld_busy_out;
                        reg register_write_state;
                        reg register_write_req_ff2;
                        reg register_write_req_ff1;
                        reg register_write_req_ff0;
                        wire register_write_ack_ff2;
                        reg register_write_ack_ff1;
                        reg register_write_ack_ff0;
                        
                        // WRITE FSM
                        
                        always @(posedge hw_clk)
                            begin
                            if(!reset_l)always @(posedge hw_clk)
                                begin
                                if(!reset_l)
                                    begin
                                        register_write_req_ff2 <= 1'b0;
                                        register_write_state <= write_idle;
                                        register_fld_in_ff <= {field_width{1'b0}};
                                    end
                                else
                                    begin
                                        case(register_write_state)
                                            write_idle : begin
                                            if(register_fld_in_enb)
                                                begin
                                                    register_fld_in_ff <= register_fld_in;
                                                    register_write_req_ff2 <= 1'b1;
                                                    register_write_state <= write_waiting;
                                                end
                                            end
                                            write_waiting : begin
                                            if(register_write_ack_ff0)
                                                begin
                                                    register_write_req_ff2 <= 1'b0;
                                                    register_write_state <= write_idle;
                                                end
                                            end
                                            default : begin
                                                register_write_state <= write_idle;
                                            end
                                        endcase
                                    end
                            end // always hw_clk
                            
                            assign register_fld_busy_out = register_write_req_ff2;
                            
                            // Write Req FF chain
                            always @(posedge clk)
                                begin
                                if(!reset_l)
                                    begin
                                        register_write_req_ff0 <= 1'b0;
                                        register_write_req_ff1 <= 1'b0;
                                    end
                                else
                                    begin
                                        register_write_req_ff1 <= register_write_req_ff2;
                                        register_write_req_ff0 <= register_write_req_ff1;
                                    end
                            end // always clk
                            
                            assign register_fld_in_enb_ff = register_write_req_ff0;
                            assign register_write_ack_ff2 = register_write_req_ff0;
                            
                            // Write Ack FF chain
                            always @(posedge hw_clk)
                                begin
                                if(!reset_l)always @(posedge hw_clk)
                                    begin
                                    if(!reset_l)
                                        begin
                                            register_write_ack_ff0 <= 1'b0;
                                            register_write_ack_ff1 <= 1'b0;
                                        end
                                    else
                                        begin
                                            register_write_ack_ff1 <= register_write_ack_ff2;
                                            register_write_ack_ff0 <= register_write_ack_ff1;
                                        end
                                end // always hw_clk
                            endmodule
