// Blah blah blah boilerplate
// Auto-generated by csv2xxx.py - do not hand-edit
    `ifndef IDS_UDP

    `endif

addrmap ctrl_top {
  name = "ctrl_top Address Map";

  reg otpm_status {
    desc = "Sensor OTPM status";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "OTPM Read/Write Operation complete.";
    } op_done[0:0] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Check bits produced by ECC.";
    } check_bits[6:1] = 6'h0;
    field {
      hw = r;
      sw = r;
      desc = "ECC single bit error correction activated.";
    } sec_used[7:7] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Double error-detect parity failure and data is bad.";
    } parity_failure[8:8] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "OTPM is full.";
    } otpm_full[9:9] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Insufficient OTPM space to include a record.";
    } otpm_insufficient[10:10] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "True (1) when sequencer is idle and OTPM timing has completed.";
    } otpm_busy[11:11] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Accumulation of Single Error Correction (SEC) errors for all reads (except invalidation). A SEC error is a single bit error that has been corrected by CRC code. SEC errors are non fatal and  provide some status as to the state of the OTPM device.  This register is reset at start of a command.";
    } sec_count[15:12] = 4'h0;
  };

  reg otpm_status2 {
    desc = "Sensor OTPM status. See otpm documentation";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "Indicates whether the automatic write sequence is finished.";
    } auto_wr_end[1:1] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Indicates whether the single read sequence is finished.";
    } auto_wr_success[2:2] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Indicates whether the automatic read sequence is finished.";
    } auto_rd_end[5:5] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Indicates whether the automatic read sequence was successful.";
    } auto_rd_success[6:6] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Indicates whether the single write sequence is finished.";
    } single_wr_end[9:9] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Indicates whether the single write sequence was successful.";
    } single_wr_success[10:10] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Indicates whether the single read sequence is finished.";
    } single_rd_end[13:13] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Indicates whether the single read sequence was successful.";
    } single_rd_success[14:14] = 1'h0;
  };

  reg asil_status_02 {
    desc = "Each bit of this register is automatically set if a corresponding check enable bit is set and the corresponding check fails during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates the status of thefixed table CRC and fixed_tbl_reg_cmp check. Only valid when bit 0 of  ASIL_CHECK_ENABLE_02 is asserted. When set the check has failed.";
    } tbrs_tbl_crc_status[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates the status of the of the locked RAM CRC check.  Only valid when bit 1 of  ASIL_CHECK_ENABLE_02 is asserted. When set the CRC check has failed.";
    } tbrs_ram_crc_status[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates the status of the shutter address SM CRC check";
    } address_sm_crc_status[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates the status of the embedded register CRC check";
    } embedded_crc_status[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates the status of image DTR region CRC check";
    } dtr_crc_status[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates the status of image FRAME or ROW CRC check";
    } row_frame_crc_status[15:15] = 1'h0;
  };

  reg asil_startup_status_00 {
    desc = "Each bit of this register is automatically set if a corresponding check enable bit is set and the corresponding check fails during startup";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "m3rom scan status. 0 - Pass. 1 - Fail";
    } startup_m3rom_status[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "OTPM scan status. 0 - Pass. 1 - Fail";
    } otpm_scan_status[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Ireg scan status. 0 - Pass. 1 - Fail";
    } ireg_scan_status[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "PDI scan status. 0 - Pass. 1 - Fail";
    } pdi_scan_status[3:3] = 1'h0;
  };

  reg asil_status_05 {
    desc = "Each bit of this register is automatically set if a corresponding check enable bit is set and the corresponding check fails during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Sreg write addr data mismatch from AHM";
    } bad_wraddr[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Sreg write data mismatch from AHM";
    } bad_wrdata[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Sreg read data mismatch from AHM";
    } bad_rddta[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates PMU Sreg write addr data mismatch from AHM";
    } pmu_bad_wraddr[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates PMU Sreg write data mismatch from AHM";
    } pmu_bad_wrdata[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates PMU Sreg read data mismatch from AHM";
    } pmu_bad_rddata[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates a transient error detected in Sequencer1 execution";
    } seq1_transient_crc_err_orig[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates a transient error detected in Sequencer2 execution";
    } seq2_transient_crc_err_orig[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates RNC and DBLC correction value calculated from DTR pixel data does not match expected value";
    } rnc_dblc_dtr_fault[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates camera service extension error on I2C bus has occurred";
    } cse_fault[15:15] = 1'h0;
  };

  reg asil_status_06 {
    desc = "Each bit of this register is automatically set if a corresponding check enable bit is set and the corresponding check fails during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates OTPM cache RAM ECC single bit error correction status";
    } otpm_ram_sec[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Channel converter RAM ECC single bit error correction status";
    } conv_ram_sec[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates DCDS RAM ECC single bit error correction status";
    } dcds_ram_sec[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Analog to Digital asynch FIFO RAM ECC single bit error correction status";
    } digclk_ram_sec[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Overflow linearization RAM ECC single bit error correction status";
    } ofl_ram_ecc_sec[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Pixel Defect Identification base RAM ECC single bit error correction status";
    } pdi_base_ram_sec[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Pixel Defect Identification stream RAM ECC single bit error correction status";
    } pdi_stream_ram_sec[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Delay Buffer RAM ECC single bit error correction status";
    } delay_buffer_ram_sec[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Pixel defect correction RAM ECC single bit error correction status";
    } pdc_ram_sec[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Secondary path ODP FIFO RAM ECC single bit error correction status";
    } odp2_ram_sec[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Primary path ODP FIFO RAM ECC single bit error correction status";
    } odp1_ram_sec[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Context switch RAM ECC single bit error correction status";
    } ctx_ram_ecc_sec[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates TBRS RAM ECC single bit error correction status";
    } tbrs_ram_ecc_sec[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates OTPM record ECC single bit error correction status";
    } otpm_ecc_sec[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates SEQ2 RAM ECC single bit error correction status";
    } seq2_ram_ecc_sec[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates SEQ1 RAM ECC single bit error correction status";
    } seq_ram_ecc_sec[15:15] = 1'h0;
  };

  reg i2c_wrt_count {
    desc = "Each time a data value is applied to I2C_WRT_CHECKSUM (R0x31d6) this register is incremented by 1<COMMA> modulo 2^16. This register is reset to 0 when I2C_WRT_CHECKSUM is re-initialised.";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "Each time a data value is applied to I2C_WRT_CHECKSUM (R0x31d6) this register is incremented by 1<COMMA> modulo 2^16. This register is reset to 0 when I2C_WRT_CHECKSUM is re-initialised.";
    } i2c_wrt_count[15:0] = 16'h0;
  };

  reg tempsens1_dec_ratio {
    desc = "Final divder used to get the required value to 19 bit code. Increasing the ratio reduces the acucray and decreasing the ratio saturates the code";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Final divder used to get the required value to 19 bit code. Increasing the ratio reduces the acucray and decreasing the ratio saturates the code";
    } decimation_ratio[11:0] = 12'h177;
  };

  reg tempsens1_max_bs {
    desc = "Decides the numbers of sigma delta cycle. Increasing the cycles increases the accuracy but also the conversion time. Decreasing it redeuces the accuracy. Conversion will be faster";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Decides the numbers of sigma delta cycle. Increasing the cycles increases the accuracy but also the conversion time. Decreasing it redeuces the accuracy. Conversion will be faster";
    } max_bs[11:0] = 12'h420;
  };

  reg tempsens1_init_test_ctrl {
    desc = "No of cycles the ADC is initialized (Auto zero) . Increasing beyond the default threshold doesn't impact the conversion. Reducing it will affect the initial cycles of conversion.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "No.of cycles required for intialization";
    } init_cycle[7:0] = 8'h14;
    field {
      hw = r;
      sw = rw;
      desc = "Used for testing various voltages and currents used in the IP";
    } tempsens1_test_ctrl[14:8] = 7'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Clock gating used in the IP";
    } tsens_clk_en[15:15] = 1'h1;
  };

  reg tempsens1_chop_cycle {
    desc = "Register to hold tempsensor chop cycle  diode_en and test_en control information";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "The chop swicthes used inside the ADC are swapped after these many sigma delta cycles. This is to reduce the low frequency noise in the modulator. It is calculated as no of sigma delta cycles/6";
    } chop_cycle[9:0] = 10'hb0;
    field {
      hw = r;
      sw = rw;
      desc = "Not used to connect IP directly. When in 01 & 10 mode diode1 & diode2 default registers are loaded to IP respectively; else IP deafults for trims are loaded";
    } t_diode_en[13:12] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Not connected at IP level; used for scan purpose";
    } temps_test_en[14:14] = 1'h0;
  };

  reg tempsens1_lookup_addr_offset {
    desc = "Register holds Lookup table controls of temperature sensor";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the lookup table diigtal correction";
    } lookup_table_enable[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Minimum number of 1's to be recevied every 32 cycles to start applying the corrections. The number of 1's is calculted based on output avg32_sum";
    } lookup_table_addr_offset[5:1] = 5'ha;
    field {
      hw = r;
      sw = rw;
      desc = "MSB of Minimum correction to the applied on the output code";
    } lookup_table_data_offset_16[15:15] = 1'h1;
  };

  reg tempsens1_lookup_data_offset {
    desc = "Minimum correction to the applied on the output code";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Minimum correction to the applied on the output code";
    } lookup_table_data_offset[15:0] = 16'hfe89;
  };

  reg tempsens1_lookup_weight {
    desc = "Lookup table weight used in linearity correction";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Minimum jump in code for change in avg code";
    } lookup_table_weight[13:0] = 14'h177;
  };

  reg tempsens1_lookup_tab_0 {
    desc = "Register holds temperature sensor lookup table data 0 1  2";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 0";
    } lookup_table_0[4:0] = 5'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 1";
    } lookup_table_1[9:5] = 5'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 2";
    } lookup_table_2[14:10] = 5'h1;
  };

  reg tempsens1_lookup_tab_1 {
    desc = "Register holds temperature sensor lookup table data 3  4  5";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 3";
    } lookup_table_3[4:0] = 5'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 4";
    } lookup_table_4[9:5] = 5'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 5";
    } lookup_table_5[14:10] = 5'h1;
  };

  reg tempsens1_lookup_tab_2 {
    desc = "Register holds temperature sensor lookup table data 6  7  8";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 6";
    } lookup_table_6[4:0] = 5'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 7";
    } lookup_table_7[9:5] = 5'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 8";
    } lookup_table_8[14:10] = 5'h2;
  };

  reg tempsens1_lookup_tab_3 {
    desc = "Register holds temperature sensor lookup table data 9 10   11";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 9";
    } lookup_table_9[4:0] = 5'h3;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 10";
    } lookup_table_10[9:5] = 5'h6;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 11";
    } lookup_table_11[14:10] = 5'h9;
  };

  reg tempsens1_lookup_tab_4 {
    desc = "Register holds temperature sensor lookup table data 12  13";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 12";
    } lookup_table_12[4:0] = 5'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Correction to be applied for a recevied average code 13";
    } lookup_table_13[9:5] = 5'h0;
  };

  reg tempvsens1_sreg_diode1_trim_vbe {
    desc = "Register holds sreg diode 1 trim vbe controls of temperature sensor";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode1 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_diode1_trim_i_vbe_cc1[3:0] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode1 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_diode1_trim_i_vbe_cc2[7:4] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Additional current to be pumped to generate VBE. Increasing this bit will reduce VBE and effect of current on code nonlinearity can be adjusted using this. This is used when diode1 is selected";
    } sreg_diode1_trim_i_vbe_wo_cc[11:8] = 4'h8;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode1 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_diode1_trim_i_vbe_gen[14:12] = 3'h0;
  };

  reg tempvsens1_sreg_diode2_trim_vbe {
    desc = "Register holds sreg diode 2 trim vbe controls of temperature sensor";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode2 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_diode2_trim_i_vbe_cc1[3:0] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode2 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_diode2_trim_i_vbe_cc2[7:4] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Additional current to be pumped to generate VBE. Increasing this bit will reduce VBE and effect of current on code nonlinearity can be adjusted using this. This is used when diode2 is selected";
    } sreg_diode2_trim_i_vbe_wo_cc[11:8] = 4'h8;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode2 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_diode2_trim_i_vbe_gen[14:12] = 3'h0;
  };

  reg tempvsens1_sreg_ip_trim_vbe {
    desc = "temperature sensor VBE trims";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode2 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_ip_trim_i_vbe_cc1[3:0] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode2 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_ip_trim_i_vbe_cc2[7:4] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Additional current to be pumped to generate VBE. Increasing this bit will reduce VBE and effect of current on code nonlinearity can be adjusted using this. This is used when diode2 is selected";
    } sreg_ip_trim_i_vbe_wo_cc[11:8] = 4'h8;
    field {
      hw = r;
      sw = rw;
      desc = "These are the trims for VBE current that would be applied to IP when diode2 is selected in curvature correction mode. This fucntionality is of curvature correction is not used in AR0823";
    } sreg_ip_trim_i_vbe_gen[14:12] = 3'h0;
  };

  reg tempvsens1_sreg_diode1_trim_fine {
    desc = "Register holds sreg diode1 trim fine control information of temperature sensor";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode1 and not used in AR0823";
    } sreg_diode1_trim_fine_cc1_off[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode1 and not used in AR0823";
    } sreg_diode1_trim_fine_cc1_on[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode1 and not used in AR0823";
    } sreg_diode1_trim_fine_cc2_off[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode1 and not used in AR0823";
    } sreg_diode1_trim_fine_cc2_on[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode1 and not used in AR0823";
    } sreg_diode1_trim_fine_vbe_gen_off[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode1 and not used in AR0823";
    } sreg_diode1_trim_fine_vbe_gen_on[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE without curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode1";
    } sreg_diode1_trim_fine_wo_cc_off[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE without curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode1";
    } sreg_diode1_trim_fine_wo_cc_on[7:7] = 1'h1;
  };

  reg tempvsens1_sreg_diode2_trim_fine {
    desc = "Register holds sreg diode2 trim fine control information of temperature sensor";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode2 and not used in AR0823";
    } sreg_diode2_trim_fine_cc1_off[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode2 and not used in AR0823";
    } sreg_diode2_trim_fine_cc1_on[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode2 and not used in AR0823";
    } sreg_diode2_trim_fine_cc2_off[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode2 and not used in AR0823";
    } sreg_diode2_trim_fine_cc2_on[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode2 and not used in AR0823";
    } sreg_diode2_trim_fine_vbe_gen_off[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode2 and not used in AR0823";
    } sreg_diode2_trim_fine_vbe_gen_on[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE without curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode2";
    } sreg_diode2_trim_fine_wo_cc_off[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE without curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for diode2";
    } sreg_diode2_trim_fine_wo_cc_on[7:7] = 1'h1;
  };

  reg tempvsens1_sreg_ip_trim_fine {
    desc = "Register holds sreg IP trim fine control information of temperature sensor";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for ip and not used in AR0823";
    } sreg_ip_trim_fine_cc1_off[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for ip and not used in AR0823";
    } sreg_ip_trim_fine_cc1_on[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for ip and not used in AR0823";
    } sreg_ip_trim_fine_cc2_off[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for ip and not used in AR0823";
    } sreg_ip_trim_fine_cc2_on[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for ip and not used in AR0823";
    } sreg_ip_trim_fine_vbe_gen_off[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE during curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for ip and not used in AR0823";
    } sreg_ip_trim_fine_vbe_gen_on[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE without curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for ip";
    } sreg_ip_trim_fine_wo_cc_off[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "The ON OFF control for fine trimming of VBE without curvature correction mode based on the bit stream obtained. When both ON & OFF are 1 or 0 ; fine trim is applied; when ON-1 and OFF-0 one additional current source  is always applied for VBE generation. When ON-0 and OFF-1 the number of source would be same as default set in cc1 and cc2. This is for ip";
    } sreg_ip_trim_fine_wo_cc_on[7:7] = 1'h1;
  };

  reg tempvsens1_sreg_trim_v_iptat {
    desc = "cfg[43:28] control information temperature sensor";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "constant voltage trim for curvature correction. Not used in 341. Was part of 823";
    } sreg_trim_cons_v[2:0] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "constant voltage trim for curvature correction. Not used in 341. Was part of 823";
    } sreg_trim_cons_v_2[5:3] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Used to trim the currents required for vbe and del_VBE gen.The currents are trimmed by taking them onto atest using appropriate test_ctrl . Increasing the trim reduces the currents";
    } sreg_trim_vbe_iptat[10:6] = 5'he;
    field {
      hw = r;
      sw = rw;
      desc = "Used to trim the currents required for vbg and the ADC.The currents are trimmed by taking them onto atest using appropriate test_ctrl . Increasing the trim reduces the currents";
    } sreg_trim_vbg_iptat[15:11] = 5'hf;
  };

  reg tempvsens1_sreg_trim_vbg_refbuf {
    desc = "This register holds the vbe and vbg trim control information";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "";
    } sreg_cfg_44_to_45[1:0] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Used to get the required VBG value. Increasing the trim increases the VBG value. VBG is trimmed by getting it on atest using appropriate test_ctrl";
    } sreg_trim_vbg_1v0[7:2] = 6'h1d;
    field {
      hw = r;
      sw = rw;
      desc = "Used to enable the chopping and dem operation inside the vbg generation block when normal temeprature mode is selected";
    } sreg_ts_mode_dem_chop_en_1v0[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Used the set the startup current required for vbe gen bandgap. Increasing the trim increases the current.";
    } sreg_strtup_trim_vbe_1v0[10:9] = 2'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Used the set the startup current required for vbg gen bandgap. Increasing the trim increases the current.";
    } sreg_strtup_trim_vbg_1v0[12:11] = 2'h1;
  };

  reg tempvsens1_sreg_cfg_0_to_12 {
    desc = "temperature sensor config bits";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Curvature correction enable block. Used in 823 not in 341";
    } sreg_cc_en[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the chop operation inside error amplifier of del_VBE gen";
    } sreg_chop_err_amp_vbe_en[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the chop operation inside error amplifier of vbg gen bandgap";
    } sreg_chop_err_amp_vbg_en[2:2] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "VBE buff chop enable used in 823 not in 341";
    } sreg_chop_vbe_ref_buf_en[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the chop operation inside vbg ref buffer";
    } sreg_chop_vbg_ref_buf_en[4:4] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the dem operation inside for del_VBE gen";
    } sreg_dem_del_vbe_en[5:5] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the dem operation inside for VBE gen";
    } sreg_dem_vbe_en[6:6] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "VBE gen dem enable used in 823 not in 341";
    } sreg_dem_vbe_gen_en[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the dem operation inside for generating PTAT current in del_VBE gen block";
    } sreg_dem_vbe_iptat_en[8:8] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the dem operation inside for vbg gen";
    } sreg_dem_vbg_en[9:9] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the dem operation inside for generating PTAT current in del_VBE gen block";
    } sreg_dem_vbg_iptat_en[10:10] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "safety mode control . Used in 823 not in 341";
    } sreg_safety_en[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Disable the modulator";
    } sreg_mod_pwr_dn[12:12] = 1'h0;
  };

  reg tempvsens1_sreg_cfg_54_to_69 {
    desc = "This register holds temperature sensor cfg pin[69:54]";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Curvature correction power down used in 823 not in 341";
    } sreg_cc_pwr_dn[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Curavture correction mirror width selection used in 823 not in 341";
    } sreg_cc_width_sel_en_in[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Chop control in curbvature correction used in 823 not in 341";
    } sreg_cc_chop_en[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Set the clk delay from theclk gen block for ADC. Increasing the trim will increase the delay";
    } sreg_clk_del_trim[4:3] = 2'h2;
    field {
      hw = r;
      sw = rw;
      desc = "To trim the non overalp period of clk used in ADC. Increasing the trim increases the non overlap period";
    } sreg_del_trim[6:5] = 2'h2;
    field {
      hw = r;
      sw = rw;
      desc = "To trim the common mode voltage used inside ADC. Increasing the trim increases the voltage";
    } sreg_vcm_trim[8:7] = 2'h2;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the resistor divider during calibration using external voltage. Higher voltage is forced on atest and divided to get the required voltage";
    } sreg_en_calib_div[9:9] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Use 3 accumulators in decimation filter to increase the overall accurayc of conversion. If 0 uses only 2 stage accumulator and ADC resolution decreases";
    } use_3rd_stage[10:10] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the dem on sampling caps used in modulator";
    } dem_cap_en[11:11] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "enable the chopping operation of integrator inpouts and outputs in modulator";
    } chop_mod_en[12:12] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "To enable control of the chop signal for del_VBE gen bandgap";
    } control_chop[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "To set which of the chop should be used in del_VBE gen block";
    } chop_err_amp_vbe_sel[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "To enable control of the dem switches for del_VBE gen bandgap";
    } control_dem[15:15] = 1'h0;
  };

  reg tempvsens1_sreg_cfg_70_to_80 {
    desc = "73:70 <3:0>: dem_vbe_sel - Choose what dem swicth should be enabled for vbe generation; 77:74 <7:4> : dem_del_vbe_sel -  Choose what dem swicth should be enabled for del_vbe generation;  80:78 <10:8> : dem_vbe_iptat_sel -  Choose what dem swicth should be enabled for del-VBE gen block current generation";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Choose what dem swicth should be enabled for vbe generation";
    } dem_vbe_sel[3:0] = 4'h8;
    field {
      hw = r;
      sw = rw;
      desc = "Choose what dem swicth should be enabled for del_vbe generation";
    } dem_del_vbe_sel[7:4] = 4'h8;
    field {
      hw = r;
      sw = rw;
      desc = "Choose what dem swicth should be enabled for del_VBE gen block current generation";
    } dem_vbe_iptat_sel[10:8] = 3'h4;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving TS SC sequence in standby mode;[11]   : Drive as 1st SM sequence;[12]   : Drive as 2nd SM sequence;[13]   : Drive as 3rd SM sequence;[14]   : Drive as 4th SM sequence;[15]   : Drive as 5th SM sequence";
    } stndby_seq_mode_sel_sc[15:11] = 5'h10;
  };

  reg tempvsens1_sm_seq_ctrl {
    desc = "This register holds the tempsensor SM sequence control information";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for SM sequence in streaming mode";
    } sm_seq_stream_mode_en[0:0] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for SM sequence in standby mode";
    } sm_seq_stndby_mode_en[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Priority mode select enable for SM sequence in streaming mode";
    } sm_seq_stream_mode_sel_en[2:2] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Priority mode select enable for SM sequence in streaming mode";
    } sm_seq_stndby_mode_sel_en[3:3] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for driving SM sequences in stream mode; [4]   : TS SM sequence; [5]   : D1 SM sequence; [6]   : D2 SM sequence; [7]   : SP SM sequence; [8]   : SC SM sequence";
    } sm_seq_ctrl_stream[8:4] = 5'h1f;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for driving SM sequences in standby mode; [9]     : TS SM sequence; [10]   : D1 SM sequence; [11]   : D2 SM sequence; [12]   : SP SM sequence; [13]   : SC SM sequence";
    } sm_seq_ctrl_stndby[13:9] = 5'h1f;
  };

  reg tempvsens1_sm_seq_sel0 {
    desc = "This register holds temp sensor Streaming mode TS; D1 and D2  SM sequence mode select order information";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving TS SM sequence in streaming mode; [0]   : Drive as 1st SM sequence; [1]   : Drive as 2nd SM sequence; [2]   : Drive as 3rd SM sequence; [3]   : Drive as 4th SM sequence; [4]   : Drive as 5th SM sequence";
    } stream_seq_mode_sel_ts[4:0] = 5'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving D1 SM sequence in streaming mode; [5]   : Drive as 1st SM sequence; [6]   : Drive as 2nd SM sequence; [7]   : Drive as 3rd SM sequence; [8]   : Drive as 4th SM sequence; [9]   : Drive as 5th SM sequence";
    } stream_seq_mode_sel_d1[9:5] = 5'h2;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving D2 SM sequence in streaming mode; [10]   : Drive as 1st SM sequence; [11]   : Drive as 2nd SM sequence; [12]   : Drive as 3rd SM sequence; [13]   : Drive as 4th SM sequence; [14]   : Drive as 5th SM sequence";
    } stream_seq_mode_sel_d2[14:10] = 5'h4;
  };

  reg tempvsens1_sm_seq_sel1 {
    desc = "This register holds temp sensor Standby mode TS; Streaming mode  D1 and D2  SM sequence mode select order information";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving SP SM sequence in streaming mode; [0]   : Drive as 1st SM sequence; [1]   : Drive as 2nd SM sequence; [2]   : Drive as 3rd SM sequence; [3]   : Drive as 4th SM sequence; [4]   : Drive as 5th SM sequence";
    } stream_seq_mode_sel_sp[4:0] = 5'h8;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving SC SM sequence in streaming mode; [5]   : Drive as 1st SM sequence; [6]   : Drive as 2nd SM sequence; [7]   : Drive as 3rd SM sequence; [8]   : Drive as 4th SM sequence; [9]   : Drive as 5th SM sequence";
    } stream_seq_mode_sel_sc[9:5] = 5'h10;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving TS SM sequence in standby mode; [10]   : Drive as 1st SM sequence; [11]   : Drive as 2nd SM sequence; [12]   : Drive as 3rd SM sequence; [13]   : Drive as 4th SM sequence; [14]   : Drive as 5th SM sequence";
    } stndby_seq_mode_sel_ts[14:10] = 5'h1;
  };

  reg tempvsens1_sm_seq_sel2 {
    desc = "This register holds temp sensor Standby mode SP; D1 and D2  SM sequence mode select order information";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving D1 SM sequence in standby mode; [0]   : Drive as 1st SM sequence; [1]   : Drive as 2nd SM sequence; [2]   : Drive as 3rd SM sequence; [3]   : Drive as 4th SM sequence; [4]   : Drive as 5th SM sequence";
    } stndby_seq_mode_sel_d1[4:0] = 5'h2;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving D2 SM sequence in standby mode; [5]   : Drive as 1st SM sequence; [6]   : Drive as 2nd SM sequen; [9]   : Drive as 5th SM sequencece; [7]   : Drive as 3rd SM sequence; [8]   : Drive as 4th SM sequence";
    } stndby_seq_mode_sel_d2[9:5] = 5'h4;
    field {
      hw = r;
      sw = rw;
      desc = "Select the priority sequence order for driving SP SM sequence in standby mode; [10]   : Drive as 1st SM sequence; [11]   : Drive as 2nd SM sequence; [12]   : Drive as 3rd SM sequence; [13]   : Drive as 4th SM sequence; [14]   : Drive as 5th SM sequence";
    } stndby_seq_mode_sel_sp[14:10] = 5'h8;
  };

  reg tempvsens1_data_sc_exp {
    desc = "Threshold for safery_cons mode status generation";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Threshold for safery_cons mode status generation";
    } tempvsens1_data_sc_exp[15:0] = 16'hd2e8;
  };

  reg tempvsens1_data_sc_off {
    desc = "This register holds ASIL check SM Threshold for safery_cons mode status generation";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "safety_cons mode status is set if (Tempsens1_data_sc_exp-Tempsens1_data_sc_off)  < temp_value (in safety_cons mode) < (Tempsens1_data_sc_exp+Tempsens1_data_sc_off)";
    } tempvsens1_data_sc_offset[12:0] = 13'h1fff;
    field {
      hw = r;
      sw = rw;
      desc = "Threshold for safery_cons mode status generation";
    } tempvsens1_data_sc_exp_ext[15:13] = 3'h3;
  };

  reg temp_value_k_diff_off {
    desc = "safety_ptat mode status is set if (temp_value_k (in safety_ptat mode) -temp_value_k_diff_off)  < temp_value_k (in normal IP mode) < (temp_value_k (in safety_ptat mode) + temp_value_k_diff_off)";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "safety_ptat mode status is set if (temp_value_k (in safety_ptat mode) -temp_value_k_diff_off)  < temp_value_k (in normal IP mode) < (temp_value_k (in safety_ptat mode) + temp_value_k_diff_off)";
    } temp_value_k_diff_off[12:0] = 13'h30;
  };

  reg otpm_core_crc_status {
    desc = "LSB (otpm_crc_done) is set high when the OTPM CRC calculation is done and the OTPM FSM returns to Idle state.";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } factory_crc_rec_present[0:0] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "";
    } factory_crc_check_done[1:1] = 1'h1;
    field {
      hw = r;
      sw = r;
      desc = "";
    } factory_crc_check_good[2:2] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "";
    } customer_crc_rec_present[3:3] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "";
    } customer_crc_check_done[4:4] = 1'h1;
    field {
      hw = r;
      sw = r;
      desc = "";
    } customer_crc_check_good[5:5] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_crc_done[7:7] = 1'h0;
  };

  reg otpm_core_crc_code_lo {
    desc = "OTPM0/1 CRC code [15:0]";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "OTPM0/1 CRC code [15:0]";
    } otpm_core_crc_code_lo[15:0] = 16'hffff;
  };

  reg otpm_core_crc_code_hi {
    desc = "OTPM0/1 CRC code [31:16]";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "OTPM0/1 CRC code [31:16]";
    } otpm_core_crc_code_hi[15:0] = 16'hffff;
  };

  reg otpm_core_crc_code_extra {
    desc = "OTPM0/1 CRC code [47:32]";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "OTPM0/1 CRC code [47:32]";
    } otpm_core_crc_code_extra[15:0] = 16'hffff;
  };

  reg ctx_rd_data_reg {
    desc = "Read from next address in context RAM and increment address. The address is reset by any write to CTX_CONTROL_REG (R0x3034). In order to read the context RAM using this register<COMMA> start an I2C read from this register and continue with no STOP until all of the data has been read. An alternative way to read the context RAM is to use CTX_CONTROL_REG.CTX_I2C_ADDR_SEL to map the context RAM into the address space.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Read from next address in context RAM and increment address. The address is reset by any write to CTX_CONTROL_REG (R0x3034). In order to read the context RAM using this register<COMMA> start an I2C read from this register and continue with no STOP until all of the data has been read. An alternative way to read the context RAM is to use CTX_CONTROL_REG.CTX_I2C_ADDR_SEL to map the context RAM into the address space.";
    } ctx_rd_data_reg[15:0] = 16'h0;
  };

  reg seq_ctrl_port {
    desc = "Register controlling the read and write to sequencer RAM.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Sequencer memory address to access<COMMA> write or read.";
    } access_addr[11:0] = 12'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Disable ECC generation during writes to sequencer memory. Provided as a simple mechanism to demostrate that the ECC generation and error-flagging is functioning correctly.";
    } seq_ecc_bypass[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Address auto increment after every sequencer data read cycle";
    } seq_ctrl_port_auto_inc_on_read[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Status for sequencer state.<NEWLINE>1: Sequencer stopped<NEWLINE>0: Sequencer running";
    } sequencer_stopped[15:15] = 1'h1;
  };

  reg tempvsens1_m1_hi_sm2 {
    desc = "This register holds slope  value m1[31:16] between -40C to 60C derived after calibration; used for Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between -40C to 60C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for diode2";
    } tempsens1_m1_sm2_hi[15:0] = 16'h0;
  };

  reg tempvsens1_m1_lo_sm2 {
    desc = "This register holds slope  value m1[15:0] between -40C to 60C derived after calibration; used for Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between -40C to 60C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for diode2";
    } tempsens1_m1_sm2_lo[15:0] = 16'hb31;
  };

  reg tempvsens1_c1_hi_sm2 {
    desc = "This register holds the intercept value value c1[31:16]) between -40C to 60C derived after calibration; used for Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between -40C to 60C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for diode2";
    } tempsens1_c1_sm2_hi[15:0] = 16'h1f;
  };

  reg tempvsens1_c1_lo_sm2 {
    desc = "This register holds the intercept value value c1[15:0]) between -40C to 60C derived after calibration; used for Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between -40C to 60C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for diode2";
    } tempsens1_c1_sm2_lo[15:0] = 16'he6a0;
  };

  reg tempvsens1_m2_hi_sm2 {
    desc = "This register holds the slope value m2[31:16] between 60C to 125C derived after calibration; used for Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between 60C to 125C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for diode2";
    } tempsens1_m2_sm2_hi[15:0] = 16'h0;
  };

  reg tempvsens1_m2_lo_sm2 {
    desc = "This register holds the slope value m2[15:0] between 60C to 125C derived after calibration; used for Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between 60C to 125C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for diode2";
    } tempsens1_m2_sm2_lo[15:0] = 16'hb31;
  };

  reg tempvsens1_c2_hi_sm2 {
    desc = "This register holds the intercept value value c2[31:16]) between 60C to 125C derived after calibration; used for Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between 60C to 125C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for diode2";
    } tempsens1_c2_sm2_hi[15:0] = 16'h1f;
  };

  reg tempvsens1_c2_lo_sm2 {
    desc = "This register holds the intercept value value c2[15:0]) between 60C to 125C derived after calibration; used for Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between 60C to 125C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for diode2";
    } tempsens1_c2_sm2_lo[15:0] = 16'he6a0;
  };

  reg otpm_status3 {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } factory_partition_locked[0:0] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "";
    } customer_partition_locked[1:1] = 1'h0;
    field {
      hw = r;
      sw = r;
      desc = "Cybersecurity disabled: otpm_status3[3:2] = 2b01 Cybersecurity enabled: otpm_status3[3:2] = 2b11<NEWLINE>";
    } cyber_security_status[3:2] = 2'h0;
  };

  reg asil_status_07 {
    desc = "Each bit of this register is automatically set if a corresponding check enable bit is set and the corresponding check fails during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates OTPM cache RAM ECC double error detected status";
    } otpm_ram_ded[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Channel converter RAM ECC double error detected status";
    } conv_ram_ded[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates DCDS RAM ECC double error detected status";
    } dcds_ram_ded[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Analog to Digital asynch FIFO RAM ECC double error detected status";
    } digclk_ram_ded[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Overflow linearization RAM ECC double error detected status";
    } ofl_ram_ecc_ded[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Pixel Defect Identification base RAM ECC double error detected status";
    } pdi_base_ram_ded[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Pixel Defect Identification stream RAM ECC double error detected status";
    } pdi_stream_ram_ded[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Delay Buffer RAM ECC double error detected status";
    } delay_buffer_ram_ded[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Pixel defect correction RAM ECC double error detected status";
    } pdc_ram_ded[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Secondary path ODP FIFO RAM ECC double error detected status";
    } odp2_ram_ded[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Primary path ODP FIFO RAM ECC double error detected status";
    } odp1_ram_ded[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates Context switch RAM ECC double error detected status";
    } ctx_ram_ecc_ded[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates TBRS RAM ECC double error detected status";
    } tbrs_ram_ecc_ded[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates OTPM record ECC double error detected status";
    } otpm_ecc_ded[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates SEQ2 RAM ECC double error detected status";
    } seq2_ram_ecc_ded[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates SEQ1 RAM ECC double error detected status";
    } seq1_ram_ecc_ded[15:15] = 1'h0;
  };

  reg otpm_factory_crc_expected_l {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_factory_crc_expected_l[15:0] = 16'h0;
  };

  reg otpm_factory_crc_expected_h {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_factory_crc_expected_h[15:0] = 16'h0;
  };

  reg otpm_factory_crc_calculated_l {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_factory_crc_calculated_l[15:0] = 16'hffff;
  };

  reg otpm_factory_crc_calculated_h {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_factory_crc_calculated_h[15:0] = 16'hffff;
  };

  reg otpm_customer_crc_expected_l {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_customer_crc_expected_l[15:0] = 16'h0;
  };

  reg otpm_customer_crc_expected_h {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_customer_crc_expected_h[15:0] = 16'h0;
  };

  reg otpm_customer_crc_calculated_l {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_customer_crc_calculated_l[15:0] = 16'hffff;
  };

  reg otpm_customer_crc_calculated_h {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } otpm_customer_crc_calculated_h[15:0] = 16'hffff;
  };

  reg model_id_ {
    desc = "Model ID.";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "Model ID.";
    } model_id_[15:0] = 16'he54;
  };

  reg revision_number {
    desc = "Revision number for Sensor.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Revision number for Sensor.";
    } revision_number[15:0] = 16'h0;
  };

  reg lock_control {
    desc = "This register protects the mirror mode select (register READ_MODE) and most of the other control registers.<NEWLINE>When set to value 0xBEEF<COMMA> the horizontal and vertical mirror modes as well as most of the other control registers can be changed<COMMA> otherwise these values are locked.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "This register protects the mirror mode select (register READ_MODE) and most of the other control registers.<NEWLINE>When set to value 0xBEEF<COMMA> the horizontal and vertical mirror modes as well as most of the other control registers can be changed<COMMA> otherwise these values are locked.";
    } lock_control[15:0] = 16'hbeef;
  };

  reg reset_register {
    desc = "Controls the operation of the sensor. For details see the bit field descriptions.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "This bit always reads as 0. Setting this bit causes the sensor to truncate the current frame at the end of the current row and start resetting (integrating) the first row. The delay before the first valid frame is read out is equal to the integration time. <NEWLINE>ASIL implications: truncating the current frame will cause frame-based ASIL checks to fail (including but not limited to the clocks-per-frame safety mechanisms).";
    } restart[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Many parameter limit registers that are specified as read-only are actually implemented as read/write registers. Clearing this bit allows such registers to be written.";
    } lock_reg[3:3] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "0 = Transition to standby is synchronized to the end of a sensor row readout (held-off until LINE_VALID has fallen). <NEWLINE>1 = Transition to standby is synchronized to the end of a frame. <NEWLINE>ASIL implications: transition to standby at the end of a sensor row readout can truncate the current frame. This will cause frame-based ASIL checks to fail (including but not limited to the clocks-per-frame safety mechanisms).";
    } stdby_eof[4:4] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "When this bit is set<COMMA> asserting a restart (bit 1) will cause the sensor state will behave as in normal restart sequence. However<COMMA> after entering standby state<COMMA> it will insert a ram context load. The context load is defined by the context_ram control register<COMMA> before going back to streaming mode.";
    } restart_ctx_load[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: The parallel data interface (DOUT[13:0]<COMMA> LINE_VALID<COMMA> FRAME_VALID<COMMA> and PIXCLK) may enter a high-impedance state (depending upon the enabling and use of the pad OUTPUT_ENABLE_N)<NEWLINE>1: The parallel data interface is driven. <NEWLINE>This bit is <QUOT>do not care<QUOT> unless bit[7]=1.";
    } drive_pins[6:6] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "0: The parallel data interface (DOUT[13:0]<COMMA> LINE_VALID<COMMA> FRAME_VALID<COMMA> and PIXCLK) is disabled and the outputs are placed in a high-impedance state. <NEWLINE>1: The parallel data interface is enabled. The output signals can be switched between a driven and a high-impedance state using output-enable control.";
    } parallel_en[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: the GPIO input functions TRIGGER<COMMA> and STANDBY are disabled.  1: the input functions are enabled.  The GPIO pins must also be configured to map the input function(s) onto a particular GPIO pin(s) and to enable the respective pin(s) input buffer.";
    } gpi_en[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: The sensor will produce bad (corrupted) frames as a result of some register changes. <NEWLINE>1: Bad (corrupted) frames are masked within the sensor by extending the vertical blanking time for the duration of the bad frame.";
    } mask_bad[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "1: A restart is forced any time a bad frame is detected. This can shorten the delay when waiting for a good frame<COMMA> since the delay for masking out a bad frame will be the integration time rather than the full-frame time.";
    } restart_bad[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: PLL will be powered down when the sensor is in standby (low power mode).<NEWLINE>1: PLL will be enabled even when the sensor is in <QUOT>standby.<QUOT>";
    } forced_pll_on[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: Serial pixel data interface Enabled.<NEWLINE>1: Serial pixel data interface Disabled.";
    } smia_ser_dis[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enables a glitch filter for the RESET_BAR pin.  0: Reset LPF Disabled.<NEWLINE>1: Reset LPF Enabled.";
    } enable_reset_lpf[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "";
    } forced_sel_clk2[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: Update of many of the registers is synchronized to frame start. <NEWLINE>1: Inhibit register updates. Register changes will remain pending until this bit is returned to 0. When this bit is returned to 0<COMMA> all pending register updates will be made on the next frame start. This bit cannot be used in conjunction with RAM-based context-switching because setting it also inhibits register updates from the context RAM.";
    } hold[15:15] = 1'h0;
  };

  reg ctx_control_reg {
    desc = "The programmable context engine allows a set of different contexts to be stored in on-chip RAM. A context is defined by a set of register writes. Any arbitrary set of registers can be used<COMMA> but each context must supply a value for each of the registers in the set.  The context RAM uses a record-based format (refer to the Developer Guide for details). When sequencing through multiple contexts (CONTEXT_MULTI=1) the load of the next context is synchronised to the start of readout or the start or integration. Set CONTEXT_LOAD=1 and CONTEXT_MULTI=1 to load the first context immediately.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "When CONTEXT_MULTI=0<COMMA> this field defines the context that will be loaded when CONTEXT_LOAD is set.";
    } context_select[3:0] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Total number of (consecutive) contexts to read out when CONTEXT_MULTI=1.";
    } context_multi_num[6:4] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable Multiple contexts to be read out. When CONTEXT_MULTI_CYCLE_MODE=0<COMMA> load context 0 through CONTEXT_MULTI_NUM then clear CONTEXT_MULTI=0 and stop. When CONTEXT_MULTI_CYCLE_MODE=1<COMMA> do not stop but repeat the context sequence forever. When this bit is cleared<COMMA> any context load in progress will be completed. Each time this bit is set<COMMA> context loading restarts at context 0.";
    } context_multi[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "1: The next context is loaded at the start of frame readout<COMMA> 0: The next context is loaded at the start of frame integration. Ignored when CONTEXT_MULTI=0. For correct operation of frame-by-frame context switching this bit should always be set to 1.";
    } context_multi_sync_mode[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Repeat multiple context readout.";
    } context_multi_cycle_mode[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Disable auto increment of addresses during I2C access. This is a test function.";
    } ctx_control_reg_i2c_auto_inc_disable[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: The context RAM can only be accessed indirectly<COMMA> using CTX_RD_DATA_REG (R0x2500) and CTX_WR_DATA_REG (R0x3066). 1: The context RAM can only be accessed directly<COMMA> using the address range R0x3A00 - R0x3BFF.";
    } ctx_i2c_addr_sel[11:11] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "";
    } ctx_mem_ecc_dis[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Load context immediately: context 0 (if CONTEXT_MULTI=1) or CONTEXT_SELECT (if CONTEXT_MULTI=0). This bit self-clears and so will always read as 0.";
    } context_load[15:15] = 1'h0;
  };

  reg otpm_control {
    desc = "otpm control for ASIC";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Trigger automatic OTPM write sequence. The high voltage must be available on the high voltage pad before this sequence is triggered.  The OTPM address to start from will be taken from otpm_manual_control[15:8]. The length of the data to program is taken from otpm_record[7:0]. The data is taken from the otpm_data* registers.";
    } auto_wr_start[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When set to 1<COMMA> disable automatic OTPM read sequence.";
    } disable_auto_rd[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Trigger automatic OTPM read sequence. <NEWLINE>When OTPM_EXPR_BYPASS_RECORD=0<COMMA> record(s) may be read out by record type (OTPM_RECORD[15:8]) or by OTPM address (OTPM_CONFIG[8:0]).  The payload of the record(s) will appear in the OTPM_DATA_* registers.<NEWLINE>When OTPM_EXPR_BYPASS_RECORD= 1<COMMA> the OTPM start address will be taken from OTPM_MANUAL_CONTROL[15:8]. The length of the data to read is taken from OTPM_RECORD[7:0]. The data read from OTPM will appear in the OTPM_DATA_* registers.";
    } auto_rd_start[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Auto-write has no retry. On detection of a programming error the sequence aborts. After an abort the user may re-issue the auto-write with AUTO_INVALIDATE=1. Alternatively<COMMA> the record can be invalidated.<NEWLINE>Blank checking is performed by issuing AUTO_RD_START with AUTO_INVALIDATE=1.";
    } auto_invalidate[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "To be used when SINGLE_RECORD_ONLY = 1 and OTPM_EXPR_BYPASS_RECORD = 0.  Triggers automatic OTPM read sequence to read the next record; bit 4 and bit 9 should both be set to 1.";
    } auto_rd_next_start[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When set<COMMA> automatic read sequence will end after one record is read out.";
    } single_record_only[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When set<COMMA>  otpm control logic to go into standby.";
    } enable_standby[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When set high<COMMA>  the PWR_DOWN input of the OTPM IP is set high<COMMA>  effectively powering down the IP.";
    } otpm_user_powerdown[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "unused register field.";
    } otpm_clk_divby2_enable[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Trigger calculation of the CRC of all the OTPM content. Scans the OTPM sequentially and calculates a CRC. Self-clearing. The scan completion is indicated in R0x230E and the result is in Rx02310<COMMA> R0x2312<COMMA> R0x2314.";
    } otpm_crc_start[13:13] = 1'h0;
  };

  reg otpm_record {
    desc = "otpm_record for ASIC";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Length of record payload in 16-bit words (between 1 and 255).";
    } auto_length[7:0] = 8'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Type of record.  Currently supported types are:<NEWLINE>0x02 - Default registers loaded before software standby.<NEWLINE>0x1n - Default registers loaded after software standby.<NEWLINE>0x2n - Register sets.<NEWLINE>Other types are only available for readback from the OTPM RAM through the OTPM_DATA_* registers.";
    } auto_type[15:8] = 8'h2;
  };

  reg otpm_manual_control {
    desc = "Single OTPM read and write operations use the address programmed in OTPM_MANUAL_ADDR for ASIC. Write data is taken from and read data is written to the registers OTPM_DATA_MANUAL_L<COMMA> OTPM_DATA_MANUAL_H and OTPM_DATA_MANUAL_EXTRA.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Trigger single OTPM write sequence. The high voltage must be available on the high voltage pad before this sequence is triggered. otpm_manual_control[14:8] is the address of the memory cell that will be programmed to 1. A single read sequence will automatically be triggered for the same address. This can be used to determine whether the program was successful.";
    } single_wr_start[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Trigger single OTPM read sequence from the memory address programmed in otpm_manual_control[14:8].";
    } single_rd_start[4:4] = 1'h0;
  };

  reg otpm_manual_addr {
    desc = "See OTPM_MANUAL_CONTROL. The value in this register is updated as a result of AUTO_WR and AUTO_RD operations.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "address to be used for OTPM single Read/Write transactions";
    } single_addr[11:0] = 12'h0;
  };

  reg otpm_expr {
    desc = "otpm_expr controls for ASIC";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "0: OTPM automatic read and write sequences will impose a record structure on data transferred between OTPM_DATA_* registers and the OTPM.<NEWLINE>1: OTPM automatic read and write sequences will transfer data directly between the OTPM_DATA_* registers and the OTPM; the record structure will be bypassed.";
    } bypass_record[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When set the ECC logic will be bypassed.";
    } ecc_bypass[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Disable automatic RAM load for record types supporting RAM load.";
    } disable_auto_ram_load[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Interprete the current content of the OTPM_DATA_* as a register upload record and upload it to registers.";
    } trigger_auto_ram_load[11:11] = 1'h0;
  };

  reg sys_reg_unlock {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "";
    } sys_reg_unlock[15:0] = 16'h0;
  };

  reg ctx_wr_data_reg {
    desc = "Write to the next address in context RAM and increment address. The address is reset by any write to CTX_CONTROL_REG (R0x3034). This register is write-only (always reads as 0).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Write to the next address in context RAM and increment address. The address is reset by any write to CTX_CONTROL_REG (R0x3034). This register is write-only (always reads as 0).";
    } ctx_wr_data_reg[15:0] = 16'h0;
  };

  reg reset_lpf_register {
    desc = "POR Reset might have a glitch due to ESD. This register sets the glitch suppression delay:<NEWLINE>RESET_LPF = ceil (max_glitch_width / period_max_CLKIN_freq) + 1<NEWLINE>Example: If the max_glitch_width is 500ns with ext clk as 48Mhz<NEWLINE> (500 ns / (1000/ 48Mhz)) + 1 = 25 is the value of reset_lpf register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "POR Reset might have a glitch due to ESD. This register sets the glitch suppression delay:<NEWLINE>RESET_LPF = ceil (max_glitch_width / period_max_CLKIN_freq) + 1<NEWLINE>Example: If the max_glitch_width is 500ns with ext clk as 48Mhz<NEWLINE> (500 ns / (1000/ 48Mhz)) + 1 = 25 is the value of reset_lpf register";
    } reset_lpf_register[5:0] = 6'h20;
  };

  reg digital_test {
    desc = "contains bitfields for different digital functions";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "unused";
    } pll_single_clock_mode[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When bit is set<COMMA> the delay buffer write and read overlap is determined by line_length_pck being less than delay_buffer_llpck_rd_wr_overlap register value to increase the number of line buffers for max T2 exposure.";
    } auto_db_buffer_group[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When the bit is set<COMMA> the delay buffer grouping limitation which affects the max T2 exposure is removed.  The assumption with setting this bit is that the line_length_pck is set large enough such that the delay buffer writes do not overlap the delay buffer reads.";
    } no_db_overlap_rd_wr[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "If this bit is 1:<NEWLINE>HiSPi CRC is calculated from HiSPi IP and is sent through embedded lines (the first two lines) in the next frame.  <NEWLINE>Once test_checksum_valid is high<COMMA> values of CRC are sampled and stored in a register.<NEWLINE>Logic toggles the test_start_checksum once test_checksum_valid is high so that CRC is calculated for subsequent frames.<NEWLINE>Stored CRC value is sent out through embedded data lines in the next frame.<NEWLINE><NEWLINE>If embedded_hispi_crc is 0<COMMA> normal operation of hispi_crc calculation is enabled";
    } embedded_hispi_crc[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Disable max shutter jump limit to allow large increases of integration times.  If integration time is larger than frame length lines<COMMA> the frame length lines will be updated automatically.";
    } no_sh_jump_limit[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When the bit is set<COMMA> the max shutter jump limitation is removed and frame_length_lines is automatically increased for 1 frame if the shutter jump is larger than the max shutter jump of the delay buffer.  After a frame<COMMA> the frame_length_lines is returned to the programmed value.";
    } update_fll_sh_jump[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When set the parallel output PIXCLK will continue to toggle irrespective of standby mode.";
    } pixclk_on[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Context Select.<NEWLINE>0: Use Context A<NEWLINE>1: Use Context B";
    } context_b[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: PLL is enabled<NEWLINE>1: PLL is bypassed.  EXTCLK will be used.<NEWLINE><NEWLINE>Note that the serial interface does not function when PLL is bypassed.";
    } pll_complete_bypass[14:14] = 1'h0;
  };

  reg tempsens1_ctrl_reg {
    desc = "bottom temperature sensor control register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "enable the tempsensor";
    } temp1_power_on[0:0] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "enable the tempsensor in stream mode";
    } temp1_start_conv_strm[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "enable the tempsensor in standby mode";
    } temp1_start_conv_stby[2:2] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Clears all measurments of tempsensor  to 0";
    } temp1_clear_value[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "enable the generation of yellow flag using the temp_value output";
    } temp1_yellow_flag_en[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "enable the generation of red flag using the temp_value output";
    } temp1_red_flag_en[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Used to generate different noise co efficient in the sensor based on this threshold. The threshold of approximately 80C is used for this purpose";
    } temp1_retrigger_threshold[15:6] = 10'h3ae;
  };

  reg trigger_delay {
    desc = "trigger delay register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "trigger delay register";
    } trigger_delay[15:0] = 16'h20;
  };

  reg otpm_data_manual_l {
    desc = "Refer to the OTPM documentation";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Refer to the OTPM documentation";
    } otpm_data_manual_l[15:0] = 16'h0;
  };

  reg otpm_data_manual_h {
    desc = "Refer to the OTPM documentation";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Refer to the OTPM documentation";
    } otpm_data_manual_h[15:0] = 16'h0;
  };

  reg otpm_data_manual_extra {
    desc = "Refer to the OTPM documentation";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Refer to the OTPM documentation";
    } otpm_data_manual_extra[7:0] = 8'h0;
  };

  reg i2c_wrt_checksum {
    desc = "On every I2C write operation<COMMA> the I2C address and write data are applied to a CRC generator. This register returns the current CRC. The CRC generator is initialised to 0xFFFF at reset. A write (any data) re-initialises the CRC generator to 0xFFFF. I2C writes are treated as a series of aligned 16-bit writes for the purpose of CRC accumulation.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "On every I2C write operation<COMMA> the I2C address and write data are applied to a CRC generator. This register returns the current CRC. The CRC generator is initialised to 0xFFFF at reset. A write (any data) re-initialises the CRC generator to 0xFFFF. I2C writes are treated as a series of aligned 16-bit writes for the purpose of CRC accumulation.";
    } i2c_wrt_checksum[15:0] = 16'hffff;
  };

  reg m3rom_wrt_checksum {
    desc = "Holds the expected 16 bit M3ROM checksum value";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Holds the expected 16 bit M3ROM checksum value";
    } m3rom_wrt_checksum[15:0] = 16'he174;
  };

  reg mipi_config_2 {
    desc = "Mipi Config2.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Some kind of legacy field related to MIPI frame-valid signal to master state machine.";
    } mipi_valids_en[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable injection of ECC 1-bit or 2-bit errors into the header of a MIPI data/long packet. This includes modification of the entire header.";
    } mipi_ecc_inj_en[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable injection of CRC errors into the payload of a MIPI data/long packet. This includes modification of packet data and CRC bytes.";
    } mipi_crc_inj_en[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0 = 1-bit ECC errror injected into header<NEWLINE>1 = 2-bit ECC error injected into header";
    } mipi_ecc_inj_bit_num[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "latency in clocks plus 1 between PIXEL_REQ and PIXEL_VALID going high for MIPI D-PHY preamble sequence. Should always be set to 4 for POLARIS.";
    } pixreq_pixval_lat[10:8] = 3'h4;
  };

  reg customer_rev {
    desc = "customer revision register for Sensor";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "customer revision register for Sensor";
    } customer_rev[15:0] = 16'h0;
  };

  reg m3rom_calc_checksum {
    desc = "Holds the calculated 16 bit M3ROM checksum value";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Holds the calculated 16 bit M3ROM checksum value";
    } m3rom_calc_checksum[15:0] = 16'h0;
  };

  reg crc_control_reg {
    desc = "Control for the streaming CRC generators and the embedded data CRC generator.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "1: Enables per-line row CRC";
    } line_crc_en[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: Only OTPM data used in CRC calculation. 1: Include OTPM address with OTPM data in CRC calculation";
    } otpm_crc_inc_addr[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "region select is one-hot encoded and only one bit can be set at a time. [0] - Dark_rows; [1] - Active_rows; [2] - ATR rows; [3] - Embed stats; [4] - Embed data. Note that if enable dtr crc is set (0x3f64[14])  this register should be set to 0";
    } fr_crc_region[6:2] = 5'h2;
    field {
      hw = r;
      sw = rw;
      desc = "1: Reverse bit-order of the values applied to the PDI startup scan CRC generators.";
    } crc_inv_pdi[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Selects exposure to calculate frame CRC in line interleave mode. 0 -> T1; 1 -> T2; 2 -> T3 3 -> T4";
    } fr_crc_exp[10:8] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "1: Reverse bit-order of the values applied to the embedded CRC generators.";
    } crc_inv_emb[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "1: Reverse bit-order of the values applied to the DTR CRC generator.";
    } crc_inv_dtr[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "1: Reverse bit-order of the values applied to the frame and line CRC generators.";
    } crc_inv_frame_line[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enables frame CRC computation without the comparison to allow external checking without causing ASIL_STATUS bit assertion";
    } fr_crc_no_comp[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "0: all embedded registers are included in the embedded data CRC and the startup register scan CRC<COMMA> 1: The EMBED_CRC_MAP registers form a bit-map which identifies embedded registers that are EXCLUDED from the embedded data CRC and the startup register scan CRC.";
    } en_crc_addr_map[15:15] = 1'h0;
  };

  reg i2c_rd_checksum {
    desc = "Checksum of I2C read operations. Writing will initialize to 0xFFFF";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Checksum of I2C read operations. Writing will initialize to 0xFFFF";
    } i2c_rd_checksum[15:0] = 16'hffff;
  };

  reg ext_trigger_delay {
    desc = "MSB bits of the trigger delay. Appended to the trigger_delay from the register 0x30DC.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "MSB bits of the trigger delay. Appended to the trigger_delay from the register 0x30DC.";
    } ext_trigger_delay[15:8] = 8'h0;
  };

  reg gpio_control1 {
    desc = "pad controls for SENSOR pads which directly control pins of the pad cell.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "GPIO OE; Output enable. <NEWLINE> [0] : GPIO 0 OE; Output enable <NEWLINE> [1] : GPIO 1 OE; Output enable  <NEWLINE> [2]: GPIO 2 OE; Output enable  <NEWLINE> [3]: Unused";
    } gpio_oe[3:0] = 4'h7;
    field {
      hw = r;
      sw = rw;
      desc = "Power down GPIO input function. <NEWLINE> [0] : GPIO 0 input power down <NEWLINE> [1] : GPIO 1 input power down <NEWLINE> [2]: GPIO 2 input power down <NEWLINE> [3]: Unused";
    } gpio_ip_pd[7:4] = 4'hf;
    field {
      hw = r;
      sw = rw;
      desc = "Not used in AR0823";
    } gpio_fsafe[11:8] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Not used in AR0823";
    } gpio_hold[15:12] = 4'h0;
  };

  reg gpio_control2 {
    desc = "gpio input mapping controls and shared padcell controls";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "gpio0 input select<NEWLINE>0 - no input function<NEWLINE>1 - OUTPUT_ENABLE_N<NEWLINE>2 - TRIGGER<NEWLINE>3 - STANDBY";
    } gpio0_isel[1:0] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "gpio1 input select<NEWLINE>0 - no input function<NEWLINE>1 - OUTPUT_ENABLE_N<NEWLINE>2 - TRIGGER<NEWLINE>3 - STANDBY";
    } gpio1_isel[3:2] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "gpio2 input select<NEWLINE>0 - no input function<NEWLINE>1 - OUTPUT_ENABLE_N<NEWLINE>2 - TRIGGER<NEWLINE>3 - STANDBY";
    } gpio2_isel[5:4] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "gpio3 input select<NEWLINE>0 - no input function<NEWLINE>1 - OUTPUT_ENABLE_N<NEWLINE>2 - TRIGGER<NEWLINE>3 - STANDBY";
    } gpio3_isel[7:6] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "GPIO and TEMP_FLAG slew control for SENSOR";
    } gpio_slew[10:8] = 3'h7;
    field {
      hw = r;
      sw = rw;
      desc = "GPIO and TEMP_FLAG hidrv enable for SENSOR <NEWLINE>use 0 for 1.8v<NEWLINE>use 1 for 2.8v";
    } gpio_hidrv_en[11:11] = 1'h1;
  };

  reg gpio_select {
    desc = "GPIO output selection<NEWLINE>0 - SYS_STATUS[0]<NEWLINE>1 - SYS_STATUS[1]<NEWLINE>2 - SYS_STATUS[2]<NEWLINE>3 - SHUTTER_STATUS<NEWLINE>4 - FLASH<NEWLINE>5 - SHUTTER<NEWLINE>6 - LINE_VALID or MIPI_LINE_VALID<NEWLINE>7 - FRAME_VALID or MIPI_FRAME_VALID<NEWLINE>8 - PIXCLK_OP or F0_WORD_CLK<NEWLINE>9 - drive zero<NEWLINE>10 - drive one<NEWLINE>11 - new_row<NEWLINE>12 - new_frame<NEWLINE>13 - gpio_ahm[0]<NEWLINE>14 - gpio_ahm[1]<NEWLINE>15 - gpio_ahm[2]<NEWLINE><NEWLINE>The GPIO_STATUS are mapped as follows:<NEWLINE>0 - hard reset<COMMA> EXTCLK is toggling SYS_CHECK<NEWLINE>0 - m3rom upload<NEWLINE>1 - critical OTPM upload<NEWLINE>2 - non-critical otpm upload<NEWLINE>3 - register scan<NEWLINE>4 - startup BIST<NEWLINE>5 - test frame<NEWLINE>6 - standby<NEWLINE>7 - stream";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "gpio0 output function selection - This is input only pad and used as Trigger for AR1212";
    } gpio0_osel[3:0] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "gpio1 output function selection";
    } gpio1_osel[7:4] = 4'h1;
    field {
      hw = r;
      sw = rw;
      desc = "gpio2 output function selection";
    } gpio2_osel[11:8] = 4'h2;
    field {
      hw = r;
      sw = rw;
      desc = "gpio3 output function selection";
    } gpio3_osel[15:12] = 4'h0;
  };

  reg low_power_control {
    desc = "Master counter challenge response mechanism and low-power control";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Set chip to low power mode. Hard reset is required to recover from this state.";
    } low_power_control_enable[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "initiates the power down of sensor and triggers shutdown sequence of PMIC";
    } power_down_en[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "When bit is enabled<COMMA>assertion of SYS_CHECK or detection of fault causes a transition to safe standby state. In safe standby state<COMMA> any frame in progress is terminated and all internal clocks are stopped. When this bit is 0<COMMA> transition to safe standby state is inhibited: SYS_CHECK will assert but the system will continue to stream image data.";
    } no_safe_state[4:4] = 1'h0;
  };

  reg master_fsm_req_code {
    desc = "16bit  challenge word from external master";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "16bit  challenge word from external master";
    } master_fsm_req_code[15:0] = 16'h0;
  };

  reg i2cids0 {
    desc = "i2c addresses for SADDR[3:0]=0 and 1. This register is read-only and can be made read/write by clearing R0x301A[3].";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "i2c addresses for SADDR[3:0]=0 and 1. This register is read-only and can be made read/write by clearing R0x301A[3].";
    } i2cids0[15:0] = 16'h3020;
  };

  reg i2cids1 {
    desc = "i2c addresses for SADDR[3:0]=2 and 3. This register is read-only and can be made read/write by clearing R0x301A[3].";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "i2c addresses for SADDR[3:0]=2 and 3. This register is read-only and can be made read/write by clearing R0x301A[3].";
    } i2cids1[15:0] = 16'h6e6c;
  };

  reg i2cids2 {
    desc = "i2c addresses for SADDR[3:0]=4 and 5. This register is read-only and can be made read/write by clearing R0x301A[3].";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "i2c addresses for SADDR[3:0]=4 and 5. This register is read-only and can be made read/write by clearing R0x301A[3].";
    } i2cids2[15:0] = 16'h5040;
  };

  reg fuse_id1 {
    desc = "Manufacturing ID";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Manufacturing ID";
    } fuse_id1[15:0] = 16'h0;
  };

  reg fuse_id2 {
    desc = "Manufacturing ID";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Manufacturing ID";
    } fuse_id2[15:0] = 16'h0;
  };

  reg fuse_id3 {
    desc = "Manufacturing ID";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Manufacturing ID";
    } fuse_id3[15:0] = 16'h0;
  };

  reg fuse_id4 {
    desc = "Manufacturing ID";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Manufacturing ID";
    } fuse_id4[15:0] = 16'h0;
  };

  reg fuse_id5 {
    desc = "Manufacturing ID";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Manufacturing ID";
    } fuse_id5[15:0] = 16'h0;
  };

  reg fuse_id6 {
    desc = "Manufacturing ID";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Manufacturing ID";
    } fuse_id6[15:0] = 16'h0;
  };

  reg fuse_id7 {
    desc = "Manufacturing ID";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Manufacturing ID";
    } fuse_id7[15:0] = 16'h0;
  };

  reg fuse_id8 {
    desc = "Manufacturing ID";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Manufacturing ID";
    } fuse_id8[15:0] = 16'h0;
  };

  reg otpm_data_0 {
    desc = "OTPM data to be written to the OTPM through auto write should be stored here and on the other OTPM_DATA_* registers. After OTPM auto read the data will be available here. The exception is for record using automatic upload to registers. In this case the OTPM data will not be available in the OTPM RAM unless the automatic upload feature is turned off.  There are a total of 256 of these registers spanning 0x3800 to 0x39FE.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "OTPM data to be written to the OTPM through auto write should be stored here and on the other OTPM_DATA_* registers. After OTPM auto read the data will be available here. The exception is for record using automatic upload to registers. In this case the OTPM data will not be available in the OTPM RAM unless the automatic upload feature is turned off.  There are a total of 256 of these registers spanning 0x3800 to 0x39FE.";
    } otpm_data_0[15:0] = 16'h0;
  };

  reg otpm_data_1 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_1[15:0] = 16'h0;
  };

  reg otpm_data_2 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_2[15:0] = 16'h0;
  };

  reg otpm_data_3 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_3[15:0] = 16'h0;
  };

  reg otpm_data_4 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_4[15:0] = 16'h0;
  };

  reg otpm_data_5 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_5[15:0] = 16'h0;
  };

  reg otpm_data_6 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_6[15:0] = 16'h0;
  };

  reg otpm_data_7 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_7[15:0] = 16'h0;
  };

  reg otpm_data_8 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_8[15:0] = 16'h0;
  };

  reg otpm_data_9 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_9[15:0] = 16'h0;
  };

  reg otpm_data_10 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_10[15:0] = 16'h0;
  };

  reg otpm_data_11 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_11[15:0] = 16'h0;
  };

  reg otpm_data_12 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_12[15:0] = 16'h0;
  };

  reg otpm_data_13 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_13[15:0] = 16'h0;
  };

  reg otpm_data_14 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_14[15:0] = 16'h0;
  };

  reg otpm_data_15 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_15[15:0] = 16'h0;
  };

  reg otpm_data_16 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_16[15:0] = 16'h0;
  };

  reg otpm_data_17 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_17[15:0] = 16'h0;
  };

  reg otpm_data_18 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_18[15:0] = 16'h0;
  };

  reg otpm_data_19 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_19[15:0] = 16'h0;
  };

  reg otpm_data_20 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_20[15:0] = 16'h0;
  };

  reg otpm_data_21 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_21[15:0] = 16'h0;
  };

  reg otpm_data_22 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_22[15:0] = 16'h0;
  };

  reg otpm_data_23 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_23[15:0] = 16'h0;
  };

  reg otpm_data_24 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_24[15:0] = 16'h0;
  };

  reg otpm_data_25 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_25[15:0] = 16'h0;
  };

  reg otpm_data_26 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_26[15:0] = 16'h0;
  };

  reg otpm_data_27 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_27[15:0] = 16'h0;
  };

  reg otpm_data_28 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_28[15:0] = 16'h0;
  };

  reg otpm_data_29 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_29[15:0] = 16'h0;
  };

  reg otpm_data_30 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_30[15:0] = 16'h0;
  };

  reg otpm_data_31 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_31[15:0] = 16'h0;
  };

  reg otpm_data_32 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_32[15:0] = 16'h0;
  };

  reg otpm_data_33 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_33[15:0] = 16'h0;
  };

  reg otpm_data_34 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_34[15:0] = 16'h0;
  };

  reg otpm_data_35 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_35[15:0] = 16'h0;
  };

  reg otpm_data_36 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_36[15:0] = 16'h0;
  };

  reg otpm_data_37 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_37[15:0] = 16'h0;
  };

  reg otpm_data_38 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_38[15:0] = 16'h0;
  };

  reg otpm_data_39 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_39[15:0] = 16'h0;
  };

  reg otpm_data_40 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_40[15:0] = 16'h0;
  };

  reg otpm_data_41 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_41[15:0] = 16'h0;
  };

  reg otpm_data_42 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_42[15:0] = 16'h0;
  };

  reg otpm_data_43 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_43[15:0] = 16'h0;
  };

  reg otpm_data_44 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_44[15:0] = 16'h0;
  };

  reg otpm_data_45 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_45[15:0] = 16'h0;
  };

  reg otpm_data_46 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_46[15:0] = 16'h0;
  };

  reg otpm_data_47 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_47[15:0] = 16'h0;
  };

  reg otpm_data_48 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_48[15:0] = 16'h0;
  };

  reg otpm_data_49 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_49[15:0] = 16'h0;
  };

  reg otpm_data_50 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_50[15:0] = 16'h0;
  };

  reg otpm_data_51 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_51[15:0] = 16'h0;
  };

  reg otpm_data_52 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_52[15:0] = 16'h0;
  };

  reg otpm_data_53 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_53[15:0] = 16'h0;
  };

  reg otpm_data_54 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_54[15:0] = 16'h0;
  };

  reg otpm_data_55 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_55[15:0] = 16'h0;
  };

  reg otpm_data_56 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_56[15:0] = 16'h0;
  };

  reg otpm_data_57 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_57[15:0] = 16'h0;
  };

  reg otpm_data_58 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_58[15:0] = 16'h0;
  };

  reg otpm_data_59 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_59[15:0] = 16'h0;
  };

  reg otpm_data_60 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_60[15:0] = 16'h0;
  };

  reg otpm_data_61 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_61[15:0] = 16'h0;
  };

  reg otpm_data_62 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_62[15:0] = 16'h0;
  };

  reg otpm_data_63 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_63[15:0] = 16'h0;
  };

  reg otpm_data_64 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_64[15:0] = 16'h0;
  };

  reg otpm_data_65 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_65[15:0] = 16'h0;
  };

  reg otpm_data_66 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_66[15:0] = 16'h0;
  };

  reg otpm_data_67 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_67[15:0] = 16'h0;
  };

  reg otpm_data_68 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_68[15:0] = 16'h0;
  };

  reg otpm_data_69 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_69[15:0] = 16'h0;
  };

  reg otpm_data_70 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_70[15:0] = 16'h0;
  };

  reg otpm_data_71 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_71[15:0] = 16'h0;
  };

  reg otpm_data_72 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_72[15:0] = 16'h0;
  };

  reg otpm_data_73 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_73[15:0] = 16'h0;
  };

  reg otpm_data_74 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_74[15:0] = 16'h0;
  };

  reg otpm_data_75 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_75[15:0] = 16'h0;
  };

  reg otpm_data_76 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_76[15:0] = 16'h0;
  };

  reg otpm_data_77 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_77[15:0] = 16'h0;
  };

  reg otpm_data_78 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_78[15:0] = 16'h0;
  };

  reg otpm_data_79 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_79[15:0] = 16'h0;
  };

  reg otpm_data_80 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_80[15:0] = 16'h0;
  };

  reg otpm_data_81 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_81[15:0] = 16'h0;
  };

  reg otpm_data_82 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_82[15:0] = 16'h0;
  };

  reg otpm_data_83 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_83[15:0] = 16'h0;
  };

  reg otpm_data_84 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_84[15:0] = 16'h0;
  };

  reg otpm_data_85 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_85[15:0] = 16'h0;
  };

  reg otpm_data_86 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_86[15:0] = 16'h0;
  };

  reg otpm_data_87 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_87[15:0] = 16'h0;
  };

  reg otpm_data_88 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_88[15:0] = 16'h0;
  };

  reg otpm_data_89 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_89[15:0] = 16'h0;
  };

  reg otpm_data_90 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_90[15:0] = 16'h0;
  };

  reg otpm_data_91 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_91[15:0] = 16'h0;
  };

  reg otpm_data_92 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_92[15:0] = 16'h0;
  };

  reg otpm_data_93 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_93[15:0] = 16'h0;
  };

  reg otpm_data_94 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_94[15:0] = 16'h0;
  };

  reg otpm_data_95 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_95[15:0] = 16'h0;
  };

  reg otpm_data_96 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_96[15:0] = 16'h0;
  };

  reg otpm_data_97 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_97[15:0] = 16'h0;
  };

  reg otpm_data_98 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_98[15:0] = 16'h0;
  };

  reg otpm_data_99 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_99[15:0] = 16'h0;
  };

  reg otpm_data_100 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_100[15:0] = 16'h0;
  };

  reg otpm_data_101 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_101[15:0] = 16'h0;
  };

  reg otpm_data_102 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_102[15:0] = 16'h0;
  };

  reg otpm_data_103 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_103[15:0] = 16'h0;
  };

  reg otpm_data_104 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_104[15:0] = 16'h0;
  };

  reg otpm_data_105 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_105[15:0] = 16'h0;
  };

  reg otpm_data_106 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_106[15:0] = 16'h0;
  };

  reg otpm_data_107 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_107[15:0] = 16'h0;
  };

  reg otpm_data_108 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_108[15:0] = 16'h0;
  };

  reg otpm_data_109 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_109[15:0] = 16'h0;
  };

  reg otpm_data_110 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_110[15:0] = 16'h0;
  };

  reg otpm_data_111 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_111[15:0] = 16'h0;
  };

  reg otpm_data_112 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_112[15:0] = 16'h0;
  };

  reg otpm_data_113 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_113[15:0] = 16'h0;
  };

  reg otpm_data_114 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_114[15:0] = 16'h0;
  };

  reg otpm_data_115 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_115[15:0] = 16'h0;
  };

  reg otpm_data_116 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_116[15:0] = 16'h0;
  };

  reg otpm_data_117 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_117[15:0] = 16'h0;
  };

  reg otpm_data_118 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_118[15:0] = 16'h0;
  };

  reg otpm_data_119 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_119[15:0] = 16'h0;
  };

  reg otpm_data_120 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_120[15:0] = 16'h0;
  };

  reg otpm_data_121 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_121[15:0] = 16'h0;
  };

  reg otpm_data_122 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_122[15:0] = 16'h0;
  };

  reg otpm_data_123 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_123[15:0] = 16'h0;
  };

  reg otpm_data_124 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_124[15:0] = 16'h0;
  };

  reg otpm_data_125 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_125[15:0] = 16'h0;
  };

  reg otpm_data_126 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_126[15:0] = 16'h0;
  };

  reg otpm_data_127 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_127[15:0] = 16'h0;
  };

  reg otpm_data_128 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_128[15:0] = 16'h0;
  };

  reg otpm_data_129 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_129[15:0] = 16'h0;
  };

  reg otpm_data_130 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_130[15:0] = 16'h0;
  };

  reg otpm_data_131 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_131[15:0] = 16'h0;
  };

  reg otpm_data_132 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_132[15:0] = 16'h0;
  };

  reg otpm_data_133 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_133[15:0] = 16'h0;
  };

  reg otpm_data_134 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_134[15:0] = 16'h0;
  };

  reg otpm_data_135 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_135[15:0] = 16'h0;
  };

  reg otpm_data_136 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_136[15:0] = 16'h0;
  };

  reg otpm_data_137 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_137[15:0] = 16'h0;
  };

  reg otpm_data_138 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_138[15:0] = 16'h0;
  };

  reg otpm_data_139 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_139[15:0] = 16'h0;
  };

  reg otpm_data_140 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_140[15:0] = 16'h0;
  };

  reg otpm_data_141 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_141[15:0] = 16'h0;
  };

  reg otpm_data_142 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_142[15:0] = 16'h0;
  };

  reg otpm_data_143 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_143[15:0] = 16'h0;
  };

  reg otpm_data_144 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_144[15:0] = 16'h0;
  };

  reg otpm_data_145 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_145[15:0] = 16'h0;
  };

  reg otpm_data_146 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_146[15:0] = 16'h0;
  };

  reg otpm_data_147 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_147[15:0] = 16'h0;
  };

  reg otpm_data_148 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_148[15:0] = 16'h0;
  };

  reg otpm_data_149 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_149[15:0] = 16'h0;
  };

  reg otpm_data_150 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_150[15:0] = 16'h0;
  };

  reg otpm_data_151 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_151[15:0] = 16'h0;
  };

  reg otpm_data_152 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_152[15:0] = 16'h0;
  };

  reg otpm_data_153 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_153[15:0] = 16'h0;
  };

  reg otpm_data_154 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_154[15:0] = 16'h0;
  };

  reg otpm_data_155 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_155[15:0] = 16'h0;
  };

  reg otpm_data_156 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_156[15:0] = 16'h0;
  };

  reg otpm_data_157 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_157[15:0] = 16'h0;
  };

  reg otpm_data_158 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_158[15:0] = 16'h0;
  };

  reg otpm_data_159 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_159[15:0] = 16'h0;
  };

  reg otpm_data_160 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_160[15:0] = 16'h0;
  };

  reg otpm_data_161 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_161[15:0] = 16'h0;
  };

  reg otpm_data_162 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_162[15:0] = 16'h0;
  };

  reg otpm_data_163 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_163[15:0] = 16'h0;
  };

  reg otpm_data_164 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_164[15:0] = 16'h0;
  };

  reg otpm_data_165 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_165[15:0] = 16'h0;
  };

  reg otpm_data_166 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_166[15:0] = 16'h0;
  };

  reg otpm_data_167 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_167[15:0] = 16'h0;
  };

  reg otpm_data_168 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_168[15:0] = 16'h0;
  };

  reg otpm_data_169 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_169[15:0] = 16'h0;
  };

  reg otpm_data_170 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_170[15:0] = 16'h0;
  };

  reg otpm_data_171 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_171[15:0] = 16'h0;
  };

  reg otpm_data_172 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_172[15:0] = 16'h0;
  };

  reg otpm_data_173 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_173[15:0] = 16'h0;
  };

  reg otpm_data_174 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_174[15:0] = 16'h0;
  };

  reg otpm_data_175 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_175[15:0] = 16'h0;
  };

  reg otpm_data_176 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_176[15:0] = 16'h0;
  };

  reg otpm_data_177 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_177[15:0] = 16'h0;
  };

  reg otpm_data_178 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_178[15:0] = 16'h0;
  };

  reg otpm_data_179 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_179[15:0] = 16'h0;
  };

  reg otpm_data_180 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_180[15:0] = 16'h0;
  };

  reg otpm_data_181 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_181[15:0] = 16'h0;
  };

  reg otpm_data_182 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_182[15:0] = 16'h0;
  };

  reg otpm_data_183 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_183[15:0] = 16'h0;
  };

  reg otpm_data_184 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_184[15:0] = 16'h0;
  };

  reg otpm_data_185 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_185[15:0] = 16'h0;
  };

  reg otpm_data_186 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_186[15:0] = 16'h0;
  };

  reg otpm_data_187 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_187[15:0] = 16'h0;
  };

  reg otpm_data_188 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_188[15:0] = 16'h0;
  };

  reg otpm_data_189 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_189[15:0] = 16'h0;
  };

  reg otpm_data_190 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_190[15:0] = 16'h0;
  };

  reg otpm_data_191 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_191[15:0] = 16'h0;
  };

  reg otpm_data_192 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_192[15:0] = 16'h0;
  };

  reg otpm_data_193 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_193[15:0] = 16'h0;
  };

  reg otpm_data_194 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_194[15:0] = 16'h0;
  };

  reg otpm_data_195 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_195[15:0] = 16'h0;
  };

  reg otpm_data_196 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_196[15:0] = 16'h0;
  };

  reg otpm_data_197 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_197[15:0] = 16'h0;
  };

  reg otpm_data_198 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_198[15:0] = 16'h0;
  };

  reg otpm_data_199 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_199[15:0] = 16'h0;
  };

  reg otpm_data_200 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_200[15:0] = 16'h0;
  };

  reg otpm_data_201 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_201[15:0] = 16'h0;
  };

  reg otpm_data_202 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_202[15:0] = 16'h0;
  };

  reg otpm_data_203 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_203[15:0] = 16'h0;
  };

  reg otpm_data_204 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_204[15:0] = 16'h0;
  };

  reg otpm_data_205 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_205[15:0] = 16'h0;
  };

  reg otpm_data_206 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_206[15:0] = 16'h0;
  };

  reg otpm_data_207 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_207[15:0] = 16'h0;
  };

  reg otpm_data_208 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_208[15:0] = 16'h0;
  };

  reg otpm_data_209 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_209[15:0] = 16'h0;
  };

  reg otpm_data_210 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_210[15:0] = 16'h0;
  };

  reg otpm_data_211 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_211[15:0] = 16'h0;
  };

  reg otpm_data_212 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_212[15:0] = 16'h0;
  };

  reg otpm_data_213 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_213[15:0] = 16'h0;
  };

  reg otpm_data_214 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_214[15:0] = 16'h0;
  };

  reg otpm_data_215 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_215[15:0] = 16'h0;
  };

  reg otpm_data_216 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_216[15:0] = 16'h0;
  };

  reg otpm_data_217 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_217[15:0] = 16'h0;
  };

  reg otpm_data_218 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_218[15:0] = 16'h0;
  };

  reg otpm_data_219 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_219[15:0] = 16'h0;
  };

  reg otpm_data_220 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_220[15:0] = 16'h0;
  };

  reg otpm_data_221 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_221[15:0] = 16'h0;
  };

  reg otpm_data_222 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_222[15:0] = 16'h0;
  };

  reg otpm_data_223 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_223[15:0] = 16'h0;
  };

  reg otpm_data_224 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_224[15:0] = 16'h0;
  };

  reg otpm_data_225 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_225[15:0] = 16'h0;
  };

  reg otpm_data_226 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_226[15:0] = 16'h0;
  };

  reg otpm_data_227 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_227[15:0] = 16'h0;
  };

  reg otpm_data_228 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_228[15:0] = 16'h0;
  };

  reg otpm_data_229 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_229[15:0] = 16'h0;
  };

  reg otpm_data_230 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_230[15:0] = 16'h0;
  };

  reg otpm_data_231 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_231[15:0] = 16'h0;
  };

  reg otpm_data_232 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_232[15:0] = 16'h0;
  };

  reg otpm_data_233 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_233[15:0] = 16'h0;
  };

  reg otpm_data_234 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_234[15:0] = 16'h0;
  };

  reg otpm_data_235 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_235[15:0] = 16'h0;
  };

  reg otpm_data_236 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_236[15:0] = 16'h0;
  };

  reg otpm_data_237 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_237[15:0] = 16'h0;
  };

  reg otpm_data_238 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_238[15:0] = 16'h0;
  };

  reg otpm_data_239 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_239[15:0] = 16'h0;
  };

  reg otpm_data_240 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_240[15:0] = 16'h0;
  };

  reg otpm_data_241 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_241[15:0] = 16'h0;
  };

  reg otpm_data_242 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_242[15:0] = 16'h0;
  };

  reg otpm_data_243 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_243[15:0] = 16'h0;
  };

  reg otpm_data_244 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_244[15:0] = 16'h0;
  };

  reg otpm_data_245 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_245[15:0] = 16'h0;
  };

  reg otpm_data_246 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_246[15:0] = 16'h0;
  };

  reg otpm_data_247 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_247[15:0] = 16'h0;
  };

  reg otpm_data_248 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_248[15:0] = 16'h0;
  };

  reg otpm_data_249 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_249[15:0] = 16'h0;
  };

  reg otpm_data_250 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_250[15:0] = 16'h0;
  };

  reg otpm_data_251 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_251[15:0] = 16'h0;
  };

  reg otpm_data_252 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_252[15:0] = 16'h0;
  };

  reg otpm_data_253 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_253[15:0] = 16'h0;
  };

  reg otpm_data_254 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_254[15:0] = 16'h0;
  };

  reg otpm_data_255 {
    desc = "See description of OTPM_DATA_0 (R0x3800).";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "See description of OTPM_DATA_0 (R0x3800).";
    } otpm_data_255[15:0] = 16'h0;
  };

  reg vddhrsidac_adj {
    desc = "VDDHRS - Row select Hi pmu monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VDDHRS-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddhrsidac_adj_0[6:0] = 7'h55;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VDDHRS-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddhrsidac_adj_1[14:8] = 7'h63;
  };

  reg vddhdcgidac_adj {
    desc = "VDDHDCG - DCG Hi pmu monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VDDHDCG-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddhdcgidac_adj_0[6:0] = 7'h4c;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VDDHDCG-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddhdcgidac_adj_1[14:8] = 7'h5a;
  };

  reg vddhgcidac_adj {
    desc = "VDDHGC - GC Hi pmu monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VDDHGC-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddhgcidac_adj_0[6:0] = 7'h46;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VDDHGC-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddhgcidac_adj_1[14:8] = 7'h54;
  };

  reg vddhtxidac_adj {
    desc = "VDDHTX - TX Hi pmu monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VDDHTX-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddhtxidac_adj_0[6:0] = 7'h3c;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VDDHTX-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddhtxidac_adj_1[14:8] = 7'h4a;
  };

  reg vddhrstidac_adj {
    desc = "VDDHRST - RST Hi pmu monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VDDHRST-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddhrstidac_adj_0[6:0] = 7'h52;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VDDHRST-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddhrstidac_adj_1[14:8] = 7'h60;
  };

  reg vddhilogicidac_adj {
    desc = "VDDHILOGIC - Rowdriver final pmos switch control voltage monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VDDHILOGIC-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddhilogicidac_adj_0[6:0] = 7'h62;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VDDHILOGIC-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddhilogicidac_adj_1[14:8] = 7'h70;
  };

  reg vaaclgrdidac_adj {
    desc = "VAACLGRD - E1 Read/T2 Read row CLGREF voltage level monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VAACLGRD-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vaaclgrdidac_adj_0[6:0] = 7'h2f;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VAACLGRD-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vaaclgrdidac_adj_1[14:8] = 7'h3d;
  };

  reg vaaclgshidac_adj {
    desc = "VAACLGSH - Shutter/E3 Read/T2 Read row CLGREF voltage level monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VAACLGSH-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vaaclgshidac_adj_0[6:0] = 7'h24;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VAACLGSH-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vaaclgshidac_adj_1[14:8] = 7'h31;
  };

  reg vaa3v3_adj {
    desc = "VAA3V3 - CLGREF and RS row driver latch logic voltage monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VAA3V3-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vaa3v3_adj_0[6:0] = 7'h41;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VAA3V3-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vaa3v3_adj_1[14:8] = 7'h4e;
  };

  reg vsslogcidac_adj {
    desc = "VSSLOGC - GC global lo level pmu monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSLOGC)/80k)/246n); for lt_uvlimit";
    } vsslogcidac_adj_0[6:0] = 7'h4a;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSLOGC)/80k)/246n); for gt_ovlimit";
    } vsslogcidac_adj_1[14:8] = 7'h3a;
  };

  reg vsslodcgidac_adj {
    desc = "VSSLODCG - DCG global lo level pmu monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSLODCG)/80k)/246n); for lt_uvlimit";
    } vsslodcgidac_adj_0[6:0] = 7'h7a;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSLODCG)/80k)/246n); for gt_ovlimit";
    } vsslodcgidac_adj_1[14:8] = 7'h6b;
  };

  reg vsslotxidac_adj {
    desc = "VSSLOTX - TX global lo level pmu monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSLOTX)/80k)/246n); for lt_uvlimit";
    } vsslotxidac_adj_0[6:0] = 7'h75;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSLOTX)/80k)/246n); for gt_ovlimit";
    } vsslotxidac_adj_1[14:8] = 7'h66;
  };

  reg vsslorstidac_adj {
    desc = "VSSLORST - RST global lo level pmu monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSLORST)/80k)/246n); for lt_uvlimit";
    } vsslorstidac_adj_0[6:0] = 7'h48;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSLORST)/80k)/246n); for gt_ovlimit";
    } vsslorstidac_adj_1[14:8] = 7'h39;
  };

  reg vssloselgcidac_adj {
    desc = "VSSLOSELGC - GC selected row level pmu monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSLOSELGC)/80k)/246n); for lt_uvlimit";
    } vssloselgcidac_adj_0[6:0] = 7'h48;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSLOSELGC)/80k)/246n); for gt_ovlimit";
    } vssloselgcidac_adj_1[14:8] = 7'h39;
  };

  reg vssloseldcgidac_adj {
    desc = "VSSLOSELDCG - DCG selected row level pmu monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSLOSELDCG)/80k)/246n); for lt_uvlimit";
    } vssloseldcgidac_adj_0[6:0] = 7'h28;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSLOSELDCG)/80k)/246n); for gt_ovlimit";
    } vssloseldcgidac_adj_1[14:8] = 7'h18;
  };

  reg vssloseltxidac_adj {
    desc = "VSSLOSELTX - TX selected row level pmu monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSLOSELTX)/80k)/246n); for lt_uvlimit";
    } vssloseltxidac_adj_0[6:0] = 7'h63;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSLOSELTX)/80k)/246n); for gt_ovlimit";
    } vssloseltxidac_adj_1[14:8] = 7'h54;
  };

  reg vssloselrstidac_adj {
    desc = "VSSLOSELRST - RST selected row level pmu monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSLOSELRST)/80k)/246n); for lt_uvlimit";
    } vssloselrstidac_adj_0[6:0] = 7'h21;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSLOSELRST)/80k)/246n); for gt_ovlimit";
    } vssloselrstidac_adj_1[14:8] = 7'h12;
  };

  reg vsshilogicidac_adj {
    desc = "VSSHILOGIC - RowDriver Pmos cascode shielding voltage level monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSHILOGIC)/80k)/246n); for lt_uvlimit";
    } vsshilogicidac_adj_0[6:0] = 7'h30;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSHILOGIC)/80k)/246n); for gt_ovlimit";
    } vsshilogicidac_adj_1[14:8] = 7'h20;
  };

  reg vssrowlogicidac_adj {
    desc = "VSSROWLOGIC - Rowdriver logic and buffers VSS supply level monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSROWLOGIC)/80k)/246n); for lt_uvlimit";
    } vssrowlogicidac_adj_0[6:0] = 7'h7f;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSROWLOGIC)/80k)/246n); for gt_ovlimit";
    } vssrowlogicidac_adj_1[14:8] = 7'h70;
  };

  reg vssrwrowdrvidac_adj {
    desc = "VSSRWROWDRV - Final driver's Nmos bulk voltage level monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VSSRWROWDRV)/80k)/246n); for lt_uvlimit";
    } vssrwrowdrvidac_adj_0[6:0] = 7'h7f;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VSSRWROWDRV)/80k)/246n); for gt_ovlimit";
    } vssrwrowdrvidac_adj_1[14:8] = 7'h70;
  };

  reg vddpartxidac_adj {
    desc = "VDDPART1X - T1 integration time TX partial level voltage monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VDDPART1X)/80k)/246n); for lt_uvlimit";
    } vddpartxidac_adj_0[6:0] = 7'h4a;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VDDPART1X)/80k)/246n); for gt_ovlimit";
    } vddpartxidac_adj_1[14:8] = 7'h3a;
  };

  reg vddpartxt2idac_adj {
    desc = "VDDPART2X - T2 integration time TX partial level voltage monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VDDPART2X)/80k)/246n); for lt_uvlimit";
    } vddpartxt2idac_adj_0[6:0] = 7'h1b;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VDDPART2X)/80k)/246n); for gt_ovlimit";
    } vddpartxt2idac_adj_1[14:8] = 7'hc;
  };

  reg vddpargcidac_adj {
    desc = "VDDPARGC - T2 integration GC partial level voltage monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VDDPARGC)/80k)/246n); for lt_uvlimit";
    } vddpargcidac_adj_0[6:0] = 7'h1b;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VDDPARGC)/80k)/246n); for gt_ovlimit";
    } vddpargcidac_adj_1[14:8] = 7'hc;
  };

  reg vddmipiidac_adj {
    desc = "VDDMIPI voltage monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_neg = Hex(((1.3+0.15-VDDMIPI)/80k)/246n); for lt_uvlimit";
    } vddmipiidac_adj_0[6:0] = 7'h35;
    field {
      hw = r;
      sw = rw;
      desc = "idac_loldo_pos = Hex(((1.3-0.15-VDDMIPI)/80k)/246n); for gt_ovlimit";
    } vddmipiidac_adj_1[14:8] = 7'h26;
  };

  reg vddihvpump_idac_adj {
    desc = "VAALDO2p4V - Charge pump internal supply voltage monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VAALDO2p4V-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddihvpump_idac_adj_0[6:0] = 7'h14;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VAALDO2p4V-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddihvpump_idac_adj_1[14:8] = 7'h22;
  };

  reg vddrowlogicidac_adj {
    desc = "VDDROWLOGIC - Rowdriver logic and buffers VDD supply level monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VDDROWLOGIC-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddrowlogicidac_adj_0[6:0] = 7'h1a;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VDDROWLOGIC-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddrowlogicidac_adj_1[14:8] = 7'h27;
  };

  reg vddhimid_dcgidac_adj {
    desc = "VDDHDCGMID - DCG MID level voltage monitor threshold adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VDDHIMID_DCG-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vddhimid_dcgidac_adj_0[6:0] = 7'h1b;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VDDHIMID_DCG-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vddhimid_dcgidac_adj_1[14:8] = 7'h29;
  };

  reg vaaclgrefidac_adj {
    desc = "VAACLGINT - Integating row CLGREF voltage level monitor thresholds adjustment";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_neg = Hex(((VAACLGINT-1.7-0.15)/90k)/246n); for lt_uvlimit";
    } vaaclgrefidac_adj_0[6:0] = 7'h33;
    field {
      hw = r;
      sw = rw;
      desc = "idac_hildo_pos = Hex(((VAACLGINT-1.7+0.15)/90k)/246n); for gt_ovlimit";
    } vaaclgrefidac_adj_1[14:8] = 7'h44;
  };

  reg pmucomp_addrchang_delay {
    desc = "pmucomp_addrchang_delay";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Delay between start of row to select address change. This delay is interms of clocks";
    } addrchange_delay[11:0] = 12'h100;
    field {
      hw = r;
      sw = rw;
      desc = "Delay(interms of rows) between select address change to start of row from which the next address change being processed";
    } pmumoncomp_delay[14:12] = 3'h3;
  };

  reg pmu_monitor_control {
    desc = "pmu_monitor_control register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for disable LDO loading";
    } disable_ldo_loading[2:0] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Supply monitor fault inject enable";
    } inj_fault_supply_mon[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Delay(interms of clocks) between pervious select address change to current select address change";
    } supplymoncomp_delay[14:4] = 11'hf;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for stopping the PMU calibration clock whenever the calibration is being done";
    } pmu_calib_clk_stop_en[15:15] = 1'h0;
  };

  reg supplymon_init_delay {
    desc = "Delay (interms of clocks)between positive edge charge pump enable  to Select address change";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Delay (interms of clocks)between positive edge charge pump enable  to Select address change";
    } supplymon_init_delay[11:0] = 12'h64;
  };

  reg pmumon_calib_control {
    desc = "PMU monitor calibration control register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMU monitor calibration suppl select address";
    } pmumon_calib_supply[3:0] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "PMU monitor calibration clock divider";
    } pmu_calib_clk_div[14:4] = 11'ha;
    field {
      hw = r;
      sw = rw;
      desc = "Supply monitor calibration enable";
    } pmumon_calib_en[15:15] = 1'h0;
  };

  reg pmumon_force_ext_addr {
    desc = "PMU monitor force external address control register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Bit[0] = Force external address enable for HV LDO; Bit[1] = Force external address enable for LV LDO; Bit[2] = Force external address enable for Supply LDO";
    } force_ext_addr_ctrl[2:0] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Force external address for HV LDO";
    } force_ext_addr_hvldo[6:3] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Force external address for LV LDO";
    } force_ext_addr_lvldo[10:7] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Force external address for supply LDO";
    } force_ext_addr_supply[13:11] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for clock always on";
    } pmumon_power_on[14:14] = 1'h1;
  };

  reg pmu_loldo_status_1 {
    desc = "Bit[1:0]= Status of select address 8; Bit[3:2]= Status of select address 9; Bit[5:4]= Status of select address 10;..Bit[13:12]= Status of select address 14";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Bit[1:0]= Status of select address 8; Bit[3:2]= Status of select address 9; Bit[5:4]= Status of select address 10;..Bit[13:12]= Status of select address 14";
    } pmu_loldo_status_1[15:15] = 1'h0;
  };

  reg pmu_hvldo_status_1 {
    desc = "Bit[1:0]= Status of select address 8; Bit[3:2]= Status of select address 9; Bit[5:4]= Status of select address 10;..Bit[13:12]= Status of select address 14";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Bit[1:0]= Status of select address 8; Bit[3:2]= Status of select address 9; Bit[5:4]= Status of select address 10;..Bit[13:12]= Status of select address 14";
    } pmu_hvldo_status_1[15:15] = 1'h0;
  };

  reg pmu_supply_2v8_status {
    desc = "Bit[1:0]= Status of supply select address 0; Bit[3:2]= Status of supply select address 1; Bit[5:4]= Status of supply select address 2;..Bit[13:12]= Status of supply select address 6";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Bit[1:0]= Status of supply select address 0; Bit[3:2]= Status of supply select address 1; Bit[5:4]= Status of supply select address 2;..Bit[13:12]= Status of supply select address 6";
    } pmu_supply_2v8_status[15:15] = 1'h0;
  };

  reg pmu_supply_1v8_status {
    desc = "Bit[1:0]= Status of supply select address 0; Bit[3:2]= Status of supply select address 1; Bit[5:4]= Status of supply select address 2;..Bit[11:10]= Status of supply select address 5";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "Bit[1:0]= Status of supply select address 0; Bit[3:2]= Status of supply select address 1; Bit[5:4]= Status of supply select address 2;..Bit[11:10]= Status of supply select address 5";
    } pmu_supply_1v8_status[15:15] = 1'h0;
  };

  reg pmu_supply_1v0_status {
    desc = "Bit[1:0]= Status of supply select address 0; Bit[3:2]= Status of supply select address 1; Bit[5:4]= Status of supply select address 2";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "Bit[1:0]= Status of supply select address 0; Bit[3:2]= Status of supply select address 1; Bit[5:4]= Status of supply select address 2";
    } pmu_supply_1v0_status[15:15] = 1'h0;
  };

  reg tempvsens1_tmg_ctrl_k0 {
    desc = "Temp compare value in kelvin";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Temp compare value in kelvin";
    } tempsens1_red_temp_code_k[12:0] = 13'h200;
    field {
      hw = r;
      sw = rw;
      desc = "Decides the number of conversion.<NEWLINE>";
    } tempsens1_sample_cnt[15:13] = 3'h0;
  };

  reg tempvsens1_tmg_ctrl_k1 {
    desc = "Temp compare offset in kelvin";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "temp_value_k> temp_value_comp_k - temp_value_compare_offse_kt yellow flag will be set<NEWLINE>";
    } tempsens1_yellow_off_red_k[6:0] = 7'h50;
    field {
      hw = r;
      sw = rw;
      desc = "Once yellow flag is set <COMMA> then to clear it the below condition has to be satisfied<COMMA> temp_value_k> temp_value_comp_k - temp_value_offset_k- temp_value_hysteresis_k<NEWLINE>";
    } tempsens1_yellow_hyst_k[12:8] = 5'h1e;
  };

  reg tempvsens1_m1_hi_sm1 {
    desc = "This register holds slope  value m1[31:16] between -40C to 60C derived after calibration; used for Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between -40C to 60C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for diode1";
    } tempsens1_m1_sm1_hi[15:0] = 16'h0;
  };

  reg tempvsens1_m1_lo_sm1 {
    desc = "This register holds slope  value m1[15:0] between -40C to 60C derived after calibration; used for Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between -40C to 60C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for diode1";
    } tempsens1_m1_sm1_lo[15:0] = 16'hb31;
  };

  reg tempvsens1_c1_hi_sm1 {
    desc = "This register holds the intercept value value c1[31:16]) between -40C to 60C derived after calibration; used for Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between -40C to 60C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for diode1";
    } tempsens1_c1_sm1_hi[15:0] = 16'h1f;
  };

  reg tempvsens1_c1_lo_sm1 {
    desc = "This register holds the intercept value value c1[15:0]) between -40C to 60C derived after calibration; used for Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between -40C to 60C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for diode1";
    } tempsens1_c1_sm1_lo[15:0] = 16'he6a0;
  };

  reg tempvsens1_m2_hi_sm1 {
    desc = "This register holds the slope value m2[31:16] between 60C to 125C derived after calibration; used for Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between 60C to 125C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for diode1";
    } tempsens1_m2_sm1_hi[15:0] = 16'h0;
  };

  reg tempvsens1_m2_lo_sm1 {
    desc = "This register holds the slope value m2[15:0] between 60C to 125C derived after calibration; used for Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between 60C to 125C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for diode1";
    } tempsens1_m2_sm1_lo[15:0] = 16'hb31;
  };

  reg tempvsens1_c2_hi_sm1 {
    desc = "This register holds the intercept value value c2[31:16]) between 60C to 125C derived after calibration; used for Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between 60C to 125C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for diode1";
    } tempsens1_c2_sm1_hi[15:0] = 16'h1f;
  };

  reg tempvsens1_c2_lo_sm1 {
    desc = "This register holds the intercept value value c2[15:0]) between 60C to 125C derived after calibration; used for Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between 60C to 125C derived after calibration. This value is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for diode2";
    } tempsens1_c2_sm1_lo[15:0] = 16'he6a0;
  };

  reg tempvsens1_m1_hi {
    desc = "This register holds slope  value m1[31:16] between -40C to 60C derived after calibration; used for normal (IP) mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between -40C to 60C derived after calibration. This value(m1[31:16]) is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for normal (IP) mode";
    } m1_hi[15:0] = 16'h0;
  };

  reg tempvsens1_m1_lo {
    desc = "This register holds slope  value m1[15:0] between -40C to 60C derived after calibration; used for normal (IP) mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between -40C to 60C derived after calibration. This value(m1[15:0]) is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for normal (IP) mode";
    } m1_lo[15:0] = 16'hb31;
  };

  reg tempvsens1_c1_hi {
    desc = "This register holds the intercept value value c1[31:16]) between -40C to 60C derived after calibration; used for normal (IP) mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between -40C to 60C derived after calibration. This value(c1[31:16]) is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for normal (IP) mode";
    } c1_hi[15:0] = 16'h1f;
  };

  reg tempvsens1_c1_lo {
    desc = "This register holds the intercept value value c1[15:0]) between -40C to 60C derived after calibration; used for normal (IP) mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between -40C to 60C derived after calibration. This value(c1[15:0]) is used to generate temp_value_k from temp_value if temp_value<temp_value_55c. This is used for normal (IP) mode";
    } c1_lo[15:0] = 16'he6a0;
  };

  reg tempvsens1_m2_hi {
    desc = "This register holds the slope value m2[31:16] between 60C to 125C derived after calibration; used for normal (IP) mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between 60C to 125C derived after calibration. This value(m1[31:16]) is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for normal (IP) mode";
    } m2_hi[15:0] = 16'h0;
  };

  reg tempvsens1_m2_lo {
    desc = "This register holds the slope value m2[15:0] between 60C to 125C derived after calibration; used for normal (IP) mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "slope between 60C to 125C derived after calibration. This value(m2[15:0]) is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for normal (IP) mode";
    } m2_lo[15:0] = 16'hb31;
  };

  reg tempvsens1_c2_hi {
    desc = "This register holds the intercept value value c2[31:16]) between 60C to 125C derived after calibration; used for normal (IP) mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between 60C to 125C derived after calibration. This value(c2[31:16]) is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for normal (IP) mode";
    } c2_hi[15:0] = 16'h1f;
  };

  reg tempvsens1_c2_lo {
    desc = "This register holds the intercept value value c2[15:0]) between 60C to 125C derived after calibration; used for normal (IP) mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "intercept between 60C to 125C derived after calibration. This value(c2[15:0]) is used to generate temp_value_k from temp_value if temp_value>temp_value_55c. This is used for normal (IP) mode";
    } c2_lo[15:0] = 16'he6a0;
  };

  reg tempvsens1_value_55 {
    desc = "Temperature code at 55 degree Centigrade for normal TS mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in normal (IP) mode";
    } tempsens1_temp_value_55c[15:0] = 16'hca7a;
  };

  reg tempvsens1_flag_comp {
    desc = "temp_value> temp_value_comp - temp_value_offset yellow flag will be set";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "temp_value> temp_value_comp - temp_value_offset yellow flag will be set";
    } tempvsens1_flag_ctrl_tempsens1_yellow_off_red[12:0] = 13'hd48;
  };

  reg tempvsens1_en_ctrl {
    desc = "TempVolt Sensor control";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "power down the bandgaps in tempsensor";
    } tempsens1_vbg_pwr_dn[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "decides the method of calibration used. If high third order polynomial is used for temp_value_k generation else its a linear equation that is used. Not used in AR0341";
    } tempsens1_poly_en[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "should be high during calibration";
    } tempsens1_calib_en[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Not used in the design: Enable for U9_4 format temperature output to calculate celcious format";
    } tempsens1_datak_u9_4_en[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Fault inject enable for injecting fault only on 1st frame";
    } fault_inj_1st_frame[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Fault inject enable for injecting fault from 2nd frame onwards";
    } fault_inj_2nd_to_every_frame[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "enable comparision of temperature In degree Kelvin (To enable flag generation based on temp_value_k)";
    } tempsens1_temp_comp_en_k[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "test control setting";
    } tempsens1_test_ctrl_mode[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "bit control mode<NEWLINE>3'b000 => 9 bits<NEWLINE>3'b001 => 10 bits<NEWLINE>3'b010 => 11 bits<NEWLINE>3'b011 => 12 bits<NEWLINE>3'b100 => 13 bits";
    } tempsens1_adc_bit_ctrl[14:12] = 3'h5;
    field {
      hw = r;
      sw = rw;
      desc = "Force trigger 13 bit temp sensor. This is an auto clear register";
    } tempsens1_force_trigger[15:15] = 1'h0;
  };

  reg tempvsens1_flag_ctrl_ext {
    desc = "Extended tempsensor flag control register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Once yellow flag is set ; then to clear it the below condition has to be satisfied; temp_value> temp_value_comp - temp_value_offset- temp_value_hysteresis";
    } tempvsens1_flag_ctrl_ext_tempsens1_yellow_hyst[6:1] = 6'hf;
    field {
      hw = r;
      sw = rw;
      desc = "Compare against temp value; if temp_comp < temp value then the red flag is set.";
    } tempvsens1_flag_ctrl_ext_tempsens1_red_temp_code[15:7] = 9'h122;
  };

  reg tempsens1_ctrl_reg_ext {
    desc = "MSB of noise threshold.Used to generate different noise co efficient in the sensor based on this threshold. The threshold of approximately 80C is used for this purpose";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "MSB of noise threshold.Used to generate different noise co efficient in the sensor based on this threshold. The threshold of approximately 80C is used for this purpose";
    } tempsens1_ctrl_reg_ext[8:0] = 9'h100;
  };

  reg tempvsens1_value_55_1 {
    desc = "Output code[18:16] of sensor at 55C  used for calibration";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in normal (IP) mode";
    } tempsens1_temp_value_55c_16[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in normal (IP) mode";
    } tempsens1_temp_value_55c_17[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in normal (IP) mode";
    } tempsens1_temp_value_55c_18[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in diode1 mode";
    } tempsens1_temp_value_55c_sm1_16[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in diode1 mode";
    } tempsens1_temp_value_55c_sm1_17[4:4] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in diode1 mode";
    } tempsens1_temp_value_55c_sm1_18[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in diode2 mode";
    } tempsens1_temp_value_55c_sm2_16[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in diode2 mode";
    } tempsens1_temp_value_55c_sm2_17[7:7] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in diode2 mode";
    } tempsens1_temp_value_55c_sm2_18[8:8] = 1'h0;
  };

  reg tempvsens1_value_55_sm1 {
    desc = "Temperature code at 55 degree Centigrade for normal Diode 1 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in diode1 mode";
    } tempsens1_temp_value_55c_sm1[15:0] = 16'hca7a;
  };

  reg tempvsens1_value_55_sm2 {
    desc = "Temperature code at 55 degree Centigrade for normal Diode 2 mode";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "the value that decides which of the slopes (m1;c1;m2;c2) has to be used for conversion. (m1;c1) is used if temp_value < temp_value_55c (m2;c2) is used if temp_value > temp_value_55c. This value is used in diode2 mode";
    } tempsens1_temp_value_55c_sm2[15:0] = 16'hca7a;
  };

  reg asil_check_enables_05 {
    desc = "Each bit of this register when set will cause the corresponding check to automatically be ran during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable to check Sreg write addr data mismatch from AHM";
    } bad_wraddr_chk_en[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable to check Sreg write data mismatch from AHM";
    } bad_wrdata_chk_en[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable to check Sreg read data mismatch from AHM";
    } bad_rddata_chk_en[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable to check PMU Sreg write addr data mismatch from AHM";
    } pmu_bad_wraddr_chk_en[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable to check PMU Sreg write data mismatch from AHM";
    } pmu_bad_wrdata_chk_en[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable to check PMU Sreg read data mismatch from AHM";
    } pmu_bad_rddata_chk_en[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for transient fault detection of Sequencer1 execution";
    } en_seq1_transient_crc_chk[6:6] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for transient fault detection of Sequencer2 execution";
    } en_seq2_transient_crc_chk[7:7] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable RNC and DBLC correction value calculated from DTR pixel data check against expected value";
    } rnc_dblc_dtr_fault_en[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable camera service extension SM check on I2C bus";
    } cse_fault_en[15:15] = 1'h0;
  };

  reg asil_pin_enables_05 {
    desc = "Each bit of this register when set will allow the corresponding check results onto the SYS_CHECK pin.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Sreg write addr data mismatch from AHM onto SYS_CHECK";
    } bad_wraddr_pin_en[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Sreg write data mismatch from AHM onto SYS_CHECK";
    } bad_wrdata_pin_en[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Sreg read data mismatch from AHM onto SYS_CHECK";
    } bad_rddata_pin_en[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting PMU Sreg write addr data mismatch from AHM onto SYS_CHECK";
    } pmu_bad_wraddr_pin_en[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting PMU Sreg write data mismatch from AHM onto SYS_CHECK";
    } pmu_bad_wrdata_pin_en[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting PMU Sreg read data mismatch from AHM onto SYS_CHECK";
    } pmu_bad_rddata_pin_en[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting transient fault of Sequencer1 execution to be detected onto SYS_CHECK";
    } en_seq1_transient_crc_pin[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting transient fault of Sequencer2 execution to be detected onto SYS_CHECK";
    } en_seq2_transient_crc_pin[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting RNC and DBLC correction value calculated from DTR pixel data mismatch error onto SYS_CHECK";
    } rnc_dblc_dtr_fault_pin[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting camera service extension error on I2C bus onto SYS_CHECK";
    } cse_fault_pin[15:15] = 1'h0;
  };

  reg asil_check_enables_02 {
    desc = "Each bit of this register when set will cause the corresponding check to automatically be ran during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the fixed table CRC and fixed_tbl_reg_cmp check. Only valid when bit 0 of  ASIL_CHECK_ENABLE_02 is asserted. When set the check has failed.";
    } en_tbrs_tbl_crc_status[0:0] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable the locked RAM CRC check.  Only valid when bit 1 of  ASIL_CHECK_ENABLE_02 is asserted. When set the CRC check has failed.";
    } en_tbrs_ram_crc_status[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable 8 to 4 conversion buffer CRC check";
    } en_buf824_crc_status[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable tempsensor safety PTAT check";
    } sm_ptat_syschk_en[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable tempsensor safety CONS continuous trigger check";
    } sm_cons_syschk_en[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable tempsensor PMU supply check";
    } sm_pmu_supply_syschk_en[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable shutter address SM CRC check";
    } en_address_sm_crc_status[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable embedded register CRC check";
    } en_embedded_crc_status[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable DTR region CRC check";
    } en_dtr_crc_status[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable FRAME or ROW CRC check";
    } en_row_frame_crc_status[15:15] = 1'h0;
  };

  reg asil_startup_enables_00 {
    desc = "Each bit of this register when set will cause the correspending check to automatically be ran during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "run m3rom scan during initialization. enabled by default for AR0341";
    } en_startup_m3rom_status[0:0] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "run OTPM scan from standby state";
    } en_otpm_scan[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "run ireg scan from standby state";
    } en_ireg_scan[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "run PDI scan from standby state";
    } en_pdi_scan[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Not supported";
    } startup_bist_en[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "enable Test frame. Once set; it sets the chip is streaming mode sends a frame out and goes back to standby. This bit is self cleared.";
    } check_frame_en[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "mask test frame data out of odp for test frame";
    } mask_test_frame[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Not supported";
    } poweron_bist2_at_standby[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Not supported";
    } poweron_bist2_at_power_up[13:13] = 1'h0;
  };

  reg asil_pin_enables_02 {
    desc = "Each bit of this register when set will allow the corresponding check results onto the SYS_CHECK pin.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting the fixed table CRC and fixed_tbl_reg_cmp check error onto SYS_CHECK. Only valid when bit 0 of  ASIL_CHECK_ENABLE_02 is asserted. When set the check has failed.";
    } en_pin_tbrs_tbl_crc_status[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reoprting the locked RAM CRC check error onto SYS_CHECK.  Only valid when bit 1 of  ASIL_CHECK_ENABLE_02 is asserted. When set the CRC check has failed.";
    } en_pin_tbrs_ram_crc_status[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting 8 to 4 conversion buffer CRC check error onto SYS_CHECK";
    } en_pin_buf824_crc_status[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting tempsensor safety PTAT check error onto SYS_CHECK";
    } sm_ptat_syschk_pin_en[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting tempsensor safety CONS continuous trigger check error onto SYS_CHECK";
    } sm_cons_syschk_pin_en[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting tempsensor PMU supply check error onto SYS_CHECK";
    } sm_pmu_supply_syschk_pin_en[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting shutter address SM CRC check error onto SYS_CHECK";
    } en_pin_address_sm_crc_status[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting embedded register CRC check error onto SYS_CHECK";
    } en_pin_embedded_crc_status[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting DTR region CRC check error onto SYS_CHECK";
    } en_pin_dtr_crc_status[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting FRAME or ROW CRC check error onto SYS_CHECK";
    } en_pin_row_frame_crc_status[15:15] = 1'h0;
  };

  reg asil_startup_pin_enables_00 {
    desc = "Each bit of this register when set will allow the corresponding check results onto the SYS_CHECK pin.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable M3ROM crc check onto SYS_CHECK pin";
    } en_pin_sys_check_m3rom[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable OTPM crc check onto SYS_CHECK pin";
    } en_pin_sys_check_otpm[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable IREG crc check onto SYS_CHECK pin";
    } en_pin_sys_check_ireg[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable PDI scan check onto SYS_CHECK pin";
    } en_pin_sys_check_pdim[3:3] = 1'h0;
  };

  reg asil_check_enables_06 {
    desc = "Each bit of this register when set will cause the corresponding check to automatically be ran during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for OTPM cache RAM ECC single bit error correction status bit check";
    } en_otpm_ram_sec[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Channel converter RAM ECC single bit error correction status bit check";
    } en_conv_ram_sec[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for DCDS RAM ECC single bit error correction status bit check";
    } en_dcds_ram_sec[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Analog to Digital asynch FIFO RAM ECC single bit error correction status bit check";
    } en_digclk_ram_sec[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Overflow linearization RAM ECC single bit error correction status bit check";
    } en_ofl_ram_ecc_sec[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Pixel Defect Identification base RAM ECC single bit error correction status bit check";
    } en_pdi_base_ram_sec[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Pixel Defect Identification stream RAM ECC single bit error correction status bit check";
    } en_pdi_stream_ram_sec[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Delay Buffer RAM ECC single bit error correction status bit check";
    } en_delay_buffer_ram_sec[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Pixel defect correction RAM ECC single bit error correction status bit check";
    } en_pdc_ram_sec[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Secondary path ODP FIFO RAM ECC single bit error correction status bit check";
    } en_odp2_ram_sec[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Primary path ODP FIFO RAM ECC single bit error correction status bit check";
    } en_odp1_ram_sec[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Context switch RAM ECC single bit error correction status bit check";
    } en_ctx_ram_ecc_sec[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for TBRS RAM ECC single bit error correction status bit check";
    } en_tbrs_ram_ecc_sec[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for OTPM record ECC single bit error correction status bit check";
    } en_otpm_ecc_sec[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for SEQ2 RAM ECC single bit error correction status bit check";
    } en_seq2_ram_ecc_sec[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for SEQ1 RAM ECC single bit error correction status bit check";
    } en_seq_ram_ecc_sec[15:15] = 1'h0;
  };

  reg asil_pin_enables_06 {
    desc = "Each bit of this register when set will allow the corresponding check results onto the SYS_CHECK pin.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting OTPM cache RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_otpm_ram_sec[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Channel converter RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_conv_ram_sec[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting DCDS RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_dcds_ram_sec[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Analog to Digital asynch FIFO RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_digclk_ram_sec[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Overflow linearization RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_ofl_ram_ecc_sec[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Pixel Defect Identification base RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_pdi_base_ram_sec[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Pixel Defect Identification stream RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_pdi_stream_ram_sec[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Delay Buffer RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_delay_buffer_ram_sec[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Pixel defect correction RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_pdc_ram_sec[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Secondary path ODP FIFO RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_odp2_ram_sec[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Primary path ODP FIFO RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_odp1_ram_sec[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Context switch RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_ctx_ram_ecc_sec[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting TBRS RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_tbrs_ram_ecc_sec[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting OTPM record ECC single bit error correction status onto SYS_CHECK";
    } en_pin_otpm_ecc_sec[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting SEQ2 RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_seq2_ram_ecc_sec[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting SEQ1 RAM ECC single bit error correction status onto SYS_CHECK";
    } en_pin_seq_ram_ecc_sec[15:15] = 1'h0;
  };

  reg wait_fv_lv_time {
    desc = "Marks the time allocated in the master state machine to wait for FV/LV to stop";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Marks the time allocated in the master state machine to wait for FV/LV to stop";
    } wait_fv_lv_time[15:0] = 16'hc0;
  };

  reg asil_check_enables_07 {
    desc = "Each bit of this register when set will cause the corresponding check to automatically be ran during a frame time.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for OTPM cache RAM ECC double error detected status bit check";
    } en_otpm_ram_ded[0:0] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Channel converter RAM ECC double error detected status bit check";
    } en_conv_ram_ded[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for DCDS RAM ECC double error detected status bit check";
    } en_dcds_ram_ded[2:2] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Analog to Digital asynch FIFO RAM ECC double error detected status bit check";
    } en_digclk_ram_ded[3:3] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Overflow linearization RAM ECC double error detected status bit check";
    } en_ofl_ram_ecc_ded[4:4] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Pixel Defect Identification base RAM ECC double error detected status bit check";
    } en_pdi_base_ram_ded[5:5] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Pixel Defect Identification stream RAM ECC double error detected status bit check";
    } en_pdi_stream_ram_ded[6:6] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Delay Buffer RAM ECC double error detected status bit check";
    } en_delay_buffer_ram_ded[7:7] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Pixel defect correction RAM ECC double error detected status bit check";
    } en_pdc_ram_ded[8:8] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Secondary path ODP FIFO RAM ECC double error detected status bit check";
    } en_odp2_ram_ded[9:9] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Primary path ODP FIFO RAM ECC double error detected status bit check";
    } en_odp1_ram_ded[10:10] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for Context switch RAM ECC double error detected status bit check";
    } en_ctx_ram_ecc_ded[11:11] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for TBRS RAM ECC double error detected status bit check";
    } en_tbrs_ram_ecc_ded[12:12] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for OTPM record ECC double error detected status bit check";
    } en_otpm_ecc_ded[13:13] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for SEQ2 RAM ECC double error detected status bit check";
    } en_seq2_ram_ecc_ded[14:14] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable for SEQ1 RAM ECC double error detected status bit check";
    } en_seq_ram_ecc_ded[15:15] = 1'h1;
  };

  reg asil_pin_enables_07 {
    desc = "Each bit of this register when set will allow the corresponding check results onto the SYS_CHECK pin.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting OTPM cache RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_otpm_ram_ded[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Channel converter RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_conv_ram_ded[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting DCDS RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_dcds_ram_ded[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Analog to Digital asynch FIFO RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_digclk_ram_ded[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Overflow linearization RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_ofl_ram_ecc_ded[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Pixel Defect Identification base RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_pdi_base_ram_ded[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Pixel Defect Identification stream RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_pdi_stream_ram_ded[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Delay Buffer RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_delay_buffer_ram_ded[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Pixel defect correction RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_pdc_ram_ded[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Secondary path ODP FIFO RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_odp2_ram_ded[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Primary path ODP FIFO RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_odp1_ram_ded[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting Context switch RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_ctx_ram_ecc_ded[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting TBRS RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_tbrs_ram_ecc_ded[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting OTPM record ECC double error detected status onto SYS_CHECK";
    } en_pin_otpm_ecc_ded[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting SEQ2 RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_seq2_ram_ecc_ded[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable reporting SEQ1 RAM ECC double error detected status onto SYS_CHECK";
    } en_pin_seq_ram_ecc_ded[15:15] = 1'h0;
  };

  reg otpm_core_macro_lock {
    desc = "OTPM0/1 VPP lock register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "OTPM0/1 VPP lock register";
    } otpm_core_macro_lock[4:0] = 5'h1;
  };

  reg tempvsens1_tmg_ctrl {
    desc = "bottom temperature sensor voltage monitoring and timing control";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enables temperature conversion trigger during streaming when test mode is enabled";
    } vmon1_start_conv_strm[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enables temperature conversion trigger during standby when test mode is enabled";
    } vmon1_start_conv_stby[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "set to enable the manual vmon1_test_ctrl_i register and write successively into vmon1 data registers";
    } vmon1_addr_cont[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "set to clear all the vmon1 data registers";
    } vmon1_clear_values[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Test mode control register";
    } temp1_test_ctrl_i[7:4] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Divides bottom temperature sensor clock vt_pixel_clock by n-value";
    } tempsens1_div_by_n[12:8] = 5'hd;
    field {
      hw = r;
      sw = rw;
      desc = "set to trigger vmon1 conversions continuously unless continuous temperature triggering is enabled";
    } vmon1_trig_cont[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "set to trigger bottom  temperature conversions continuously";
    } temp1_trig_cont[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "set to ensure bottom temperature conversions are doing temperature only";
    } temp1_addr_lock[15:15] = 1'h0;
  };

  reg tempvsens1_flag_ctrl {
    desc = "bottom temperature sensor flag control";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Not used in the design";
    } flag1_spare[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Compare against temp value; if temp_comp < temp value then the red flag is set.";
    } tempvsens1_flag_ctrl_tempsens1_yellow_hyst[5:1] = 5'h14;
    field {
      hw = r;
      sw = rw;
      desc = "Once yellow flag is set ; then to clear it the below condition has to be satisfied; temp_value> temp_value_comp - temp_value_offset- temp_value_hysteresis";
    } tempvsens1_flag_ctrl_tempsens1_red_temp_code[15:6] = 10'h21c;
  };

  reg tempvsens1_tmg_ctrl_ex {
    desc = "Not used in the design";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Not used in the design";
    } tempsens1_div_by_n_ext[2:0] = 3'h0;
  };

  reg otpm_timing0 {
    desc = "OTPM timing parameters.  <NEWLINE> [3:0] => read width  <NEWLINE> [7:4] => vbg settle  <NEWLINE> [15:8] => program width.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "OTPM timing parameters.  <NEWLINE> [3:0] => read width  <NEWLINE> [7:4] => vbg settle  <NEWLINE> [15:8] => program width.";
    } otpm_timing0[15:0] = 16'h1e21;
  };

  reg otpm_timing1 {
    desc = "OTPM timing parameters.  <NEWLINE> [3:0] => OP recovery  <NEWLINE> [7:4] => VRR settle  <NEWLINE> [11:8] => VQQ settle  <NEWLINE> [15:12] => VPP settle";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "OTPM timing parameters.  <NEWLINE> [3:0] => OP recovery  <NEWLINE> [7:4] => VRR settle  <NEWLINE> [11:8] => VQQ settle  <NEWLINE> [15:12] => VPP settle";
    } otpm_timing1[15:0] = 16'h8479;
  };

  reg otpm_ipsmr0_10 {
    desc = "LSB 16 bits of MRR settings for IPS in IDLE state";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "LSB 16 bits of MRR settings for IPS in IDLE state";
    } otpm_ipsmr0_10[15:0] = 16'h6ca1;
  };

  reg otpm_ipsmr0_32 {
    desc = "MSB 16 bits of MRR settings for IPS in IDLE state";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "MSB 16 bits of MRR settings for IPS in IDLE state";
    } otpm_ipsmr0_32[15:0] = 16'h608;
  };

  reg otpm_ipsmr1_10 {
    desc = "LSB 16 bits of MRR settings for IPS for read";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "LSB 16 bits of MRR settings for IPS for read";
    } otpm_ipsmr1_10[15:0] = 16'h6ca1;
  };

  reg otpm_ipsmr1_32 {
    desc = "MSB 16 bits of MRR settings for IPS for read";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "MSB 16 bits of MRR settings for IPS for read";
    } otpm_ipsmr1_32[15:0] = 16'h908;
  };

  reg otpm_ipsmr2_10 {
    desc = "LSB 16 bits of MRR settings for IPS for write";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "LSB 16 bits of MRR settings for IPS for write";
    } otpm_ipsmr2_10[15:0] = 16'h6ca1;
  };

  reg otpm_ipsmr2_32 {
    desc = "MSB 16 bits of MRR settings for IPS for write";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "MSB 16 bits of MRR settings for IPS for write";
    } otpm_ipsmr2_32[15:0] = 16'h3908;
  };

  reg otpm_shfmr0_10 {
    desc = "MRR setting for SHF OTPM for IDLE state";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "MRR setting for SHF OTPM for IDLE state";
    } otpm_shfmr0_10[15:0] = 16'hfc0;
  };

  reg otpm_shfmr1_10 {
    desc = "MRR setting for SHF OTPM for read";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "MRR setting for SHF OTPM for read";
    } otpm_shfmr1_10[15:0] = 16'hfd0;
  };

  reg otpm_shfmr2_10 {
    desc = "MRR setting for SHF OTPM for write";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "MRR setting for SHF OTPM for write";
    } otpm_shfmr2_10[15:0] = 16'hfc0;
  };

  reg cse_ess_cci_rsvd_1 {
    desc = "";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "";
    } cse_ess_cci_rsvd_1[7:0] = 8'h0;
  };

  reg cse_service_descriptor {
    desc = "Used to enable CSE operation and specify the operating mode  (Mode1 or Mode2)";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Enables CSE operation";
    } fusa_enable[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Indicates the CSE operating Mode 0x00 (mode1) 0x01 (Mode2)";
    } fusa_mode[2:1] = 2'h0;
  };

  reg cse_write_tag_clr {
    desc = "Write only register only available in Mode1 used to clear the write count tag";
    regwidth = 8;
    field {
      hw = r;
      sw = r;
      desc = "Write to 1 to clear write cnt tag";
    } clr[0:0] = 1'h0;
  };

  reg cse_write_msg_cnt {
    desc = "Write message counter";
    regwidth = 8;
    field {
      hw = r;
      sw = rw;
      desc = "count of write messages";
    } wmc[7:0] = 8'h0;
  };

  reg cse_write_msg_crc {
    desc = "write message crc accumulator";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "current write message crc";
    } wcrc[15:0] = 16'hffff;
  };

  reg cse_read_msg_cnt {
    desc = "Read message counter";
    regwidth = 8;
    field {
      hw = r;
      sw = rw;
      desc = "Current read message count";
    } rmc[7:0] = 8'h0;
  };

  reg cse_read_msg_crc {
    desc = "Read message crc accumulator";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "current rad message crc";
    } rcrc[15:0] = 16'hffff;
  };

  reg cse_fault_status {
    desc = "Fault status";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Current fault status";
    } fault[15:0] = 16'h0;
  };

  reg asil_status_02_dup {
    desc = "asil_status_02_dup is a mirrored image of the asil_status_02. The actual status is a OR of these two register. However this duplicate can be written independently.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates the status of thefixed table CRC and fixed_tbl_reg_cmp check. Only valid when bit 0 of  ASIL_CHECK_ENABLE_02 is asserted. When set the check has failed.";
    } asil_status_02_dup_tbrs_tbl_crc_status[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates the status of the of the locked RAM CRC check.  Only valid when bit 1 of  ASIL_CHECK_ENABLE_02 is asserted. When set the CRC check has failed.";
    } asil_status_02_dup_tbrs_ram_crc_status[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates the status of the shutter address SM CRC check";
    } asil_status_02_dup_address_sm_crc_status[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates the status of the embedded register CRC check";
    } asil_status_02_dup_embedded_crc_status[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates the status of image DTR region CRC check";
    } asil_status_02_dup_dtr_crc_status[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates the status of image FRAME or ROW CRC check";
    } asil_status_02_dup_row_frame_crc_status[15:15] = 1'h0;
  };

  reg asil_startup_status_00_dup {
    desc = "asil_startup_status_00_dup is a mirrored image of the asil_startup_status_00. The actual status is a OR of these two register. However this duplicate can be written independently.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates m3rom scan status. 0 - Pass. 1 - Fail";
    } asil_startup_status_00_dup_startup_m3rom_status[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates OTPM scan status. 0 - Pass. 1 - Fail";
    } asil_startup_status_00_dup_otpm_scan_status[1:1] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Ireg scan status. 0 - Pass. 1 - Fail";
    } asil_startup_status_00_dup_ireg_scan_status[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates PDI scan status. 0 - Pass. 1 - Fail";
    } asil_startup_status_00_dup_pdi_scan_status[3:3] = 1'h0;
  };

  reg asil_status_05_dup {
    desc = "asil_status_05_dup is a mirrored image of the asil_status_05. The actual status is a OR of these two register. However this duplicate can be written independently.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Sreg write addr data mismatch from AHM";
    } asil_status_05_dup_bad_wraddr[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Sreg write data mismatch from AHM";
    } asil_status_05_dup_bad_wrdata[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Sreg read data mismatch from AHM";
    } asil_status_05_dup_bad_rddta[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates PMU Sreg write addr data mismatch from AHM";
    } asil_status_05_dup_pmu_bad_wraddr[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates PMU Sreg write data mismatch from AHM";
    } asil_status_05_dup_pmu_bad_wrdata[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates PMU Sreg read data mismatch from AHM";
    } asil_status_05_dup_pmu_bad_rddata[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates a transient error detected in Sequencer1 execution";
    } asil_status_05_dup_seq1_transient_crc_err[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates a transient error detected in Sequencer2 execution";
    } asil_status_05_dup_seq2_transient_crc_err[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates RNC and DBLC correction value calculated from DTR pixel data does not match expected value";
    } asil_status_05_dup_rnc_dblc_dtr_fault[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates camera service extension error on I2C bus has occurred";
    } asil_status_05_dup_cse_fault[15:15] = 1'h0;
  };

  reg asil_status_07_dup {
    desc = "asil_status_07_dup is a mirrored image of the asil_status_07. The actual status is a OR of these two register. However this duplicate can be written independently.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates OTPM cache RAM ECC double error detected status";
    } asil_status_07_dup_otpm_ram_ded[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Channel converter RAM ECC double error detected status";
    } asil_status_07_dup_conv_ram_ded[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates DCDS RAM ECC double error detected status";
    } asil_status_07_dup_dcds_ram_ded[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Analog to Digital asynch FIFO RAM ECC double error detected status";
    } asil_status_07_dup_digclk_ram_ded[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Overflow linearization RAM ECC double error detected status";
    } asil_status_07_dup_ofl_ram_ecc_ded[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Pixel Defect Identification base RAM ECC double error detected status";
    } asil_status_07_dup_pdi_base_ram_ded[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Pixel Defect Identification stream RAM ECC double error detected status";
    } asil_status_07_dup_pdi_stream_ram_ded[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Delay Buffer RAM ECC double error detected status";
    } asil_status_07_dup_delay_buffer_ram_ded[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Pixel defect correction RAM ECC double error detected status";
    } asil_status_07_dup_pdc_ram_ded[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Secondary path ODP FIFO RAM ECC double error detected status";
    } asil_status_07_dup_odp2_ram_ded[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Primary path ODP FIFO RAM ECC double error detected status";
    } asil_status_07_dup_odp1_ram_ded[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Context switch RAM ECC double error detected status";
    } asil_status_07_dup_ctx_ram_ecc_ded[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates TBRS RAM ECC double error detected status";
    } asil_status_07_dup_tbrs_ram_ecc_ded[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates OTPM record ECC double error detected status";
    } asil_status_07_dup_otpm_ecc_ded[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates SEQ2 RAM ECC double error detected status";
    } asil_status_07_dup_seq2_ram_ecc_ded[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates SEQ1 RAM ECC double error detected status";
    } asil_status_07_dup_seq1_ram_ecc_ded[15:15] = 1'h0;
  };

  reg asil_status_06_dup {
    desc = "asil_status_06_dup is a mirrored image of the asil_status_06. The actual status is a OR of these two register. However this duplicate can be written independently.";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates OTPM cache RAM ECC single bit error correction status";
    } asil_status_06_dup_otpm_ram_sec[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Channel converter RAM ECC single bit error correction status";
    } asil_status_06_dup_conv_ram_sec[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates DCDS RAM ECC single bit error correction status";
    } asil_status_06_dup_dcds_ram_sec[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Analog to Digital asynch FIFO RAM ECC single bit error correction status";
    } asil_status_06_dup_digclk_ram_sec[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Overflow linearization RAM ECC single bit error correction status";
    } asil_status_06_dup_ofl_ram_ecc_sec[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Pixel Defect Identification base RAM ECC single bit error correction status";
    } asil_status_06_dup_pdi_base_ram_sec[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Pixel Defect Identification stream RAM ECC single bit error correction status";
    } asil_status_06_dup_pdi_stream_ram_sec[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Delay Buffer RAM ECC single bit error correction status";
    } asil_status_06_dup_delay_buffer_ram_sec[7:7] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Pixel defect correction RAM ECC single bit error correction status";
    } asil_status_06_dup_pdc_ram_sec[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Secondary path ODP FIFO RAM ECC single bit error correction status";
    } asil_status_06_dup_odp2_ram_sec[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Primary path ODP FIFO RAM ECC single bit error correction status";
    } asil_status_06_dup_odp1_ram_sec[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates Context switch RAM ECC single bit error correction status";
    } asil_status_06_dup_ctx_ram_ecc_sec[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates TBRS RAM ECC single bit error correction status";
    } asil_status_06_dup_tbrs_ram_ecc_sec[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates OTPM record ECC single bit error correction status";
    } asil_status_06_dup_otpm_ecc_sec[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates SEQ2 RAM ECC single bit error correction status";
    } asil_status_06_dup_seq2_ram_ecc_sec[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Duplicate bit that indicates SEQ1 RAM ECC single bit error correction status";
    } asil_status_06_dup_seq1_ram_ecc_sec[15:15] = 1'h0;
  };

  reg ecc_fault_injection1 {
    desc = "Fault injection register on memories with ECC";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault in context switch memory. 01: single fault<COMMA> 10: double fault";
    } ctx[1:0] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault in channel converter line buffer1 memories. 01: single fault<COMMA> 10: double fault";
    } conv_lb1[3:2] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault in OTPM cache memory. 01: single fault<COMMA> 10: double fault";
    } otpm[5:4] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault in sequencer1 memory. 01: single fault<COMMA> 10: double fault";
    } seq1[7:6] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault in sequencer2 memory. 01: single fault<COMMA> 10: double fault";
    } seq2[9:8] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault in PDI base memory. 01: single fault<COMMA> 10: double fault";
    } pdi_bram[11:10] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault in PDI stream memory. 01: single fault<COMMA> 10: double fault";
    } pdi_sram[13:12] = 2'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault in channel converter line buffer2 memories. 01: single fault<COMMA>10: double fault";
    } conv_lb2[15:14] = 2'h0;
  };

  reg otpm_ecc_fault_inj {
    desc = "OTPM record ECC fault injection register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Number of OTPM clocks to wait until 1 bit fault is injected";
    } oefi_sec_dly[2:0] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Number of OTPM words to wait until 1 bit fault is injected";
    } oefi_sec_num[6:3] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Number of OTPM clocks to wait until 2 bit fault is injected";
    } oefi_ded_dly[9:7] = 3'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Number of OTPM words to wait until 2 bit fault is injected";
    } oefi_ded_num[13:10] = 4'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable fault injection on 1 bit of OTPM record to trigger an ECC single error correction";
    } oefi_sec_en[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Enable fault injection on 2 bits of OTPM record to trigger an ECC double error detection";
    } oefi_ded_en[15:15] = 1'h0;
  };

  reg crc_fault_injection {
    desc = "Fault injection register for challenge response<COMMA>address shutter and m3rom CRC check";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into m3rom CRC";
    } m3rom[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into address t1 readout state machine CRC.  Bit self-clears once fault is detected on asil_status register.";
    } fault_inject_shutter_crc_t1[8:8] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into address t2 readout state machine CRC.  Bit self-clears once fault is detected on asil_status register.";
    } fault_inject_shutter_crc_t2[9:9] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into address t3 readout state machine CRC.  Bit self-clears once fault is detected on asil_status register.";
    } fault_inject_shutter_crc_t3[10:10] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into address t4 readout state machine CRC.  Bit self-clears once fault is detected on asil_status register.";
    } fault_inject_shutter_crc_t4[11:11] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into address s1 shutter state machine CRC.  Bit self-clears once fault is detected on asil_status register.";
    } fault_inject_shutter_crc_s1[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into address s2 shutter state machine CRC.  Bit self-clears once fault is detected on asil_status register.";
    } fault_inject_shutter_crc_s2[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into sequencer1 challenge response CRC.  Bit self-clears once fault is detected on asil_status register.";
    } fault_inject_seq1_transient_crc[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Inject fault into sequencer2 challenge response CRC.  Bit self-clears once fault is detected on asil_status register.";
    } fault_inject_seq2_transient_crc[15:15] = 1'h0;
  };

  reg cp_soft_start_ctrl {
    desc = "Soft chargepump control register";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "AHM pin";
    } soft_start_adj_cplo[2:0] = 3'h4;
    field {
      hw = r;
      sw = rw;
      desc = "AHM pin";
    } soft_start_adj_cphi[5:3] = 3'h4;
    field {
      hw = r;
      sw = rw;
      desc = "AHM pin";
    } sel_vaa_bp[6:6] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Soft start pulse width selection; range 10ms(4'b0000) to 150ms(4'b0111) in steps of 10ms";
    } cp_soft_start_pulse_width[10:7] = 4'ha;
    field {
      hw = r;
      sw = rw;
      desc = "Enable to set soft_start pin for chargepump";
    } cp_soft_start_en[11:11] = 1'h1;
    field {
      hw = r;
      sw = rw;
      desc = "Enable bit to start chargepump startup control";
    } charge_pump_enable[12:12] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Not used.";
    } bst_mon_adc_regdb_pwr_on[13:13] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Derive cp_hi_clk and cp_low_clk by sequencer rise and fall opcodes";
    } seq_cp_row_clk[14:14] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "Drive soft start pulse Ton by 1 ms";
    } cp_ss_pulse_1ms[15:15] = 1'h0;
  };

  reg pmu_vout_r1 {
    desc = "PMIC voltage rail 1 settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage rail 1 settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_vout_r1[15:0] = 16'h0;
  };

  reg pmu_cfg_r1 {
    desc = "PMIC voltage 1 configuration<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage 1 configuration<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_cfg_r1[15:0] = 16'h0;
  };

  reg pmu_mon_ov_r1 {
    desc = "PMIC voltage 1 over voltage monitor settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage 1 over voltage monitor settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_mon_ov_r1[15:0] = 16'h0;
  };

  reg pmu_mon_uv_r1 {
    desc = "PMIC voltage 1 under voltage monitor settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage 1 under voltage monitor settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_mon_uv_r1[15:0] = 16'h0;
  };

  reg pmu_vout_r2 {
    desc = "PMIC voltage rail 2 settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage rail 2 settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_vout_r2[15:0] = 16'h0;
  };

  reg pmu_cfg_r2 {
    desc = "PMIC voltage 2 configuration<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage 2 configuration<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_cfg_r2[15:0] = 16'h0;
  };

  reg pmu_mon_ov_r2 {
    desc = "PMIC voltage 2 over voltage monitor settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage 2 over voltage monitor settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_mon_ov_r2[15:0] = 16'h0;
  };

  reg pmu_mon_uv_r2 {
    desc = "PMIC voltage 2 under voltage monitor settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage 2 under voltage monitor settings<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_mon_uv_r2[15:0] = 16'h0;
  };

  reg pmu_wr_prot {
    desc = "PMIC write protection register write<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC write protection register write<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_wr_prot[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r1 {
    desc = "PMIC power down sequence settings register 1<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 1<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r1[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r2 {
    desc = "PMIC power down sequence settings register 2<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 2<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r2[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r3 {
    desc = "PMIC power down sequence settings register 3<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 3<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r3[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r4 {
    desc = "PMIC power down sequence settings register 4<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 4<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r4[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r5 {
    desc = "PMIC power down sequence settings register 5<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 5<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r5[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r6 {
    desc = "PMIC power down sequence settings register 6<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 6<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r6[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r7 {
    desc = "PMIC power down sequence settings register 7<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 7<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r7[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r8 {
    desc = "PMIC power down sequence settings register 8<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 8<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r8[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r9 {
    desc = "PMIC power down sequence settings register 9<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 9<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r9[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r10 {
    desc = "PMIC power down sequence settings register 10<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 10<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r10[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r11 {
    desc = "PMIC power down sequence settings register 11<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 11<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r11[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r12 {
    desc = "PMIC power down sequence settings register 12<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 12<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r12[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r13 {
    desc = "PMIC power down sequence settings register 13<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 13<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r13[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r14 {
    desc = "PMIC power down sequence settings register 14<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 14<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r14[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r15 {
    desc = "PMIC power down sequence settings register 15<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 15<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r15[15:0] = 16'h0;
  };

  reg pmu_pd_seq_r16 {
    desc = "PMIC power down sequence settings register 16<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence settings register 16<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_r16[15:0] = 16'h0;
  };

  reg pmu_pd_seq_en {
    desc = "PMIC power down sequence enable register<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence enable register<NEWLINE>[15:8] - PMIC register address <NEWLINE>[7:0]   - PMIC register data";
    } pmu_pd_seq_en[15:0] = 16'h0;
  };

  reg pmu_ctrl {
    desc = "PMIC controller";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "";
    } pmu_ctrl_enable[0:0] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC OTPM data enable<NEWLINE>0 - Disable OTPM data write to PMIC from Sensor through I2C<NEWLINE>1 - Enable  OTPM data write to PMIC from Sensor through I2C";
    } pmu_otpm_enable[1:1] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage rail 1 data write enable<NEWLINE>0 - Disable rail 1 data write to PMIC from Sensor through I2C<NEWLINE>1 - Enable  rail 1 data write to PMIC from Sensor through I2C";
    } pmu_rail1_enable[2:2] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC voltage rail 2 data write enable<NEWLINE>0 - Disable rail 2 data write to PMIC from Sensor through I2C<NEWLINE>1 - Enable  rail 2 data write to PMIC from Sensor through I2C";
    } pmu_rail2_enable[3:3] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "PMIC power down sequence data write enable<NEWLINE>0 - Disable PD data write to PMIC from Sensor through I2C<NEWLINE>1 - Enable  PD data write to PMIC from Sensor through I2C";
    } pmu_pd_en[4:4] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "PMU voltage regulator oscillator enable<NEWLINE>0 - Disable<NEWLINE>1 - Enable";
    } oscillator_en[5:5] = 1'h0;
    field {
      hw = r;
      sw = rw;
      desc = "PMU voltage regulator oscillator pulse period";
    } osc_pulse_period[15:8] = 8'h0;
  };

  reg osc_en_period {
    desc = "Voltage regulator; oscillator enable";
    regwidth = 16;
    field {
      hw = r;
      sw = rw;
      desc = "Voltage regulator; oscillator enable";
    } osc_en_period[9:0] = 10'h3e8;
  };

  reg ahm_osc_count {
    desc = "Voltage regulator; oscillator count";
    regwidth = 16;
    field {
      hw = r;
      sw = r;
      desc = "Voltage regulator; oscillator count";
    } ahm_osc_count[15:0] = 16'h0;
  };

  otpm_status otpm_status @0x2004;

  otpm_status2 otpm_status2 @0x200e;

  asil_status_02 asil_status_02 @0x2064;

  asil_startup_status_00 asil_startup_status_00 @0x2068;

  asil_status_05 asil_status_05 @0x2078;

  asil_status_06 asil_status_06 @0x207a;

  i2c_wrt_count i2c_wrt_count @0x209c;

  tempsens1_dec_ratio tempsens1_dec_ratio @0x2102;

  tempsens1_max_bs tempsens1_max_bs @0x2104;

  tempsens1_init_test_ctrl tempsens1_init_test_ctrl @0x2106;

  tempsens1_chop_cycle tempsens1_chop_cycle @0x2108;

  tempsens1_lookup_addr_offset tempsens1_lookup_addr_offset @0x210a;

  tempsens1_lookup_data_offset tempsens1_lookup_data_offset @0x210c;

  tempsens1_lookup_weight tempsens1_lookup_weight @0x210e;

  tempsens1_lookup_tab_0 tempsens1_lookup_tab_0 @0x2110;

  tempsens1_lookup_tab_1 tempsens1_lookup_tab_1 @0x2112;

  tempsens1_lookup_tab_2 tempsens1_lookup_tab_2 @0x2114;

  tempsens1_lookup_tab_3 tempsens1_lookup_tab_3 @0x2116;

  tempsens1_lookup_tab_4 tempsens1_lookup_tab_4 @0x2118;

  tempvsens1_sreg_diode1_trim_vbe tempvsens1_sreg_diode1_trim_vbe @0x211a;

  tempvsens1_sreg_diode2_trim_vbe tempvsens1_sreg_diode2_trim_vbe @0x211c;

  tempvsens1_sreg_ip_trim_vbe tempvsens1_sreg_ip_trim_vbe @0x211e;

  tempvsens1_sreg_diode1_trim_fine tempvsens1_sreg_diode1_trim_fine @0x2120;

  tempvsens1_sreg_diode2_trim_fine tempvsens1_sreg_diode2_trim_fine @0x2122;

  tempvsens1_sreg_ip_trim_fine tempvsens1_sreg_ip_trim_fine @0x2124;

  tempvsens1_sreg_trim_v_iptat tempvsens1_sreg_trim_v_iptat @0x2126;

  tempvsens1_sreg_trim_vbg_refbuf tempvsens1_sreg_trim_vbg_refbuf @0x2128;

  tempvsens1_sreg_cfg_0_to_12 tempvsens1_sreg_cfg_0_to_12 @0x212a;

  tempvsens1_sreg_cfg_54_to_69 tempvsens1_sreg_cfg_54_to_69 @0x212c;

  tempvsens1_sreg_cfg_70_to_80 tempvsens1_sreg_cfg_70_to_80 @0x212e;

  tempvsens1_sm_seq_ctrl tempvsens1_sm_seq_ctrl @0x2130;

  tempvsens1_sm_seq_sel0 tempvsens1_sm_seq_sel0 @0x2134;

  tempvsens1_sm_seq_sel1 tempvsens1_sm_seq_sel1 @0x2136;

  tempvsens1_sm_seq_sel2 tempvsens1_sm_seq_sel2 @0x2138;

  tempvsens1_data_sc_exp tempvsens1_data_sc_exp @0x2140;

  tempvsens1_data_sc_off tempvsens1_data_sc_off @0x2142;

  temp_value_k_diff_off temp_value_k_diff_off @0x2144;

  otpm_core_crc_status otpm_core_crc_status @0x230e;

  otpm_core_crc_code_lo otpm_core_crc_code_lo @0x2310;

  otpm_core_crc_code_hi otpm_core_crc_code_hi @0x2312;

  otpm_core_crc_code_extra otpm_core_crc_code_extra @0x2314;

  ctx_rd_data_reg ctx_rd_data_reg @0x2500;

  seq_ctrl_port seq_ctrl_port @0x2512;

  tempvsens1_m1_hi_sm2 tempvsens1_m1_hi_sm2 @0x2f10;

  tempvsens1_m1_lo_sm2 tempvsens1_m1_lo_sm2 @0x2f12;

  tempvsens1_c1_hi_sm2 tempvsens1_c1_hi_sm2 @0x2f14;

  tempvsens1_c1_lo_sm2 tempvsens1_c1_lo_sm2 @0x2f16;

  tempvsens1_m2_hi_sm2 tempvsens1_m2_hi_sm2 @0x2f18;

  tempvsens1_m2_lo_sm2 tempvsens1_m2_lo_sm2 @0x2f1a;

  tempvsens1_c2_hi_sm2 tempvsens1_c2_hi_sm2 @0x2f1c;

  tempvsens1_c2_lo_sm2 tempvsens1_c2_lo_sm2 @0x2f1e;

  otpm_status3 otpm_status3 @0x201e;

  asil_status_07 asil_status_07 @0x207c;

  otpm_factory_crc_expected_l otpm_factory_crc_expected_l @0x2320;

  otpm_factory_crc_expected_h otpm_factory_crc_expected_h @0x2322;

  otpm_factory_crc_calculated_l otpm_factory_crc_calculated_l @0x2324;

  otpm_factory_crc_calculated_h otpm_factory_crc_calculated_h @0x2326;

  otpm_customer_crc_expected_l otpm_customer_crc_expected_l @0x2328;

  otpm_customer_crc_expected_h otpm_customer_crc_expected_h @0x232a;

  otpm_customer_crc_calculated_l otpm_customer_crc_calculated_l @0x232c;

  otpm_customer_crc_calculated_h otpm_customer_crc_calculated_h @0x232e;

  model_id_ model_id_ @0x3000;

  revision_number revision_number @0x300e;

  lock_control lock_control @0x3010;

  reset_register reset_register @0x301a;

  ctx_control_reg ctx_control_reg @0x3034;

  otpm_control otpm_control @0x304a;

  otpm_record otpm_record @0x304c;

  otpm_manual_control otpm_manual_control @0x3050;

  otpm_manual_addr otpm_manual_addr @0x3052;

  otpm_expr otpm_expr @0x3054;

  sys_reg_unlock sys_reg_unlock @0x3060;

  ctx_wr_data_reg ctx_wr_data_reg @0x3066;

  reset_lpf_register reset_lpf_register @0x309c;

  digital_test digital_test @0x30b0;

  tempsens1_ctrl_reg tempsens1_ctrl_reg @0x30b8;

  trigger_delay trigger_delay @0x30dc;

  otpm_data_manual_l otpm_data_manual_l @0x313a;

  otpm_data_manual_h otpm_data_manual_h @0x313c;

  otpm_data_manual_extra otpm_data_manual_extra @0x313e;

  i2c_wrt_checksum i2c_wrt_checksum @0x31d6;

  m3rom_wrt_checksum m3rom_wrt_checksum @0x31d8;

  mipi_config_2 mipi_config_2 @0x31f8;

  customer_rev customer_rev @0x31fe;

  m3rom_calc_checksum m3rom_calc_checksum @0x331c;

  crc_control_reg crc_control_reg @0x3324;

  i2c_rd_checksum i2c_rd_checksum @0x3354;

  ext_trigger_delay ext_trigger_delay @0x3400;

  gpio_control1 gpio_control1 @0x340a;

  gpio_control2 gpio_control2 @0x340c;

  gpio_select gpio_select @0x340e;

  low_power_control low_power_control @0x3410;

  master_fsm_req_code master_fsm_req_code @0x3412;

  i2cids0 i2cids0 @0x3420;

  i2cids1 i2cids1 @0x3422;

  i2cids2 i2cids2 @0x3424;

  fuse_id1 fuse_id1 @0x34c0;

  fuse_id2 fuse_id2 @0x34c2;

  fuse_id3 fuse_id3 @0x34c4;

  fuse_id4 fuse_id4 @0x34c6;

  fuse_id5 fuse_id5 @0x34c8;

  fuse_id6 fuse_id6 @0x34ca;

  fuse_id7 fuse_id7 @0x34cc;

  fuse_id8 fuse_id8 @0x34ce;

  otpm_data_0 otpm_data_0 @0x3800;

  otpm_data_1 otpm_data_1 @0x3802;

  otpm_data_2 otpm_data_2 @0x3804;

  otpm_data_3 otpm_data_3 @0x3806;

  otpm_data_4 otpm_data_4 @0x3808;

  otpm_data_5 otpm_data_5 @0x380a;

  otpm_data_6 otpm_data_6 @0x380c;

  otpm_data_7 otpm_data_7 @0x380e;

  otpm_data_8 otpm_data_8 @0x3810;

  otpm_data_9 otpm_data_9 @0x3812;

  otpm_data_10 otpm_data_10 @0x3814;

  otpm_data_11 otpm_data_11 @0x3816;

  otpm_data_12 otpm_data_12 @0x3818;

  otpm_data_13 otpm_data_13 @0x381a;

  otpm_data_14 otpm_data_14 @0x381c;

  otpm_data_15 otpm_data_15 @0x381e;

  otpm_data_16 otpm_data_16 @0x3820;

  otpm_data_17 otpm_data_17 @0x3822;

  otpm_data_18 otpm_data_18 @0x3824;

  otpm_data_19 otpm_data_19 @0x3826;

  otpm_data_20 otpm_data_20 @0x3828;

  otpm_data_21 otpm_data_21 @0x382a;

  otpm_data_22 otpm_data_22 @0x382c;

  otpm_data_23 otpm_data_23 @0x382e;

  otpm_data_24 otpm_data_24 @0x3830;

  otpm_data_25 otpm_data_25 @0x3832;

  otpm_data_26 otpm_data_26 @0x3834;

  otpm_data_27 otpm_data_27 @0x3836;

  otpm_data_28 otpm_data_28 @0x3838;

  otpm_data_29 otpm_data_29 @0x383a;

  otpm_data_30 otpm_data_30 @0x383c;

  otpm_data_31 otpm_data_31 @0x383e;

  otpm_data_32 otpm_data_32 @0x3840;

  otpm_data_33 otpm_data_33 @0x3842;

  otpm_data_34 otpm_data_34 @0x3844;

  otpm_data_35 otpm_data_35 @0x3846;

  otpm_data_36 otpm_data_36 @0x3848;

  otpm_data_37 otpm_data_37 @0x384a;

  otpm_data_38 otpm_data_38 @0x384c;

  otpm_data_39 otpm_data_39 @0x384e;

  otpm_data_40 otpm_data_40 @0x3850;

  otpm_data_41 otpm_data_41 @0x3852;

  otpm_data_42 otpm_data_42 @0x3854;

  otpm_data_43 otpm_data_43 @0x3856;

  otpm_data_44 otpm_data_44 @0x3858;

  otpm_data_45 otpm_data_45 @0x385a;

  otpm_data_46 otpm_data_46 @0x385c;

  otpm_data_47 otpm_data_47 @0x385e;

  otpm_data_48 otpm_data_48 @0x3860;

  otpm_data_49 otpm_data_49 @0x3862;

  otpm_data_50 otpm_data_50 @0x3864;

  otpm_data_51 otpm_data_51 @0x3866;

  otpm_data_52 otpm_data_52 @0x3868;

  otpm_data_53 otpm_data_53 @0x386a;

  otpm_data_54 otpm_data_54 @0x386c;

  otpm_data_55 otpm_data_55 @0x386e;

  otpm_data_56 otpm_data_56 @0x3870;

  otpm_data_57 otpm_data_57 @0x3872;

  otpm_data_58 otpm_data_58 @0x3874;

  otpm_data_59 otpm_data_59 @0x3876;

  otpm_data_60 otpm_data_60 @0x3878;

  otpm_data_61 otpm_data_61 @0x387a;

  otpm_data_62 otpm_data_62 @0x387c;

  otpm_data_63 otpm_data_63 @0x387e;

  otpm_data_64 otpm_data_64 @0x3880;

  otpm_data_65 otpm_data_65 @0x3882;

  otpm_data_66 otpm_data_66 @0x3884;

  otpm_data_67 otpm_data_67 @0x3886;

  otpm_data_68 otpm_data_68 @0x3888;

  otpm_data_69 otpm_data_69 @0x388a;

  otpm_data_70 otpm_data_70 @0x388c;

  otpm_data_71 otpm_data_71 @0x388e;

  otpm_data_72 otpm_data_72 @0x3890;

  otpm_data_73 otpm_data_73 @0x3892;

  otpm_data_74 otpm_data_74 @0x3894;

  otpm_data_75 otpm_data_75 @0x3896;

  otpm_data_76 otpm_data_76 @0x3898;

  otpm_data_77 otpm_data_77 @0x389a;

  otpm_data_78 otpm_data_78 @0x389c;

  otpm_data_79 otpm_data_79 @0x389e;

  otpm_data_80 otpm_data_80 @0x38a0;

  otpm_data_81 otpm_data_81 @0x38a2;

  otpm_data_82 otpm_data_82 @0x38a4;

  otpm_data_83 otpm_data_83 @0x38a6;

  otpm_data_84 otpm_data_84 @0x38a8;

  otpm_data_85 otpm_data_85 @0x38aa;

  otpm_data_86 otpm_data_86 @0x38ac;

  otpm_data_87 otpm_data_87 @0x38ae;

  otpm_data_88 otpm_data_88 @0x38b0;

  otpm_data_89 otpm_data_89 @0x38b2;

  otpm_data_90 otpm_data_90 @0x38b4;

  otpm_data_91 otpm_data_91 @0x38b6;

  otpm_data_92 otpm_data_92 @0x38b8;

  otpm_data_93 otpm_data_93 @0x38ba;

  otpm_data_94 otpm_data_94 @0x38bc;

  otpm_data_95 otpm_data_95 @0x38be;

  otpm_data_96 otpm_data_96 @0x38c0;

  otpm_data_97 otpm_data_97 @0x38c2;

  otpm_data_98 otpm_data_98 @0x38c4;

  otpm_data_99 otpm_data_99 @0x38c6;

  otpm_data_100 otpm_data_100 @0x38c8;

  otpm_data_101 otpm_data_101 @0x38ca;

  otpm_data_102 otpm_data_102 @0x38cc;

  otpm_data_103 otpm_data_103 @0x38ce;

  otpm_data_104 otpm_data_104 @0x38d0;

  otpm_data_105 otpm_data_105 @0x38d2;

  otpm_data_106 otpm_data_106 @0x38d4;

  otpm_data_107 otpm_data_107 @0x38d6;

  otpm_data_108 otpm_data_108 @0x38d8;

  otpm_data_109 otpm_data_109 @0x38da;

  otpm_data_110 otpm_data_110 @0x38dc;

  otpm_data_111 otpm_data_111 @0x38de;

  otpm_data_112 otpm_data_112 @0x38e0;

  otpm_data_113 otpm_data_113 @0x38e2;

  otpm_data_114 otpm_data_114 @0x38e4;

  otpm_data_115 otpm_data_115 @0x38e6;

  otpm_data_116 otpm_data_116 @0x38e8;

  otpm_data_117 otpm_data_117 @0x38ea;

  otpm_data_118 otpm_data_118 @0x38ec;

  otpm_data_119 otpm_data_119 @0x38ee;

  otpm_data_120 otpm_data_120 @0x38f0;

  otpm_data_121 otpm_data_121 @0x38f2;

  otpm_data_122 otpm_data_122 @0x38f4;

  otpm_data_123 otpm_data_123 @0x38f6;

  otpm_data_124 otpm_data_124 @0x38f8;

  otpm_data_125 otpm_data_125 @0x38fa;

  otpm_data_126 otpm_data_126 @0x38fc;

  otpm_data_127 otpm_data_127 @0x38fe;

  otpm_data_128 otpm_data_128 @0x3900;

  otpm_data_129 otpm_data_129 @0x3902;

  otpm_data_130 otpm_data_130 @0x3904;

  otpm_data_131 otpm_data_131 @0x3906;

  otpm_data_132 otpm_data_132 @0x3908;

  otpm_data_133 otpm_data_133 @0x390a;

  otpm_data_134 otpm_data_134 @0x390c;

  otpm_data_135 otpm_data_135 @0x390e;

  otpm_data_136 otpm_data_136 @0x3910;

  otpm_data_137 otpm_data_137 @0x3912;

  otpm_data_138 otpm_data_138 @0x3914;

  otpm_data_139 otpm_data_139 @0x3916;

  otpm_data_140 otpm_data_140 @0x3918;

  otpm_data_141 otpm_data_141 @0x391a;

  otpm_data_142 otpm_data_142 @0x391c;

  otpm_data_143 otpm_data_143 @0x391e;

  otpm_data_144 otpm_data_144 @0x3920;

  otpm_data_145 otpm_data_145 @0x3922;

  otpm_data_146 otpm_data_146 @0x3924;

  otpm_data_147 otpm_data_147 @0x3926;

  otpm_data_148 otpm_data_148 @0x3928;

  otpm_data_149 otpm_data_149 @0x392a;

  otpm_data_150 otpm_data_150 @0x392c;

  otpm_data_151 otpm_data_151 @0x392e;

  otpm_data_152 otpm_data_152 @0x3930;

  otpm_data_153 otpm_data_153 @0x3932;

  otpm_data_154 otpm_data_154 @0x3934;

  otpm_data_155 otpm_data_155 @0x3936;

  otpm_data_156 otpm_data_156 @0x3938;

  otpm_data_157 otpm_data_157 @0x393a;

  otpm_data_158 otpm_data_158 @0x393c;

  otpm_data_159 otpm_data_159 @0x393e;

  otpm_data_160 otpm_data_160 @0x3940;

  otpm_data_161 otpm_data_161 @0x3942;

  otpm_data_162 otpm_data_162 @0x3944;

  otpm_data_163 otpm_data_163 @0x3946;

  otpm_data_164 otpm_data_164 @0x3948;

  otpm_data_165 otpm_data_165 @0x394a;

  otpm_data_166 otpm_data_166 @0x394c;

  otpm_data_167 otpm_data_167 @0x394e;

  otpm_data_168 otpm_data_168 @0x3950;

  otpm_data_169 otpm_data_169 @0x3952;

  otpm_data_170 otpm_data_170 @0x3954;

  otpm_data_171 otpm_data_171 @0x3956;

  otpm_data_172 otpm_data_172 @0x3958;

  otpm_data_173 otpm_data_173 @0x395a;

  otpm_data_174 otpm_data_174 @0x395c;

  otpm_data_175 otpm_data_175 @0x395e;

  otpm_data_176 otpm_data_176 @0x3960;

  otpm_data_177 otpm_data_177 @0x3962;

  otpm_data_178 otpm_data_178 @0x3964;

  otpm_data_179 otpm_data_179 @0x3966;

  otpm_data_180 otpm_data_180 @0x3968;

  otpm_data_181 otpm_data_181 @0x396a;

  otpm_data_182 otpm_data_182 @0x396c;

  otpm_data_183 otpm_data_183 @0x396e;

  otpm_data_184 otpm_data_184 @0x3970;

  otpm_data_185 otpm_data_185 @0x3972;

  otpm_data_186 otpm_data_186 @0x3974;

  otpm_data_187 otpm_data_187 @0x3976;

  otpm_data_188 otpm_data_188 @0x3978;

  otpm_data_189 otpm_data_189 @0x397a;

  otpm_data_190 otpm_data_190 @0x397c;

  otpm_data_191 otpm_data_191 @0x397e;

  otpm_data_192 otpm_data_192 @0x3980;

  otpm_data_193 otpm_data_193 @0x3982;

  otpm_data_194 otpm_data_194 @0x3984;

  otpm_data_195 otpm_data_195 @0x3986;

  otpm_data_196 otpm_data_196 @0x3988;

  otpm_data_197 otpm_data_197 @0x398a;

  otpm_data_198 otpm_data_198 @0x398c;

  otpm_data_199 otpm_data_199 @0x398e;

  otpm_data_200 otpm_data_200 @0x3990;

  otpm_data_201 otpm_data_201 @0x3992;

  otpm_data_202 otpm_data_202 @0x3994;

  otpm_data_203 otpm_data_203 @0x3996;

  otpm_data_204 otpm_data_204 @0x3998;

  otpm_data_205 otpm_data_205 @0x399a;

  otpm_data_206 otpm_data_206 @0x399c;

  otpm_data_207 otpm_data_207 @0x399e;

  otpm_data_208 otpm_data_208 @0x39a0;

  otpm_data_209 otpm_data_209 @0x39a2;

  otpm_data_210 otpm_data_210 @0x39a4;

  otpm_data_211 otpm_data_211 @0x39a6;

  otpm_data_212 otpm_data_212 @0x39a8;

  otpm_data_213 otpm_data_213 @0x39aa;

  otpm_data_214 otpm_data_214 @0x39ac;

  otpm_data_215 otpm_data_215 @0x39ae;

  otpm_data_216 otpm_data_216 @0x39b0;

  otpm_data_217 otpm_data_217 @0x39b2;

  otpm_data_218 otpm_data_218 @0x39b4;

  otpm_data_219 otpm_data_219 @0x39b6;

  otpm_data_220 otpm_data_220 @0x39b8;

  otpm_data_221 otpm_data_221 @0x39ba;

  otpm_data_222 otpm_data_222 @0x39bc;

  otpm_data_223 otpm_data_223 @0x39be;

  otpm_data_224 otpm_data_224 @0x39c0;

  otpm_data_225 otpm_data_225 @0x39c2;

  otpm_data_226 otpm_data_226 @0x39c4;

  otpm_data_227 otpm_data_227 @0x39c6;

  otpm_data_228 otpm_data_228 @0x39c8;

  otpm_data_229 otpm_data_229 @0x39ca;

  otpm_data_230 otpm_data_230 @0x39cc;

  otpm_data_231 otpm_data_231 @0x39ce;

  otpm_data_232 otpm_data_232 @0x39d0;

  otpm_data_233 otpm_data_233 @0x39d2;

  otpm_data_234 otpm_data_234 @0x39d4;

  otpm_data_235 otpm_data_235 @0x39d6;

  otpm_data_236 otpm_data_236 @0x39d8;

  otpm_data_237 otpm_data_237 @0x39da;

  otpm_data_238 otpm_data_238 @0x39dc;

  otpm_data_239 otpm_data_239 @0x39de;

  otpm_data_240 otpm_data_240 @0x39e0;

  otpm_data_241 otpm_data_241 @0x39e2;

  otpm_data_242 otpm_data_242 @0x39e4;

  otpm_data_243 otpm_data_243 @0x39e6;

  otpm_data_244 otpm_data_244 @0x39e8;

  otpm_data_245 otpm_data_245 @0x39ea;

  otpm_data_246 otpm_data_246 @0x39ec;

  otpm_data_247 otpm_data_247 @0x39ee;

  otpm_data_248 otpm_data_248 @0x39f0;

  otpm_data_249 otpm_data_249 @0x39f2;

  otpm_data_250 otpm_data_250 @0x39f4;

  otpm_data_251 otpm_data_251 @0x39f6;

  otpm_data_252 otpm_data_252 @0x39f8;

  otpm_data_253 otpm_data_253 @0x39fa;

  otpm_data_254 otpm_data_254 @0x39fc;

  otpm_data_255 otpm_data_255 @0x39fe;

  vddhrsidac_adj vddhrsidac_adj @0x3c10;

  vddhdcgidac_adj vddhdcgidac_adj @0x3c12;

  vddhgcidac_adj vddhgcidac_adj @0x3c14;

  vddhtxidac_adj vddhtxidac_adj @0x3c16;

  vddhrstidac_adj vddhrstidac_adj @0x3c18;

  vddhilogicidac_adj vddhilogicidac_adj @0x3c1a;

  vaaclgrdidac_adj vaaclgrdidac_adj @0x3c1c;

  vaaclgshidac_adj vaaclgshidac_adj @0x3c1e;

  vaa3v3_adj vaa3v3_adj @0x3c20;

  vsslogcidac_adj vsslogcidac_adj @0x3c22;

  vsslodcgidac_adj vsslodcgidac_adj @0x3c24;

  vsslotxidac_adj vsslotxidac_adj @0x3c26;

  vsslorstidac_adj vsslorstidac_adj @0x3c28;

  vssloselgcidac_adj vssloselgcidac_adj @0x3c2a;

  vssloseldcgidac_adj vssloseldcgidac_adj @0x3c2c;

  vssloseltxidac_adj vssloseltxidac_adj @0x3c2e;

  vssloselrstidac_adj vssloselrstidac_adj @0x3c30;

  vsshilogicidac_adj vsshilogicidac_adj @0x3c32;

  vssrowlogicidac_adj vssrowlogicidac_adj @0x3c34;

  vssrwrowdrvidac_adj vssrwrowdrvidac_adj @0x3c36;

  vddpartxidac_adj vddpartxidac_adj @0x3c38;

  vddpartxt2idac_adj vddpartxt2idac_adj @0x3c3a;

  vddpargcidac_adj vddpargcidac_adj @0x3c3c;

  vddmipiidac_adj vddmipiidac_adj @0x3c3e;

  vddihvpump_idac_adj vddihvpump_idac_adj @0x3c40;

  vddrowlogicidac_adj vddrowlogicidac_adj @0x3c44;

  vddhimid_dcgidac_adj vddhimid_dcgidac_adj @0x3c46;

  vaaclgrefidac_adj vaaclgrefidac_adj @0x3c4a;

  pmucomp_addrchang_delay pmucomp_addrchang_delay @0x3c4c;

  pmu_monitor_control pmu_monitor_control @0x3c4e;

  supplymon_init_delay supplymon_init_delay @0x3c50;

  pmumon_calib_control pmumon_calib_control @0x3c52;

  pmumon_force_ext_addr pmumon_force_ext_addr @0x3c54;

  pmu_loldo_status_1 pmu_loldo_status_1 @0x3c62;

  pmu_hvldo_status_1 pmu_hvldo_status_1 @0x3c66;

  pmu_supply_2v8_status pmu_supply_2v8_status @0x3c68;

  pmu_supply_1v8_status pmu_supply_1v8_status @0x3c6a;

  pmu_supply_1v0_status pmu_supply_1v0_status @0x3c6c;

  tempvsens1_tmg_ctrl_k0 tempvsens1_tmg_ctrl_k0 @0x3e6e;

  tempvsens1_tmg_ctrl_k1 tempvsens1_tmg_ctrl_k1 @0x3e70;

  tempvsens1_m1_hi_sm1 tempvsens1_m1_hi_sm1 @0x3e72;

  tempvsens1_m1_lo_sm1 tempvsens1_m1_lo_sm1 @0x3e74;

  tempvsens1_c1_hi_sm1 tempvsens1_c1_hi_sm1 @0x3e76;

  tempvsens1_c1_lo_sm1 tempvsens1_c1_lo_sm1 @0x3e78;

  tempvsens1_m2_hi_sm1 tempvsens1_m2_hi_sm1 @0x3e7a;

  tempvsens1_m2_lo_sm1 tempvsens1_m2_lo_sm1 @0x3e7c;

  tempvsens1_c2_hi_sm1 tempvsens1_c2_hi_sm1 @0x3e7e;

  tempvsens1_c2_lo_sm1 tempvsens1_c2_lo_sm1 @0x3e80;

  tempvsens1_m1_hi tempvsens1_m1_hi @0x3e82;

  tempvsens1_m1_lo tempvsens1_m1_lo @0x3e84;

  tempvsens1_c1_hi tempvsens1_c1_hi @0x3e86;

  tempvsens1_c1_lo tempvsens1_c1_lo @0x3e88;

  tempvsens1_m2_hi tempvsens1_m2_hi @0x3e8a;

  tempvsens1_m2_lo tempvsens1_m2_lo @0x3e8c;

  tempvsens1_c2_hi tempvsens1_c2_hi @0x3e8e;

  tempvsens1_c2_lo tempvsens1_c2_lo @0x3e90;

  tempvsens1_value_55 tempvsens1_value_55 @0x3e92;

  tempvsens1_flag_comp tempvsens1_flag_comp @0x3e94;

  tempvsens1_en_ctrl tempvsens1_en_ctrl @0x3e98;

  tempvsens1_flag_ctrl_ext tempvsens1_flag_ctrl_ext @0x3ee0;

  tempsens1_ctrl_reg_ext tempsens1_ctrl_reg_ext @0x3ee2;

  tempvsens1_value_55_1 tempvsens1_value_55_1 @0x3ee6;

  tempvsens1_value_55_sm1 tempvsens1_value_55_sm1 @0x3ee8;

  tempvsens1_value_55_sm2 tempvsens1_value_55_sm2 @0x3eea;

  asil_check_enables_05 asil_check_enables_05 @0x3f50;

  asil_pin_enables_05 asil_pin_enables_05 @0x3f52;

  asil_check_enables_02 asil_check_enables_02 @0x3f64;

  asil_startup_enables_00 asil_startup_enables_00 @0x3f66;

  asil_pin_enables_02 asil_pin_enables_02 @0x3f6c;

  asil_startup_pin_enables_00 asil_startup_pin_enables_00 @0x3f6e;

  asil_check_enables_06 asil_check_enables_06 @0x3f78;

  asil_pin_enables_06 asil_pin_enables_06 @0x3f7a;

  wait_fv_lv_time wait_fv_lv_time @0x3f80;

  asil_check_enables_07 asil_check_enables_07 @0x3f82;

  asil_pin_enables_07 asil_pin_enables_07 @0x3f84;

  otpm_core_macro_lock otpm_core_macro_lock @0x3f8a;

  tempvsens1_tmg_ctrl tempvsens1_tmg_ctrl @0x3f92;

  tempvsens1_flag_ctrl tempvsens1_flag_ctrl @0x3f96;

  tempvsens1_tmg_ctrl_ex tempvsens1_tmg_ctrl_ex @0x3fc2;

  otpm_timing0 otpm_timing0 @0x3fd0;

  otpm_timing1 otpm_timing1 @0x3fd2;

  otpm_ipsmr0_10 otpm_ipsmr0_10 @0x3fe0;

  otpm_ipsmr0_32 otpm_ipsmr0_32 @0x3fe2;

  otpm_ipsmr1_10 otpm_ipsmr1_10 @0x3fe4;

  otpm_ipsmr1_32 otpm_ipsmr1_32 @0x3fe6;

  otpm_ipsmr2_10 otpm_ipsmr2_10 @0x3fe8;

  otpm_ipsmr2_32 otpm_ipsmr2_32 @0x3fea;

  otpm_shfmr0_10 otpm_shfmr0_10 @0x3fec;

  otpm_shfmr1_10 otpm_shfmr1_10 @0x3fee;

  otpm_shfmr2_10 otpm_shfmr2_10 @0x3ff0;

  cse_ess_cci_rsvd_1 cse_ess_cci_rsvd_1 @0x4022;

  cse_service_descriptor cse_service_descriptor @0x4024;

  cse_write_tag_clr cse_write_tag_clr @0x4026;

  cse_write_msg_cnt cse_write_msg_cnt @0x4027;

  cse_write_msg_crc cse_write_msg_crc @0x4028;

  cse_read_msg_cnt cse_read_msg_cnt @0x402b;

  cse_read_msg_crc cse_read_msg_crc @0x402c;

  cse_fault_status cse_fault_status @0x402e;

  asil_status_02_dup asil_status_02_dup @0x4324;

  asil_startup_status_00_dup asil_startup_status_00_dup @0x4328;

  asil_status_05_dup asil_status_05_dup @0x432c;

  asil_status_07_dup asil_status_07_dup @0x432e;

  asil_status_06_dup asil_status_06_dup @0x4330;

  ecc_fault_injection1 ecc_fault_injection1 @0x43f2;

  otpm_ecc_fault_inj otpm_ecc_fault_inj @0x43fa;

  crc_fault_injection crc_fault_injection @0x43fc;

  cp_soft_start_ctrl cp_soft_start_ctrl @0x4440;

  pmu_vout_r1 pmu_vout_r1 @0x4600;

  pmu_cfg_r1 pmu_cfg_r1 @0x4602;

  pmu_mon_ov_r1 pmu_mon_ov_r1 @0x4604;

  pmu_mon_uv_r1 pmu_mon_uv_r1 @0x4606;

  pmu_vout_r2 pmu_vout_r2 @0x4608;

  pmu_cfg_r2 pmu_cfg_r2 @0x460a;

  pmu_mon_ov_r2 pmu_mon_ov_r2 @0x460c;

  pmu_mon_uv_r2 pmu_mon_uv_r2 @0x460e;

  pmu_wr_prot pmu_wr_prot @0x4610;

  pmu_pd_seq_r1 pmu_pd_seq_r1 @0x4612;

  pmu_pd_seq_r2 pmu_pd_seq_r2 @0x4614;

  pmu_pd_seq_r3 pmu_pd_seq_r3 @0x4616;

  pmu_pd_seq_r4 pmu_pd_seq_r4 @0x4618;

  pmu_pd_seq_r5 pmu_pd_seq_r5 @0x461a;

  pmu_pd_seq_r6 pmu_pd_seq_r6 @0x461c;

  pmu_pd_seq_r7 pmu_pd_seq_r7 @0x461e;

  pmu_pd_seq_r8 pmu_pd_seq_r8 @0x4620;

  pmu_pd_seq_r9 pmu_pd_seq_r9 @0x4622;

  pmu_pd_seq_r10 pmu_pd_seq_r10 @0x4624;

  pmu_pd_seq_r11 pmu_pd_seq_r11 @0x4626;

  pmu_pd_seq_r12 pmu_pd_seq_r12 @0x4628;

  pmu_pd_seq_r13 pmu_pd_seq_r13 @0x462a;

  pmu_pd_seq_r14 pmu_pd_seq_r14 @0x462c;

  pmu_pd_seq_r15 pmu_pd_seq_r15 @0x462e;

  pmu_pd_seq_r16 pmu_pd_seq_r16 @0x4630;

  pmu_pd_seq_en pmu_pd_seq_en @0x4632;

  pmu_ctrl pmu_ctrl @0x4634;

  osc_en_period osc_en_period @0x4636;

  ahm_osc_count ahm_osc_count @0x4638;

};
