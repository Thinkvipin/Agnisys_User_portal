/* Agnisys, Inc. ***** Copyright 2022 All Rights Reserved. *****

*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
created by          :
generated by        : drheault
IDesignSpec ver     : 7.56.0.0

**** This code is generated with the following settings ***
Reg Width                  : 32
Address Unit               : 32
C++ Types int              : hwint
Bus Type                   : APB
BigEndian                  : false
LittleEndian               : false
Dist. Decode and Readback  : false
------------------------------------------------------------ */

/*--------------------------------------------------
MODULE    :    MYBLOCK MODULE
*/
module myblock_ids#(
    
    // PARAMETERS
    
    
    
    parameter bus_width = 32,
    parameter addr_width = 9,
    parameter block_size = 'h144,
    
    parameter [addr_width-1 : 0] block_offset = {(addr_width){1'b0}},
    
    
    // REGISTER : MYMEM
    parameter mymem_count  = 8,
    parameter mymem_address_width = addr_width - 7
    )
    
    (
    
    
    // REGISTER : MYREG PORT SIGNAL
    output [31 : 0] myreg_myfield_r,
    
    // SECTION(EXTERNAL) : MYMEM SIGNALS
    input  mymem_rd_ack_in,
    input [320-1 : 0] mymem_rd_data_in,
    output mymem_rd_valid_out,
    input  mymem_wr_req_in,
    output mymem_wr_valid_out,
    
    output [320-1:0] mymem_wr_data_out,
    
    
    output  [ addr_width-1:0] address_out,
    output  [ bus_width-1:0] wr_data_out,
    
    
    //APB signals
    input pclk,     //Bus clock
    input presetn,     //Reset
    input psel,     //Select    : It indicates that the slave device is selected and a data transfer is required
    input penable,     //Enable    : This signal indicates the second and subsequent cycles of an APB transfer
    input pwrite,     //Direction : This signal indicates an APB write access when HIGH and an APB read access when LOW
    input [2 : 0] pprot,     //Protection type : This signal indicates the normal, privileged, or secure protection level of the transaction
    input [bus_width/8-1 : 0] pstrb,     //Write strobes : This signal indicates which byte lanes to update during a write transfer
    input [bus_width-1 : 0] pwdata,     //Write data
    input [addr_width-1 : 0] paddr,     //Address bus
    output pready,     //Ready     : The slave uses this signal to extend an APB transfer
    output [bus_width-1 : 0] prdata,     //Read data
    output pslverr     //pslverr : This signal indicates a transfer failure.
    );
    
    
    
    wire myreg_decode;        // Write Decode
    wire myreg_wr_valid;        // Write Valid
    wire [63 : 0] myreg_offset;        // Offset
    wire myreg_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] myreg_rd_data;        // Read Data
    reg [31 : 0] myreg_myfield_q; // FIELD : myfield
    
    
    wire   mymem_decode;
    wire [64-1 : 0] mymem_offset;
    wire   mymem_wr_valid;
    wire   mymem_wr_req_wire;
    wire   mymem_decode_wire;
    wire mymem_write_error;
    wire mymem_error_wire;
    wire   mymem_rd_valid;
    wire   mymem_rd_ack_wire;
    wire mymem_combined_write;
    wire mymem_combined_read;
    reg [288-1 : 0]mymem_buff;
    wire [320 -1 : 0] mymem_rd_data;
    wire [bus_width-1:0] mymem_rd_data1;
    wire [bus_width-1:0] mymem_rd_data2;
    wire [bus_width-1:0] mymem_rd_data3;
    wire [bus_width-1:0] mymem_rd_data4;
    wire [bus_width-1:0] mymem_rd_data5;
    wire [bus_width-1:0] mymem_rd_data6;
    wire [bus_width-1:0] mymem_rd_data7;
    wire [bus_width-1:0] mymem_rd_data8;
    wire [bus_width-1:0] mymem_rd_data9;
    wire [bus_width-1:0] mymem_rd_data10;
    wire mymem_buff1_decode;
    wire mymem_buff2_decode;
    wire mymem_buff3_decode;
    wire mymem_buff4_decode;
    wire mymem_buff5_decode;
    wire mymem_buff6_decode;
    wire mymem_buff7_decode;
    wire mymem_buff8_decode;
    wire mymem_buff9_decode;
    wire mymem_buff10_decode;
    wire [bus_width-1 : 0] int_rd_data;
    wire [bus_width-1 : 0] wide_access_rd_data;
    wire external_rd_valid;
    reg rd_wait_state;
    wire external_rd_ack;
    wire external_access;
    wire external_wr_req;
    
    
    
    wire [2 : 0] pprot_i;
    
    
    wire [bus_width-1 : 0] reg_enb;
    wire clk;
    wire reset_l;
    wire rd_stb;
    wire rd_wait;
    wire wr_stb;
    wire [addr_width-1 : 0] address;
    wire  [bus_width/8 -1 : 0] byte_enb;
    wire [bus_width-1 : 0] wr_data;
    wire request;
    wire [bus_width-1 : 0] rd_data;
    wire rd_data_vld;
    wire error;
    
    apb_widget # (.addr_width(addr_width), .bus_width(bus_width) )apb (
            .pclk(pclk),
            .presetn(presetn),
            .pwdata(pwdata),
            .paddr(paddr),
            .prdata(prdata),
            .pready(pready),
            .pwrite(pwrite),
            .pprot(pprot),
            .pprot_i(pprot_i),
            .pstrb(pstrb),
            .psel(psel),
            .penable(penable),
            .pslverr(pslverr),
            
            .clk(clk),
            .reset_l(reset_l),
            .request(request),
            .wr_stb(wr_stb),
            .rd_stb(rd_stb),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .rd_wait(rd_wait),
            .address(address),
            .rd_data_vld(rd_data_vld),
            .byte_enb(byte_enb),
            .error(error));
    // end widget
    
    assign wr_data_out = wr_data;
    assign address_out = (mymem_decode)? {address[(addr_width-1) : 5],5'b0} :address;
    assign mymem_wr_data_out = {wr_data,mymem_buff};
    
    assign reg_enb = {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MYREG
    // ADDRESS       :  block_offset +'h0		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : myfield  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign myreg_wr_valid = myreg_decode && wr_stb  ;
    assign myreg_offset = block_offset +'h0;
    assign myreg_decode = (address[addr_width-1 : 0] == myreg_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign myreg_rd_valid = myreg_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : MYFIELD
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    : My Reg
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            myreg_myfield_q <= 32'd0;
        end
    else
        begin
        if (myreg_wr_valid)	 //MYFIELD : SW Write
            begin
                myreg_myfield_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (myreg_myfield_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign myreg_myfield_r = myreg_myfield_q; // Field : MYFIELD
    assign myreg_rd_data  = myreg_rd_valid ? {myreg_myfield_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // SECTION(EXTERNAL) : MYMEM
    // ADDRESS       :   (block_offset/'h200) + 'h0
    //----------------------------------------------------------------------------------------------------
    assign mymem_decode = ((address[(addr_width - 1): 0] >= block_offset + 'h4) && (address[(addr_width - 1): 0] <= block_offset + 'h143)) ? 1'b1 : 1'b0;
    assign mymem_offset =  (block_offset/'h200) + 'h0;
    assign mymem_write_error = mymem_decode && wr_stb ;
    assign mymem_error_wire = mymem_write_error;
    assign mymem_wr_valid = mymem_decode && wr_stb;
    assign mymem_rd_valid = mymem_decode && rd_stb;
    assign mymem_wr_valid_out = (mymem_combined_write) ? mymem_wr_valid:1'b0;
    assign mymem_rd_valid_out = (mymem_combined_read) ? (mymem_rd_valid && rd_wait_state):1'b0;
    assign mymem_rd_data = mymem_rd_ack_in ? mymem_rd_data_in : 320'd0;
    assign mymem_decode_wire = mymem_decode;
    assign mymem_wr_req_wire = mymem_wr_req_in;
    assign mymem_rd_ack_wire = mymem_rd_ack_in;
    
    
    
    assign int_rd_data = (~external_access) ? (myreg_rd_data ) : {bus_width{1'b0}};
    
    assign external_rd_valid = mymem_rd_valid_out; // END external_rd_valid
    
    assign external_rd_ack = mymem_rd_ack_wire; // END external_rd_ack
    
    assign external_wr_req = mymem_wr_req_wire; // END external_wr_req
    
    assign external_access = (mymem_decode_wire) & (rd_stb | wr_stb); // END external_access
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            rd_wait_state <= 1'b1;
        end
    else
        begin
            case(rd_wait_state)
                1'b1:
                begin
                if (external_rd_valid == 1'b1 && external_rd_ack == 1'b0 )
                    begin
                        rd_wait_state <= 1'b0;
                    end
                end
                1'b0:
                begin
                if (external_rd_ack == 1'b1)
                    begin
                        rd_wait_state <= 1'b1;
                    end
                end
            endcase
        end
    end //end always
    
    //------------------ mymem --------------------
    assign mymem_buff1_decode = (mymem_decode && (address[5 : 0]  == 6'h0)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[31:0]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff1_decode)
            begin
                mymem_buff[31:0] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[31:0] <= mymem_rd_data[31:0];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data1 = (mymem_rd_ack_in && mymem_buff1_decode) ? mymem_buff[31:0] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff2_decode = (mymem_decode && (address[5 : 0]  == 6'hA)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[63:32]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff2_decode)
            begin
                mymem_buff[63:32] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[63:32] <= mymem_rd_data[63:32];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data2 = (mymem_rd_ack_in && mymem_buff2_decode) ? mymem_buff[63:32] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff3_decode = (mymem_decode && (address[5 : 0]  == 6'h14)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[95:64]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff3_decode)
            begin
                mymem_buff[95:64] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[95:64] <= mymem_rd_data[95:64];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data3 = (mymem_rd_ack_in && mymem_buff3_decode) ? mymem_buff[95:64] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff4_decode = (mymem_decode && (address[5 : 0]  == 6'h1E)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[127:96]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff4_decode)
            begin
                mymem_buff[127:96] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[127:96] <= mymem_rd_data[127:96];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data4 = (mymem_rd_ack_in && mymem_buff4_decode) ? mymem_buff[127:96] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff5_decode = (mymem_decode && (address[5 : 0]  == 6'h28)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[159:128]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff5_decode)
            begin
                mymem_buff[159:128] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[159:128] <= mymem_rd_data[159:128];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data5 = (mymem_rd_ack_in && mymem_buff5_decode) ? mymem_buff[159:128] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff6_decode = (mymem_decode && (address[5 : 0]  == 6'h32)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[191:160]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff6_decode)
            begin
                mymem_buff[191:160] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[191:160] <= mymem_rd_data[191:160];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data6 = (mymem_rd_ack_in && mymem_buff6_decode) ? mymem_buff[191:160] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff7_decode = (mymem_decode && (address[5 : 0]  == 6'h3C)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[223:192]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff7_decode)
            begin
                mymem_buff[223:192] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[223:192] <= mymem_rd_data[223:192];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data7 = (mymem_rd_ack_in && mymem_buff7_decode) ? mymem_buff[223:192] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff8_decode = (mymem_decode && (address[5 : 0]  == 6'h46)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[255:224]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff8_decode)
            begin
                mymem_buff[255:224] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[255:224] <= mymem_rd_data[255:224];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data8 = (mymem_rd_ack_in && mymem_buff8_decode) ? mymem_buff[255:224] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff9_decode = (mymem_decode && (address[5 : 0]  == 6'h50)) ? 1'b1 : 1'b0 ;
    
    always @(posedge clk)  begin
    if(!reset_l)
        begin
            mymem_buff[287:256]<=32'b0;
        end
    else
        begin
        if(mymem_wr_valid && mymem_buff9_decode)
            begin
                mymem_buff[287:256] <= wr_data;
            end
        else
            begin
            if(mymem_rd_ack_in)
                begin
                    mymem_buff[287:256] <= mymem_rd_data[287:256];
                end
            end
        end
    end  //end always
    
    assign mymem_rd_data9 = (mymem_rd_ack_in && mymem_buff9_decode) ? mymem_buff[287:256] : 32'b0;
    
    //------------------ mymem --------------------
    assign mymem_buff10_decode = (mymem_decode && (address[5 : 0]  == 6'h24)) ? 1'b1 : 1'b0 ;
    
    assign mymem_rd_data10 = (mymem_rd_ack_in && mymem_buff10_decode) ? mymem_rd_data[319:288] : 32'b0;
    assign mymem_combined_write = (mymem_wr_valid && mymem_buff10_decode) ? 1'b1 : 1'b0;
    assign mymem_combined_read = (mymem_rd_valid  && mymem_buff10_decode) ? 1'b1 : 1'b0;
    
    
    assign request = external_wr_req;
    assign rd_data_vld = external_rd_ack |(~external_access & rd_stb & rd_wait_state);
    assign rd_wait = rd_wait_state;
    
    
    assign rd_data = int_rd_data | wide_access_rd_data;
    assign wide_access_rd_data = mymem_rd_data1 | mymem_rd_data2 | mymem_rd_data3 | mymem_rd_data4 | mymem_rd_data5 | mymem_rd_data6 | mymem_rd_data7 | mymem_rd_data8 | mymem_rd_data9 | mymem_rd_data10;
    
    assign error = mymem_error_wire;
    
endmodule

