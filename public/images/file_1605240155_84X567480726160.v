//
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***

// created by        :


// IDesignSpec rev   : idsbatch v 6.44.8.0

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : AMBA3AHBLITE
// BigEndian                  : true
// LittleEndian               : true
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

//------------------------------------------------
//  BLOCK : ROT_KAM_REGS MODULE
//

module ROT_KAM_regs_ids #(
    
    //  PARAMETERS
    parameter bus_width   = 32,
    parameter addr_width = 11,
    
    parameter block_size   = 'h650,
    
    parameter block_offset  = {(addr_width){1'b0}},
    
    parameter  [0:0]
    KAM_OTP_HW_CONTROL_LCM_MODE_e_LCM_DEVELOPMENT  =  1'h0,    //  LCM MODE is Development Mode
    KAM_OTP_HW_CONTROL_LCM_MODE_e_LCM_PRODUCTION  =  1'h1    //  LCM MODE is Prodcution Mode
    ,
    
    
    parameter  [1:0]
    KAM_PMR_EXTEND_TARGET_PMR_SIZE_e_PMR_256  =  2'h0,    //  PMR is 256-bits (8 PMR Entries)
    KAM_PMR_EXTEND_TARGET_PMR_SIZE_e_PMR_384  =  2'h1,    //  PMR is 384-bits (12 PMR Entries)
    KAM_PMR_EXTEND_TARGET_PMR_SIZE_e_PMR_512  =  2'h2    //  PMR is 512-bits (16 PMR Entries)
    ,
    
    
    
    parameter KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_count   = 2,
    
    parameter KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_address_width= addr_width  - 3,
    
    parameter KAM_OTP_OTPC_KAM_OTP_OTPC_READ_count    = 2,
    
    parameter KAM_OTP_OTPC_KAM_OTP_OTPC_READ_address_width= addr_width  - 3,
    // SECTION : KAM_OTP_OTPC
    parameter KAM_OTP_OTPC_address_width = addr_width,
    
    // SECTION : KAM_OTP_EFC
    parameter KAM_OTP_EFC_address_width = addr_width,
    
    parameter KAM_OTP_LANE_count                      = 8,
    parameter KAM_OTP_LANE_address_width              = addr_width,
    parameter KAM_KV_count                            = 2,
    parameter KAM_KV_address_width                    = addr_width,
    
    parameter KAM_PMR_LIST_KAM_PMR_ENTRY_count        = 16,
    
    parameter KAM_PMR_LIST_KAM_PMR_ENTRY_address_width= addr_width  - 6,
    parameter KAM_PMR_LIST_count                      = 8,
    parameter KAM_PMR_LIST_address_width              = addr_width,
    
    parameter KAM_PMR_STATUS_count                    = 8,
    
    parameter KAM_PMR_STATUS_address_width            = addr_width,
    
    parameter ROT_KAM_regs_address_width = addr_width
    )
    
    (
    
    //-----------------------------------------------------
    // REGISTER : KAM_OTP_HW_CONTROL_VALID SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_VALID_VALID_r,    // FIELD : VALID
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_OTP_HW_CONTROL SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_HWC_VALID_in,    // FIELD : HWC_VALID
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_HWC_VALID_r,    // FIELD : HWC_VALID
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_in,    // FIELD : AUTOLOAD_VALID
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_in_enb,    // FIELD : AUTOLOAD_VALID
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_r,    // FIELD : AUTOLOAD_VALID
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_in,    // FIELD : AUTOLOAD_ERR
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_in_enb,    // FIELD : AUTOLOAD_ERR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_r,    // FIELD : AUTOLOAD_ERR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_LCM_MODE_r,    // FIELD : LCM_MODE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_KAM_KV_EN_r,    // FIELD : KAM_KV_EN
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_KAM_OAF_EN_r,    // FIELD : KAM_OAF_EN
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_r,    // FIELD : KAM_HWC_LOCK_ENABLE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_RESERVED_1_r,    // FIELD : RESERVED_1
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_ROT_EXCLUSIVE_ACCESS_r,    // FIELD : ROT_EXCLUSIVE_ACCESS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_RESERVED_0_r,    // FIELD : RESERVED_0
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_in,    // FIELD : SOFT_RESET_DISABLE
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_in_enb,    // FIELD : SOFT_RESET_DISABLE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_r,    // FIELD : SOFT_RESET_DISABLE
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_in,    // FIELD : SEC_LOAD_FAIL_REPORT
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_in_enb,    // FIELD : SEC_LOAD_FAIL_REPORT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_r,    // FIELD : SEC_LOAD_FAIL_REPORT
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_in,    // FIELD : ROT_ROM_BOOT_SRC
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_in_enb,    // FIELD : ROT_ROM_BOOT_SRC
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_r,    // FIELD : ROT_ROM_BOOT_SRC
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_UART_DISABLE_in,    // FIELD : UART_DISABLE
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_OTP_HW_CONTROL_UART_DISABLE_in_enb,    // FIELD : UART_DISABLE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_UART_DISABLE_r,    // FIELD : UART_DISABLE
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_SOC_DEBUG_in,    // FIELD : SOC_DEBUG
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_OTP_HW_CONTROL_SOC_DEBUG_in_enb,    // FIELD : SOC_DEBUG
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_SOC_DEBUG_r,    // FIELD : SOC_DEBUG
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_OTP_HW_CONTROL_ROT_DEBUG_in,    // FIELD : ROT_DEBUG
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_OTP_HW_CONTROL_ROT_DEBUG_in_enb,    // FIELD : ROT_DEBUG
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_OTP_HW_CONTROL_ROT_DEBUG_r,    // FIELD : ROT_DEBUG
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_STATUS SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [KAM_PMR_STATUS_count*16-1 : 0] KAM_PMR_STATUS_PMR_VALID_in,    // FIELD : PMR_VALID
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_EXTEND_MEASUREMENT_SRC SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [31 : 0] KAM_PMR_EXTEND_MEASUREMENT_SRC_ADDR_r,    // FIELD : ADDR
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_EXTEND_TARGET SIGNALS
    
    output   KAM_PMR_EXTEND_TARGET_enb,
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [1 : 0] KAM_PMR_EXTEND_TARGET_PMR_SIZE_r,    // FIELD : PMR_SIZE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [2 : 0] KAM_PMR_EXTEND_TARGET_PMR_INDEX_r,    // FIELD : PMR_INDEX
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_SHA_CONFIG SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [6 : 0] KAM_PMR_SHA_CONFIG_MODE_in,    // FIELD : MODE
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_CONFIG_MODE_in_enb,    // FIELD : MODE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [6 : 0] KAM_PMR_SHA_CONFIG_MODE_r,    // FIELD : MODE
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [2 : 0] KAM_PMR_SHA_CONFIG_KEY_SIZE_in,    // FIELD : KEY_SIZE
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_CONFIG_KEY_SIZE_in_enb,    // FIELD : KEY_SIZE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [2 : 0] KAM_PMR_SHA_CONFIG_KEY_SIZE_r,    // FIELD : KEY_SIZE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [7 : 0] KAM_PMR_SHA_CONFIG_IN_LEVEL_r,    // FIELD : IN_LEVEL
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_PMR_SHA_CONFIG_DMA_IN_in,    // FIELD : DMA_IN
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_CONFIG_DMA_IN_in_enb,    // FIELD : DMA_IN
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_PMR_SHA_CONFIG_DMA_IN_r,    // FIELD : DMA_IN
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_in,    // FIELD : BYTE_SWAP_IN
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_in_enb,    // FIELD : BYTE_SWAP_IN
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_r,    // FIELD : BYTE_SWAP_IN
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_in,    // FIELD : BYTE_SWAP_OUT
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_in_enb,    // FIELD : BYTE_SWAP_OUT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_r,    // FIELD : BYTE_SWAP_OUT
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_SHA_INTR SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_PMR_SHA_INTR_VERIFY_DONE_in,    // FIELD : VERIFY_DONE
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_INTR_VERIFY_DONE_in_enb,    // FIELD : VERIFY_DONE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_PMR_SHA_INTR_VERIFY_DONE_r,    // FIELD : VERIFY_DONE
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_PMR_SHA_INTR_GEN_DONE_in,    // FIELD : GEN_DONE
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_INTR_GEN_DONE_in_enb,    // FIELD : GEN_DONE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_PMR_SHA_INTR_GEN_DONE_r,    // FIELD : GEN_DONE
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_PMR_SHA_INTR_IN_FIFO_AE_in,    // FIELD : IN_FIFO_AE
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_INTR_IN_FIFO_AE_in_enb,    // FIELD : IN_FIFO_AE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_PMR_SHA_INTR_IN_FIFO_AE_r,    // FIELD : IN_FIFO_AE
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_PMR_SHA_INTR_ERR_in,    // FIELD : ERR
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_INTR_ERR_in_enb,    // FIELD : ERR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_PMR_SHA_INTR_ERR_r,    // FIELD : ERR
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_PMR_SHA_INTR_ALERT_in,    // FIELD : ALERT
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_PMR_SHA_INTR_ALERT_in_enb,    // FIELD : ALERT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_PMR_SHA_INTR_ALERT_r,    // FIELD : ALERT
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_ECC_CTRL_PMR SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_ECC_CTRL_PMR_ERR_SB_INSERT_r,    // FIELD : ERR_SB_INSERT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_ECC_CTRL_PMR_ERR_DB_INSERT_r,    // FIELD : ERR_DB_INSERT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_ECC_CTRL_PMR_ERR_CLEAR_r,    // FIELD : ERR_CLEAR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_ECC_CTRL_PMR_ENABLE_r,    // FIELD : ENABLE
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_ECC_STATUS_PMR SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_ECC_STATUS_PMR_ERR_DB_in,    // FIELD : ERR_DB
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_ECC_STATUS_PMR_ERR_SB_in,    // FIELD : ERR_SB
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [3 : 0] KAM_ECC_STATUS_PMR_ERR_COUNT_in,    // FIELD : ERR_COUNT
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [6 : 0] KAM_ECC_STATUS_PMR_ECC_in,    // FIELD : ECC
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [14 : 0] KAM_ECC_STATUS_PMR_ADDR_in,    // FIELD : ADDR
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_ECC_LOG_PMR SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [31 : 0] KAM_ECC_LOG_PMR_DATA_in,    // FIELD : DATA
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_ERR_STATUS SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_ERR_STATUS_SHA_UNAUTHORIZED_in,    // FIELD : SHA_UNAUTHORIZED
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_ERR_STATUS_SHA_UNAUTHORIZED_in_enb,    // FIELD : SHA_UNAUTHORIZED
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_ERR_STATUS_SHA_UNAUTHORIZED_r,    // FIELD : SHA_UNAUTHORIZED
    
    input  KAM_ERR_STATUS_SHA_UNAUTHORIZED_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_ERR_STATUS_PMR_EXTEND_ABORT_in,    // FIELD : PMR_EXTEND_ABORT
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_ERR_STATUS_PMR_EXTEND_ABORT_in_enb,    // FIELD : PMR_EXTEND_ABORT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_ERR_STATUS_PMR_EXTEND_ABORT_r,    // FIELD : PMR_EXTEND_ABORT
    
    input  KAM_ERR_STATUS_PMR_EXTEND_ABORT_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_ERR_STATUS_ECC_SB_PMR_in,    // FIELD : ECC_SB_PMR
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_ERR_STATUS_ECC_SB_PMR_in_enb,    // FIELD : ECC_SB_PMR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_ERR_STATUS_ECC_SB_PMR_r,    // FIELD : ECC_SB_PMR
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_ERR_STATUS_ECC_DB_PMR_in,    // FIELD : ECC_DB_PMR
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_ERR_STATUS_ECC_DB_PMR_in_enb,    // FIELD : ECC_DB_PMR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_ERR_STATUS_ECC_DB_PMR_r,    // FIELD : ECC_DB_PMR
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_INTR_STATE SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_INTR_STATE_OTPC_INT_in,    // FIELD : OTPC_INT
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_INTR_STATE_OTPC_INT_in_enb,    // FIELD : OTPC_INT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_STATE_OTPC_INT_r,    // FIELD : OTPC_INT
    
    input  KAM_INTR_STATE_OTPC_INT_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_INTR_STATE_OTP_WRITE_DENY_in,    // FIELD : OTP_WRITE_DENY
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_INTR_STATE_OTP_WRITE_DENY_in_enb,    // FIELD : OTP_WRITE_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_STATE_OTP_WRITE_DENY_r,    // FIELD : OTP_WRITE_DENY
    
    input  KAM_INTR_STATE_OTP_WRITE_DENY_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_INTR_STATE_OTP_READ_DENY_in,    // FIELD : OTP_READ_DENY
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_INTR_STATE_OTP_READ_DENY_in_enb,    // FIELD : OTP_READ_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_STATE_OTP_READ_DENY_r,    // FIELD : OTP_READ_DENY
    
    input  KAM_INTR_STATE_OTP_READ_DENY_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_INTR_STATE_KV_WRITE_DENY_in,    // FIELD : KV_WRITE_DENY
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_INTR_STATE_KV_WRITE_DENY_in_enb,    // FIELD : KV_WRITE_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_STATE_KV_WRITE_DENY_r,    // FIELD : KV_WRITE_DENY
    
    input  KAM_INTR_STATE_KV_WRITE_DENY_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_INTR_STATE_KV_READ_DENY_in,    // FIELD : KV_READ_DENY
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_INTR_STATE_KV_READ_DENY_in_enb,    // FIELD : KV_READ_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_STATE_KV_READ_DENY_r,    // FIELD : KV_READ_DENY
    
    input  KAM_INTR_STATE_KV_READ_DENY_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_INTR_STATE_PMR_EXTEND_COMPLETE_in,    // FIELD : PMR_EXTEND_COMPLETE
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_INTR_STATE_PMR_EXTEND_COMPLETE_in_enb,    // FIELD : PMR_EXTEND_COMPLETE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_STATE_PMR_EXTEND_COMPLETE_r,    // FIELD : PMR_EXTEND_COMPLETE
    
    input  KAM_INTR_STATE_PMR_EXTEND_COMPLETE_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_INTR_STATE_ERR_in,    // FIELD : ERR
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_INTR_STATE_ERR_in_enb,    // FIELD : ERR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_STATE_ERR_r,    // FIELD : ERR
    
    input  KAM_INTR_STATE_ERR_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input   KAM_INTR_STATE_ALERT_in,    // FIELD : ALERT
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   KAM_INTR_STATE_ALERT_in_enb,    // FIELD : ALERT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_STATE_ALERT_r,    // FIELD : ALERT
    
    input  KAM_INTR_STATE_ALERT_hw_set ,
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_INTR_ENABLE SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_ENABLE_OTPC_INT_r,    // FIELD : OTPC_INT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_ENABLE_OTP_WRITE_DENY_r,    // FIELD : OTP_WRITE_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_ENABLE_OTP_READ_DENY_r,    // FIELD : OTP_READ_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_ENABLE_KV_WRITE_DENY_r,    // FIELD : KV_WRITE_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_ENABLE_KV_READ_DENY_r,    // FIELD : KV_READ_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_ENABLE_PMR_EXTEND_COMPLETE_r,    // FIELD : PMR_EXTEND_COMPLETE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_ENABLE_ERR_r,    // FIELD : ERR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_ENABLE_ALERT_r,    // FIELD : ALERT
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_INTR_TEST SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_TEST_OTPC_INT_r,    // FIELD : OTPC_INT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_TEST_OTP_WRITE_DENY_r,    // FIELD : OTP_WRITE_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_TEST_OTP_READ_DENY_r,    // FIELD : OTP_READ_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_TEST_KV_WRITE_DENY_r,    // FIELD : KV_WRITE_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_TEST_KV_READ_DENY_r,    // FIELD : KV_READ_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_TEST_PMR_EXTEND_COMPLETE_r,    // FIELD : PMR_EXTEND_COMPLETE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_TEST_ERR_r,    // FIELD : ERR
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  KAM_INTR_TEST_ALERT_r,    // FIELD : ALERT
    
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_SCRATCH SIGNALS
    
    
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_data_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_req_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_data_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_req_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_data_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_req_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_data_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_data_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_req_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_data_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_req_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_valid_out,
    input   KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_data_in,
    output  KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_valid_out,
    
    input   KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_data_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_req_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_data_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_req_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_data_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_req_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_data_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_req_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_data_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_req_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_data_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_req_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_data_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_req_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_valid_out,
    input   KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_ack_in,
    input   [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_data_in,
    output  KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_valid_out,
    
    
    //-----------------------------------------------------
    // REGISTER : CONFIG SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_CONFIG_LANE_ENABLE_r,    // FIELD : LANE_ENABLE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_OTP_LANE_count*6-1 : 0] KAM_OTP_LANE_CONFIG_LANE_COUNT_r,    // FIELD : LANE_COUNT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_OTP_LANE_count*10-1 : 0] KAM_OTP_LANE_CONFIG_LANE_START_r,    // FIELD : LANE_START
    
    
    
    //-----------------------------------------------------
    // REGISTER : ACCESS SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_ACCESS_RE_r,    // FIELD : RE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_ACCESS_WE_r,    // FIELD : WE
    
    
    
    //-----------------------------------------------------
    // REGISTER : STATUS SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_STATUS_WRITE_DENY_in,    // FIELD : WRITE_DENY
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input  [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_STATUS_WRITE_DENY_in_enb,    // FIELD : WRITE_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_STATUS_WRITE_DENY_r,    // FIELD : WRITE_DENY
    
    input [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_STATUS_WRITE_DENY_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_STATUS_READ_DENY_in,    // FIELD : READ_DENY
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input  [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_STATUS_READ_DENY_in_enb,    // FIELD : READ_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_STATUS_READ_DENY_r,    // FIELD : READ_DENY
    
    input [KAM_OTP_LANE_count-1 : 0] KAM_OTP_LANE_STATUS_READ_DENY_hw_set ,
    
    
    
    //-----------------------------------------------------
    // REGISTER : RANGE SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_KV_count-1 : 0] KAM_KV_RANGE_KV_ENABLE_r,    // FIELD : KV_ENABLE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_KV_count*8-1 : 0] KAM_KV_RANGE_KV_COUNT_r,    // FIELD : KV_COUNT
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_KV_count*8-1 : 0] KAM_KV_RANGE_KV_START_r,    // FIELD : KV_START
    
    
    
    //-----------------------------------------------------
    // REGISTER : ACCESS SIGNALS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_KV_count-1 : 0] KAM_KV_ACCESS_RE_r,    // FIELD : RE
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_KV_count-1 : 0] KAM_KV_ACCESS_WE_r,    // FIELD : WE
    
    
    
    //-----------------------------------------------------
    // REGISTER : STATUS SIGNALS
    
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [KAM_KV_count-1 : 0] KAM_KV_STATUS_WRITE_DENY_in,    // FIELD : WRITE_DENY
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input  [KAM_KV_count-1 : 0] KAM_KV_STATUS_WRITE_DENY_in_enb,    // FIELD : WRITE_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_KV_count-1 : 0] KAM_KV_STATUS_WRITE_DENY_r,    // FIELD : WRITE_DENY
    
    input [KAM_KV_count-1 : 0] KAM_KV_STATUS_WRITE_DENY_hw_set ,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    
    input  [KAM_KV_count-1 : 0] KAM_KV_STATUS_READ_DENY_in,    // FIELD : READ_DENY
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input  [KAM_KV_count-1 : 0] KAM_KV_STATUS_READ_DENY_in_enb,    // FIELD : READ_DENY
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [KAM_KV_count-1 : 0] KAM_KV_STATUS_READ_DENY_r,    // FIELD : READ_DENY
    
    input [KAM_KV_count-1 : 0] KAM_KV_STATUS_READ_DENY_hw_set ,
    
    
    input  [KAM_PMR_LIST_count-1 : 0 ] KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in,
    input   [KAM_PMR_LIST_count*bus_width-1 : 0] KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data_in,
    output [KAM_PMR_LIST_count-1 : 0 ] KAM_PMR_LIST_KAM_PMR_ENTRY_rd_valid_out,
    input  [KAM_PMR_LIST_count-1 : 0 ] KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in,
    output [KAM_PMR_LIST_count-1 : 0 ] KAM_PMR_LIST_KAM_PMR_ENTRY_wr_valid_out,
    
    
    
    //Signals  : SIGNALS
    
    // Desc: SW_RESET
    //     sw reset signal
    
    input SW_Reset,
    
    
    output [addr_width-1:0] address_out,
    output [bus_width-1:0] wr_data_out,
    
    //AMBA3AHBLITE signals
    input hclk,     // Bus clock
    input hresetn,     // Bus reset
    input [addr_width-1 : 0] haddr,     // Address bus
    input [2 : 0] hburst,     // Burst type : Transfer is a single transfer or forms part of a burst
    input [3 : 0] hprot,     // Protection control signals
    input [2 : 0] hsize,     // Transfer Size : byte, halfword, word, doubleword, 4-word line, 8-word line
    input [1 : 0] htrans,     // Transfer type  : NONSEQUENTIAL, SEQUENTIAL, IDLE or BUSY
    input [bus_width-1 : 0] hwdata,     // Write data bus : Transfer data from the master to the bus slaves during write operations
    input hwrite,     // Transfer direction : HIGH indicates a write transfer and when LOW a read transfer
    input hsel,     // Slave select signal : This signal indicates that the current transfer is intended for the selected slave
    input hready,     // Transfer done  : HIGH indicates that a transfer has finished and when LOW transfer has extended
    output [bus_width-1 : 0] hrdata,     // Read data bus  : Transfer data from bus slaves to the bus master during read operations
    output hreadyout,     // Transfer done  : HIGH indicates that a transfer has finished on the bus and when LOW transfer has extended
    output hresp     // Transfer response  : HIGH indicates that the transfer status is ERROR and when LOW that the transfer status is OKAY
    
    );
    //-----------------------------------------------------
    // REGISTER : KAM_OTP_HW_CONTROL_VALID SIGNALS
    
    
    wire    KAM_OTP_HW_CONTROL_VALID_decode;         // DECODE
    wire    KAM_OTP_HW_CONTROL_VALID_wr_valid;       // WRITE VALID
    wire    KAM_OTP_HW_CONTROL_VALID_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_OTP_HW_CONTROL_VALID_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_OTP_HW_CONTROL_VALID_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_OTP_HW_CONTROL_VALID_VALID_q ;      // FIELD : VALID
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_OTP_HW_CONTROL SIGNALS
    
    
    wire    KAM_OTP_HW_CONTROL_decode;         // DECODE
    wire    KAM_OTP_HW_CONTROL_wr_valid;       // WRITE VALID
    wire    KAM_OTP_HW_CONTROL_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_OTP_HW_CONTROL_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_OTP_HW_CONTROL_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    wire KAM_OTP_HW_CONTROL_HWC_VALID_q            ;      // FIELD : HWC_VALID
    reg KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_q       ;      // FIELD : AUTOLOAD_VALID
    reg KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_q         ;      // FIELD : AUTOLOAD_ERR
    reg KAM_OTP_HW_CONTROL_LCM_MODE_q             ;      // FIELD : LCM_MODE
    reg KAM_OTP_HW_CONTROL_KAM_KV_EN_q            ;      // FIELD : KAM_KV_EN
    reg KAM_OTP_HW_CONTROL_KAM_OAF_EN_q           ;      // FIELD : KAM_OAF_EN
    reg KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_q  ;      // FIELD : KAM_HWC_LOCK_ENABLE
    reg KAM_OTP_HW_CONTROL_RESERVED_1_q           ;      // FIELD : RESERVED_1
    reg KAM_OTP_HW_CONTROL_ROT_EXCLUSIVE_ACCESS_q ;      // FIELD : ROT_EXCLUSIVE_ACCESS
    reg KAM_OTP_HW_CONTROL_RESERVED_0_q           ;      // FIELD : RESERVED_0
    reg KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_q   ;      // FIELD : SOFT_RESET_DISABLE
    reg KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_q ;      // FIELD : SEC_LOAD_FAIL_REPORT
    reg KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_q     ;      // FIELD : ROT_ROM_BOOT_SRC
    reg KAM_OTP_HW_CONTROL_UART_DISABLE_q         ;      // FIELD : UART_DISABLE
    reg KAM_OTP_HW_CONTROL_SOC_DEBUG_q            ;      // FIELD : SOC_DEBUG
    reg KAM_OTP_HW_CONTROL_ROT_DEBUG_q            ;      // FIELD : ROT_DEBUG
    
    
    
    
    
    
    
    
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_STATUS SIGNALS
    
    
    wire    KAM_PMR_STATUS_decode[KAM_PMR_STATUS_count-1 : 0];         // DECODE
    wire    [KAM_PMR_STATUS_count-1 : 0]KAM_PMR_STATUS_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_PMR_STATUS_rd_data[KAM_PMR_STATUS_count-1 : 0];          // READ DATA
    wire    [64-1 : 0] KAM_PMR_STATUS_offset[KAM_PMR_STATUS_count-1 : 0];  // OFFSET
    wire   [bus_width-1 : 0] KAM_PMR_STATUS_rd_data_wire;
    
    // BUFFER SIGNAL FOR EACH FIELD
    wire [15 : 0] KAM_PMR_STATUS_PMR_VALID_q[KAM_PMR_STATUS_count-1 : 0] ;      // FIELD : PMR_VALID
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_EXTEND_MEASUREMENT_SRC SIGNALS
    
    
    wire    KAM_PMR_EXTEND_MEASUREMENT_SRC_decode;         // DECODE
    wire    KAM_PMR_EXTEND_MEASUREMENT_SRC_wr_valid;       // WRITE VALID
    wire    KAM_PMR_EXTEND_MEASUREMENT_SRC_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_PMR_EXTEND_MEASUREMENT_SRC_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_PMR_EXTEND_MEASUREMENT_SRC_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] KAM_PMR_EXTEND_MEASUREMENT_SRC_ADDR_q ;      // FIELD : ADDR
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_EXTEND_TARGET SIGNALS
    
    
    wire    KAM_PMR_EXTEND_TARGET_decode;         // DECODE
    wire    KAM_PMR_EXTEND_TARGET_wr_valid;       // WRITE VALID
    wire    KAM_PMR_EXTEND_TARGET_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_PMR_EXTEND_TARGET_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_PMR_EXTEND_TARGET_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [1 : 0] KAM_PMR_EXTEND_TARGET_PMR_SIZE_q  ;      // FIELD : PMR_SIZE
    reg  [2 : 0] KAM_PMR_EXTEND_TARGET_PMR_INDEX_q ;      // FIELD : PMR_INDEX
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_SHA_CONFIG SIGNALS
    
    
    wire    KAM_PMR_SHA_CONFIG_decode;         // DECODE
    wire    KAM_PMR_SHA_CONFIG_wr_valid;       // WRITE VALID
    wire    KAM_PMR_SHA_CONFIG_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_PMR_SHA_CONFIG_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_PMR_SHA_CONFIG_offset;  // OFFSET
    // Write/Read Protection signals
    wire KAM_PMR_SHA_CONFIG_wprot ;
    wire KAM_PMR_SHA_CONFIG_rprot ;
    
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [6 : 0] KAM_PMR_SHA_CONFIG_MODE_q          ;      // FIELD : MODE
    reg  [2 : 0] KAM_PMR_SHA_CONFIG_KEY_SIZE_q      ;      // FIELD : KEY_SIZE
    reg  [7 : 0] KAM_PMR_SHA_CONFIG_IN_LEVEL_q      ;      // FIELD : IN_LEVEL
    reg          KAM_PMR_SHA_CONFIG_DMA_IN_q        ;      // FIELD : DMA_IN
    reg          KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_q  ;      // FIELD : BYTE_SWAP_IN
    reg          KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_q ;      // FIELD : BYTE_SWAP_OUT
    
    
    
    
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_PMR_SHA_INTR SIGNALS
    
    
    wire    KAM_PMR_SHA_INTR_decode;         // DECODE
    wire    KAM_PMR_SHA_INTR_wr_valid;       // WRITE VALID
    wire    KAM_PMR_SHA_INTR_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_PMR_SHA_INTR_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_PMR_SHA_INTR_offset;  // OFFSET
    // Write/Read Protection signals
    wire KAM_PMR_SHA_INTR_wprot ;
    wire KAM_PMR_SHA_INTR_rprot ;
    
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_PMR_SHA_INTR_VERIFY_DONE_q ;      // FIELD : VERIFY_DONE
    reg KAM_PMR_SHA_INTR_GEN_DONE_q    ;      // FIELD : GEN_DONE
    reg KAM_PMR_SHA_INTR_IN_FIFO_AE_q  ;      // FIELD : IN_FIFO_AE
    reg KAM_PMR_SHA_INTR_ERR_q         ;      // FIELD : ERR
    reg KAM_PMR_SHA_INTR_ALERT_q       ;      // FIELD : ALERT
    
    
    
    
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_ECC_CTRL_PMR SIGNALS
    
    
    wire    KAM_ECC_CTRL_PMR_decode;         // DECODE
    wire    KAM_ECC_CTRL_PMR_wr_valid;       // WRITE VALID
    wire    KAM_ECC_CTRL_PMR_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_ECC_CTRL_PMR_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_ECC_CTRL_PMR_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_ECC_CTRL_PMR_ERR_SB_INSERT_q ;      // FIELD : ERR_SB_INSERT
    reg KAM_ECC_CTRL_PMR_ERR_DB_INSERT_q ;      // FIELD : ERR_DB_INSERT
    reg KAM_ECC_CTRL_PMR_ERR_CLEAR_q     ;      // FIELD : ERR_CLEAR
    reg KAM_ECC_CTRL_PMR_ENABLE_q        ;      // FIELD : ENABLE
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_ECC_STATUS_PMR SIGNALS
    
    
    wire    KAM_ECC_STATUS_PMR_decode;         // DECODE
    wire    KAM_ECC_STATUS_PMR_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_ECC_STATUS_PMR_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_ECC_STATUS_PMR_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    wire          KAM_ECC_STATUS_PMR_ERR_DB_q    ;      // FIELD : ERR_DB
    wire          KAM_ECC_STATUS_PMR_ERR_SB_q    ;      // FIELD : ERR_SB
    wire  [3 : 0] KAM_ECC_STATUS_PMR_ERR_COUNT_q ;      // FIELD : ERR_COUNT
    wire  [6 : 0] KAM_ECC_STATUS_PMR_ECC_q       ;      // FIELD : ECC
    wire [14 : 0] KAM_ECC_STATUS_PMR_ADDR_q      ;      // FIELD : ADDR
    
    
    
    
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_ECC_LOG_PMR SIGNALS
    
    
    wire    KAM_ECC_LOG_PMR_decode;         // DECODE
    wire    KAM_ECC_LOG_PMR_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_ECC_LOG_PMR_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_ECC_LOG_PMR_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    wire [31 : 0] KAM_ECC_LOG_PMR_DATA_q ;      // FIELD : DATA
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_ERR_STATUS SIGNALS
    
    
    wire    KAM_ERR_STATUS_decode;         // DECODE
    wire    KAM_ERR_STATUS_wr_valid;       // WRITE VALID
    wire    KAM_ERR_STATUS_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_ERR_STATUS_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_ERR_STATUS_offset;  // OFFSET
    
    //  FIELD : SHA_UNAUTHORIZED SPECIAL CONTROL SIGNAL
    
    //  FIELD : PMR_EXTEND_ABORT SPECIAL CONTROL SIGNAL
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_ERR_STATUS_SHA_UNAUTHORIZED_q ;      // FIELD : SHA_UNAUTHORIZED
    reg KAM_ERR_STATUS_PMR_EXTEND_ABORT_q ;      // FIELD : PMR_EXTEND_ABORT
    reg KAM_ERR_STATUS_ECC_SB_PMR_q       ;      // FIELD : ECC_SB_PMR
    reg KAM_ERR_STATUS_ECC_DB_PMR_q       ;      // FIELD : ECC_DB_PMR
    
    
    
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_INTR_STATE SIGNALS
    
    
    wire    KAM_INTR_STATE_decode;         // DECODE
    wire    KAM_INTR_STATE_wr_valid;       // WRITE VALID
    wire    KAM_INTR_STATE_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_INTR_STATE_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_INTR_STATE_offset;  // OFFSET
    
    //  FIELD : OTPC_INT SPECIAL CONTROL SIGNAL
    
    //  FIELD : OTP_WRITE_DENY SPECIAL CONTROL SIGNAL
    
    //  FIELD : OTP_READ_DENY SPECIAL CONTROL SIGNAL
    
    //  FIELD : KV_WRITE_DENY SPECIAL CONTROL SIGNAL
    
    //  FIELD : KV_READ_DENY SPECIAL CONTROL SIGNAL
    
    //  FIELD : PMR_EXTEND_COMPLETE SPECIAL CONTROL SIGNAL
    
    //  FIELD : ERR SPECIAL CONTROL SIGNAL
    
    //  FIELD : ALERT SPECIAL CONTROL SIGNAL
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_INTR_STATE_OTPC_INT_q            ;      // FIELD : OTPC_INT
    reg KAM_INTR_STATE_OTP_WRITE_DENY_q      ;      // FIELD : OTP_WRITE_DENY
    reg KAM_INTR_STATE_OTP_READ_DENY_q       ;      // FIELD : OTP_READ_DENY
    reg KAM_INTR_STATE_KV_WRITE_DENY_q       ;      // FIELD : KV_WRITE_DENY
    reg KAM_INTR_STATE_KV_READ_DENY_q        ;      // FIELD : KV_READ_DENY
    reg KAM_INTR_STATE_PMR_EXTEND_COMPLETE_q ;      // FIELD : PMR_EXTEND_COMPLETE
    reg KAM_INTR_STATE_ERR_q                 ;      // FIELD : ERR
    reg KAM_INTR_STATE_ALERT_q               ;      // FIELD : ALERT
    
    
    
    
    
    
    
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_INTR_ENABLE SIGNALS
    
    
    wire    KAM_INTR_ENABLE_decode;         // DECODE
    wire    KAM_INTR_ENABLE_wr_valid;       // WRITE VALID
    wire    KAM_INTR_ENABLE_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_INTR_ENABLE_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_INTR_ENABLE_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_INTR_ENABLE_OTPC_INT_q            ;      // FIELD : OTPC_INT
    reg KAM_INTR_ENABLE_OTP_WRITE_DENY_q      ;      // FIELD : OTP_WRITE_DENY
    reg KAM_INTR_ENABLE_OTP_READ_DENY_q       ;      // FIELD : OTP_READ_DENY
    reg KAM_INTR_ENABLE_KV_WRITE_DENY_q       ;      // FIELD : KV_WRITE_DENY
    reg KAM_INTR_ENABLE_KV_READ_DENY_q        ;      // FIELD : KV_READ_DENY
    reg KAM_INTR_ENABLE_PMR_EXTEND_COMPLETE_q ;      // FIELD : PMR_EXTEND_COMPLETE
    reg KAM_INTR_ENABLE_ERR_q                 ;      // FIELD : ERR
    reg KAM_INTR_ENABLE_ALERT_q               ;      // FIELD : ALERT
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_INTR_TEST SIGNALS
    
    
    wire    KAM_INTR_TEST_decode;         // DECODE
    wire    KAM_INTR_TEST_wr_valid;       // WRITE VALID
    wire    KAM_INTR_TEST_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_INTR_TEST_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_INTR_TEST_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_INTR_TEST_OTPC_INT_q            ;      // FIELD : OTPC_INT
    reg KAM_INTR_TEST_OTP_WRITE_DENY_q      ;      // FIELD : OTP_WRITE_DENY
    reg KAM_INTR_TEST_OTP_READ_DENY_q       ;      // FIELD : OTP_READ_DENY
    reg KAM_INTR_TEST_KV_WRITE_DENY_q       ;      // FIELD : KV_WRITE_DENY
    reg KAM_INTR_TEST_KV_READ_DENY_q        ;      // FIELD : KV_READ_DENY
    reg KAM_INTR_TEST_PMR_EXTEND_COMPLETE_q ;      // FIELD : PMR_EXTEND_COMPLETE
    reg KAM_INTR_TEST_ERR_q                 ;      // FIELD : ERR
    reg KAM_INTR_TEST_ALERT_q               ;      // FIELD : ALERT
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : KAM_SCRATCH SIGNALS
    
    
    wire    KAM_SCRATCH_decode;         // DECODE
    wire    KAM_SCRATCH_wr_valid;       // WRITE VALID
    wire    KAM_SCRATCH_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_SCRATCH_rd_data;          // READ DATA
    wire    [64-1 : 0] KAM_SCRATCH_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] KAM_SCRATCH_DATA_q ;      // FIELD : DATA
    
    //-----------------------------------------------------
    
    
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_OTPC_CONTROL SIGNALS
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_decode;
    wire    [64-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_offset;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_valid;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_valid;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_req_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_ack_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_OTPC_ADDRESS SIGNALS
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_decode;
    wire    [64-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_offset;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_valid;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_valid;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_req_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_ack_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_OTPC_CONTROL0 SIGNALS
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_decode;
    wire    [64-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_offset;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_valid;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_valid;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_req_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_ack_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_OTPC_STATUS0 SIGNALS
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_decode;
    wire    [64-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_offset;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_valid;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_ack_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_data;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_write_error;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_error;
    
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_OTPC_STATUS1 SIGNALS
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_decode;
    wire    [64-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_offset;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_valid;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_valid;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_req_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_ack_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_OTPC_WRITE SIGNALS
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_decode;
    wire    [64-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_offset;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_valid;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_valid;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_req_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_ack_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_OTPC_READ SIGNALS
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_READ_decode;
    wire    [64-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_READ_offset;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_valid;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_ack_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_READ_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_data;
    wire    KAM_OTP_OTPC_KAM_OTP_OTPC_READ_write_error;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_READ_write_error_wire;
    wire     KAM_OTP_OTPC_KAM_OTP_OTPC_READ_error_wire;
    
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_EFC_CONTROL SIGNALS
    wire    KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_decode;
    wire    [64-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_offset;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_valid;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_valid;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_req_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_ack_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_EFC_BYPASS_CONTROL SIGNALS
    wire    KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_decode;
    wire    [64-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_offset;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_valid;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_valid;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_req_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_ack_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_EFC_STATUS SIGNALS
    wire    KAM_OTP_EFC_KAM_OTP_EFC_STATUS_decode;
    wire    [64-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_STATUS_offset;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_valid;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_valid;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_req_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_ack_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_STATUS_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_EFC_POWER_CONTROLS SIGNALS
    wire    KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_decode;
    wire    [64-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_offset;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_valid;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_valid;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_req_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_ack_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_EFC_ACCESS_TIMERS SIGNALS
    wire    KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_decode;
    wire    [64-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_offset;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_valid;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_valid;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_req_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_ack_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_EFC_ADDRESS SIGNALS
    wire    KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_decode;
    wire    [64-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_offset;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_valid;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_valid;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_req_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_ack_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_EFC_PGM_DATA SIGNALS
    wire    KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_decode;
    wire    [64-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_offset;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_valid;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_valid;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_req_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_ack_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_OTP_EFC_RD_DATA SIGNALS
    wire    KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_decode;
    wire    [64-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_offset;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_valid;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_ack_wire;
    wire     KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_data;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_write_error;
    wire    KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_error;
    
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : CONFIG SIGNALS
    
    
    wire    KAM_OTP_LANE_CONFIG_decode[KAM_OTP_LANE_count-1 : 0];         // DECODE
    wire    [KAM_OTP_LANE_count-1 : 0]KAM_OTP_LANE_CONFIG_wr_valid;       // WRITE VALID
    wire    [KAM_OTP_LANE_count-1 : 0]KAM_OTP_LANE_CONFIG_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_OTP_LANE_CONFIG_rd_data[KAM_OTP_LANE_count-1 : 0];          // READ DATA
    wire    [64-1 : 0] KAM_OTP_LANE_CONFIG_offset[KAM_OTP_LANE_count-1 : 0];  // OFFSET
    wire   [bus_width-1 : 0] KAM_OTP_LANE_CONFIG_rd_data_wire;
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          KAM_OTP_LANE_CONFIG_LANE_ENABLE_q[KAM_OTP_LANE_count-1 : 0] ;      // FIELD : LANE_ENABLE
    reg  [5 : 0] KAM_OTP_LANE_CONFIG_LANE_COUNT_q[KAM_OTP_LANE_count-1 : 0]  ;      // FIELD : LANE_COUNT
    reg  [9 : 0] KAM_OTP_LANE_CONFIG_LANE_START_q[KAM_OTP_LANE_count-1 : 0]  ;      // FIELD : LANE_START
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : ACCESS SIGNALS
    
    
    wire    KAM_OTP_LANE_ACCESS_decode[KAM_OTP_LANE_count-1 : 0];         // DECODE
    wire    [KAM_OTP_LANE_count-1 : 0]KAM_OTP_LANE_ACCESS_wr_valid;       // WRITE VALID
    wire    [KAM_OTP_LANE_count-1 : 0]KAM_OTP_LANE_ACCESS_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_OTP_LANE_ACCESS_rd_data[KAM_OTP_LANE_count-1 : 0];          // READ DATA
    wire    [64-1 : 0] KAM_OTP_LANE_ACCESS_offset[KAM_OTP_LANE_count-1 : 0];  // OFFSET
    wire   [bus_width-1 : 0] KAM_OTP_LANE_ACCESS_rd_data_wire;
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_count-1 : 0] ;      // FIELD : OTP_LANE_LOCK
    reg KAM_OTP_LANE_ACCESS_RE_q[KAM_OTP_LANE_count-1 : 0]            ;      // FIELD : RE
    reg KAM_OTP_LANE_ACCESS_WE_q[KAM_OTP_LANE_count-1 : 0]            ;      // FIELD : WE
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : STATUS SIGNALS
    
    
    wire    KAM_OTP_LANE_STATUS_decode[KAM_OTP_LANE_count-1 : 0];         // DECODE
    wire    [KAM_OTP_LANE_count-1 : 0]KAM_OTP_LANE_STATUS_wr_valid;       // WRITE VALID
    wire    [KAM_OTP_LANE_count-1 : 0]KAM_OTP_LANE_STATUS_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_OTP_LANE_STATUS_rd_data[KAM_OTP_LANE_count-1 : 0];          // READ DATA
    wire    [64-1 : 0] KAM_OTP_LANE_STATUS_offset[KAM_OTP_LANE_count-1 : 0];  // OFFSET
    wire   [bus_width-1 : 0] KAM_OTP_LANE_STATUS_rd_data_wire;
    
    //  FIELD : WRITE_DENY SPECIAL CONTROL SIGNAL
    
    //  FIELD : READ_DENY SPECIAL CONTROL SIGNAL
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_OTP_LANE_STATUS_WRITE_DENY_q[KAM_OTP_LANE_count-1 : 0] ;      // FIELD : WRITE_DENY
    reg KAM_OTP_LANE_STATUS_READ_DENY_q[KAM_OTP_LANE_count-1 : 0]  ;      // FIELD : READ_DENY
    
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : RANGE SIGNALS
    
    
    wire    KAM_KV_RANGE_decode[KAM_KV_count-1 : 0];         // DECODE
    wire    [KAM_KV_count-1 : 0]KAM_KV_RANGE_wr_valid;       // WRITE VALID
    wire    [KAM_KV_count-1 : 0]KAM_KV_RANGE_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_KV_RANGE_rd_data[KAM_KV_count-1 : 0];          // READ DATA
    wire    [64-1 : 0] KAM_KV_RANGE_offset[KAM_KV_count-1 : 0];  // OFFSET
    wire   [bus_width-1 : 0] KAM_KV_RANGE_rd_data_wire;
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          KAM_KV_RANGE_KV_ENABLE_q[KAM_KV_count-1 : 0] ;      // FIELD : KV_ENABLE
    reg  [7 : 0] KAM_KV_RANGE_KV_COUNT_q[KAM_KV_count-1 : 0]  ;      // FIELD : KV_COUNT
    reg  [7 : 0] KAM_KV_RANGE_KV_START_q[KAM_KV_count-1 : 0]  ;      // FIELD : KV_START
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : ACCESS SIGNALS
    
    
    wire    KAM_KV_ACCESS_decode[KAM_KV_count-1 : 0];         // DECODE
    wire    [KAM_KV_count-1 : 0]KAM_KV_ACCESS_wr_valid;       // WRITE VALID
    wire    [KAM_KV_count-1 : 0]KAM_KV_ACCESS_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_KV_ACCESS_rd_data[KAM_KV_count-1 : 0];          // READ DATA
    wire    [64-1 : 0] KAM_KV_ACCESS_offset[KAM_KV_count-1 : 0];  // OFFSET
    wire   [bus_width-1 : 0] KAM_KV_ACCESS_rd_data_wire;
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_count-1 : 0] ;      // FIELD : KV_RANGE_LOCK
    reg KAM_KV_ACCESS_RE_q[KAM_KV_count-1 : 0]            ;      // FIELD : RE
    reg KAM_KV_ACCESS_WE_q[KAM_KV_count-1 : 0]            ;      // FIELD : WE
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : STATUS SIGNALS
    
    
    wire    KAM_KV_STATUS_decode[KAM_KV_count-1 : 0];         // DECODE
    wire    [KAM_KV_count-1 : 0]KAM_KV_STATUS_wr_valid;       // WRITE VALID
    wire    [KAM_KV_count-1 : 0]KAM_KV_STATUS_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] KAM_KV_STATUS_rd_data[KAM_KV_count-1 : 0];          // READ DATA
    wire    [64-1 : 0] KAM_KV_STATUS_offset[KAM_KV_count-1 : 0];  // OFFSET
    wire   [bus_width-1 : 0] KAM_KV_STATUS_rd_data_wire;
    
    //  FIELD : WRITE_DENY SPECIAL CONTROL SIGNAL
    
    //  FIELD : READ_DENY SPECIAL CONTROL SIGNAL
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg KAM_KV_STATUS_WRITE_DENY_q[KAM_KV_count-1 : 0] ;      // FIELD : WRITE_DENY
    reg KAM_KV_STATUS_READ_DENY_q[KAM_KV_count-1 : 0]  ;      // FIELD : READ_DENY
    
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : KAM_PMR_ENTRY SIGNALS
    wire    KAM_PMR_LIST_KAM_PMR_ENTRY_decode[KAM_PMR_LIST_count-1 : 0];
    wire    [64-1 : 0] KAM_PMR_LIST_KAM_PMR_ENTRY_offset[KAM_PMR_LIST_count-1 : 0];
    wire   [KAM_PMR_LIST_count-1 : 0] KAM_PMR_LIST_KAM_PMR_ENTRY_rd_valid;
    wire   [KAM_PMR_LIST_count-1 : 0] KAM_PMR_LIST_KAM_PMR_ENTRY_wr_valid;
    wire     KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_wire;
    wire     KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_wire;
    wire     KAM_PMR_LIST_KAM_PMR_ENTRY_decode_wire;
    
    wire    [bus_width-1 : 0] KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[KAM_PMR_LIST_count-1 : 0];
    wire     [bus_width-1 : 0] KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data_wire;
    
    // Write/Read Protection signals
    wire KAM_PMR_LIST_KAM_PMR_ENTRY_wprot ;
    wire    KAM_PMR_LIST_KAM_PMR_ENTRY_write_error[KAM_PMR_LIST_count-1 : 0];
    wire     KAM_PMR_LIST_KAM_PMR_ENTRY_write_error_wire;
    wire     KAM_PMR_LIST_KAM_PMR_ENTRY_error_wire;
    
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    
    wire  [bus_width-1:0] int_rd_data;
    wire  [bus_width-1:0] ext_rd_data;
    wire external_rd_valid;
    reg  rd_wait_state;
    wire external_rd_ack;
    wire external_wr_req;
    wire external_access;
    wire  [3 : 0] hprot_i;
    
    wire  clk;
    wire  reset_l;
    wire   rd_stb;
    wire   rd_wait;
    wire   wr_stb;
    wire  [addr_width-1:0]  address;
    wire  [bus_width-1:0]  wr_data;
    wire   request;
    wire  rd_data_vld;
    wire  [bus_width-1:0] rd_data;
    wire  error;
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    AMBA3AHBlite_widget #(.addr_width(addr_width), .bus_width(bus_width)) AMBA3AHBlite(
            .hclk(hclk),
            .hresetn(hresetn),
            .haddr(haddr),
            .hburst(hburst),
            .hprot(hprot),
            .hsize(hsize),
            .htrans(htrans),
            .hwdata(hwdata),
            .hwrite(hwrite),
            .hready(hready),
            .hrdata(hrdata),
            .hsel(hsel),
            .hreadyout(hreadyout),
            .hresp(hresp),
            .clk(clk),
            .reset_l(reset_l),
            .address(address),
            .request(request),
            .wr_stb(wr_stb),
            .rd_stb(rd_stb),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .rd_data_vld(rd_data_vld),
            .rd_wait(rd_wait),
            .hprot_i(hprot_i),
            .byte_enb(byte_enb),
            .error(error));
    //end widget
    assign address_out = address;
    assign wr_data_out = wr_data;
    
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    // Register Protection : KAM_PMR_SHA_CONFIG
    // Write Protection : Privileged Access
    assign KAM_PMR_SHA_CONFIG_wprot = hprot_i[1];
    
    // Read Protection :
    assign KAM_PMR_SHA_CONFIG_rprot = hprot_i[1];
    
    // Register Protection : KAM_PMR_SHA_INTR
    // Write Protection : Privileged Access
    assign KAM_PMR_SHA_INTR_wprot = hprot_i[1];
    
    // Read Protection :
    assign KAM_PMR_SHA_INTR_rprot = hprot_i[1];
    
    // Register Protection : KAM_PMR_LIST_KAM_PMR_ENTRY
    // Write Protection : Privileged Access
    assign KAM_PMR_LIST_KAM_PMR_ENTRY_wprot = hprot_i[1];
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_HW_CONTROL_VALID
    // ADDRESS       :  block_offset+'h260                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:0 : VALID  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_OTP_HW_CONTROL_VALID_wr_valid = KAM_OTP_HW_CONTROL_VALID_decode && wr_stb;
    assign KAM_OTP_HW_CONTROL_VALID_rd_valid = KAM_OTP_HW_CONTROL_VALID_decode && rd_stb;
    assign KAM_OTP_HW_CONTROL_VALID_offset = block_offset+'h260;
    assign KAM_OTP_HW_CONTROL_VALID_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_OTP_HW_CONTROL_VALID_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : VALID
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_VALID_VALID_q  <=1'd0;
            end
        else
            begin
                
            if (KAM_OTP_HW_CONTROL_VALID_wr_valid && !((KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_q) && ((KAM_OTP_HW_CONTROL_VALID_VALID_q) && (KAM_OTP_HW_CONTROL_LCM_MODE_q))))   // VALID : SW Write
                begin
                    KAM_OTP_HW_CONTROL_VALID_VALID_q <=  ( wr_data[0] & reg_enb[0] ) | (KAM_OTP_HW_CONTROL_VALID_VALID_q & (~reg_enb[0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_OTP_HW_CONTROL_VALID_VALID_r  =  KAM_OTP_HW_CONTROL_VALID_VALID_q ;    // Field : VALID
    
    
    assign KAM_OTP_HW_CONTROL_VALID_rd_data = KAM_OTP_HW_CONTROL_VALID_rd_valid ? {31'b0 ,KAM_OTP_HW_CONTROL_VALID_VALID_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_HW_CONTROL
    // ADDRESS       :  block_offset+'h264                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //    31:31 : HWC_VALID             ( SW : Read-only  HW : Read-Write )
    //    30:30 : AUTOLOAD_VALID        ( SW : Read-only  HW : Read-Write )
    //    29:29 : AUTOLOAD_ERR          ( SW : Read-only  HW : Read-Write )
    //    12:12 : LCM_MODE              ( SW : Read-Write HW : Read-only )
    //    11:11 : KAM_KV_EN             ( SW : Read-Write HW : Read-only )
    //    10:10 : KAM_OAF_EN            ( SW : Read-Write HW : Read-only )
    //      9:9 : KAM_HWC_LOCK_ENABLE   ( SW : Read-Write HW : Read-only )
    //      8:8 : RESERVED_1            ( SW : Read-Write HW : Read-only )
    //      7:7 : ROT_EXCLUSIVE_ACCESS  ( SW : Read-Write HW : Read-only )
    //      6:6 : RESERVED_0            ( SW : Read-Write HW : Read-only )
    //      5:5 : SOFT_RESET_DISABLE    ( SW : Read-Write HW : Read-Write )
    //      4:4 : SEC_LOAD_FAIL_REPORT  ( SW : Read-Write HW : Read-Write )
    //      3:3 : ROT_ROM_BOOT_SRC      ( SW : Read-Write HW : Read-Write )
    //      2:2 : UART_DISABLE          ( SW : Read-Write HW : Read-Write )
    //      1:1 : SOC_DEBUG             ( SW : Read-Write HW : Read-Write )
    //      0:0 : ROT_DEBUG             ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_OTP_HW_CONTROL_wr_valid = KAM_OTP_HW_CONTROL_decode && wr_stb;
    assign KAM_OTP_HW_CONTROL_rd_valid = KAM_OTP_HW_CONTROL_decode && rd_stb;
    assign KAM_OTP_HW_CONTROL_offset = block_offset+'h264;
    assign KAM_OTP_HW_CONTROL_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_OTP_HW_CONTROL_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : AUTOLOAD_VALID
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-ONLY                           OFFSET :  30
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_q        <=1'd0;
            end
        else
            begin
            if (KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_in_enb)   // AUTOLOAD_VALID : HW Write
                begin
                    KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_q <= KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : AUTOLOAD_ERR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-ONLY                           OFFSET :  29
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_q          <=1'd0;
            end
        else
            begin
            if (KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_in_enb)   // AUTOLOAD_ERR : HW Write
                begin
                    KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_q <= KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : LCM_MODE
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_LCM_MODE_q              <=1'd1;
            end
        else
            begin
                
            if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // LCM_MODE : SW Write
                begin
                    KAM_OTP_HW_CONTROL_LCM_MODE_q <=  ( wr_data[12] & reg_enb[12] ) | (KAM_OTP_HW_CONTROL_LCM_MODE_q & (~reg_enb[12]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KAM_KV_EN
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  11
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_KAM_KV_EN_q             <=1'd1;
            end
        else
            begin
                
            if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // KAM_KV_EN : SW Write
                begin
                    KAM_OTP_HW_CONTROL_KAM_KV_EN_q <=  ( wr_data[11] & reg_enb[11] ) | (KAM_OTP_HW_CONTROL_KAM_KV_EN_q & (~reg_enb[11]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KAM_OAF_EN
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  10
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_KAM_OAF_EN_q            <=1'd1;
            end
        else
            begin
                
            if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // KAM_OAF_EN : SW Write
                begin
                    KAM_OTP_HW_CONTROL_KAM_OAF_EN_q <=  ( wr_data[10] & reg_enb[10] ) | (KAM_OTP_HW_CONTROL_KAM_OAF_EN_q & (~reg_enb[10]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KAM_HWC_LOCK_ENABLE
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  9
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_q   <=1'd1;
            end
        else
            begin
                
            if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // KAM_HWC_LOCK_ENABLE : SW Write
                begin
                    KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_q <=  ( wr_data[9] & reg_enb[9] ) | (KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_q & (~reg_enb[9]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : RESERVED_1
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_RESERVED_1_q            <=1'd1;
            end
        else
            begin
                
            if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // RESERVED_1 : SW Write
                begin
                    KAM_OTP_HW_CONTROL_RESERVED_1_q <=  ( wr_data[8] & reg_enb[8] ) | (KAM_OTP_HW_CONTROL_RESERVED_1_q & (~reg_enb[8]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ROT_EXCLUSIVE_ACCESS
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_ROT_EXCLUSIVE_ACCESS_q  <=1'd1;
            end
        else
            begin
                
            if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // ROT_EXCLUSIVE_ACCESS : SW Write
                begin
                    KAM_OTP_HW_CONTROL_ROT_EXCLUSIVE_ACCESS_q <=  ( wr_data[7] & reg_enb[7] ) | (KAM_OTP_HW_CONTROL_ROT_EXCLUSIVE_ACCESS_q & (~reg_enb[7]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : RESERVED_0
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  6
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_RESERVED_0_q            <=1'd1;
            end
        else
            begin
                
            if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // RESERVED_0 : SW Write
                begin
                    KAM_OTP_HW_CONTROL_RESERVED_0_q <=  ( wr_data[6] & reg_enb[6] ) | (KAM_OTP_HW_CONTROL_RESERVED_0_q & (~reg_enb[6]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : SOFT_RESET_DISABLE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  5
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_q    <=1'd1;
            end
        else
            begin
            if (KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_in_enb)   // SOFT_RESET_DISABLE : HW Write
                begin
                    KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_q <= KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_in;
                end
            else
                begin
                    
                if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // SOFT_RESET_DISABLE : SW Write
                    begin
                        KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_q <=  ( wr_data[5] & reg_enb[5] ) | (KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_q & (~reg_enb[5]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : SEC_LOAD_FAIL_REPORT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_q  <=1'd1;
            end
        else
            begin
            if (KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_in_enb)   // SEC_LOAD_FAIL_REPORT : HW Write
                begin
                    KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_q <= KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_in;
                end
            else
                begin
                    
                if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // SEC_LOAD_FAIL_REPORT : SW Write
                    begin
                        KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_q <=  ( wr_data[4] & reg_enb[4] ) | (KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_q & (~reg_enb[4]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ROT_ROM_BOOT_SRC
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_q      <=1'd1;
            end
        else
            begin
            if (KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_in_enb)   // ROT_ROM_BOOT_SRC : HW Write
                begin
                    KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_q <= KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_in;
                end
            else
                begin
                    
                if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // ROT_ROM_BOOT_SRC : SW Write
                    begin
                        KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_q <=  ( wr_data[3] & reg_enb[3] ) | (KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_q & (~reg_enb[3]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : UART_DISABLE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_UART_DISABLE_q          <=1'd1;
            end
        else
            begin
            if (KAM_OTP_HW_CONTROL_UART_DISABLE_in_enb)   // UART_DISABLE : HW Write
                begin
                    KAM_OTP_HW_CONTROL_UART_DISABLE_q <= KAM_OTP_HW_CONTROL_UART_DISABLE_in;
                end
            else
                begin
                    
                if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // UART_DISABLE : SW Write
                    begin
                        KAM_OTP_HW_CONTROL_UART_DISABLE_q <=  ( wr_data[2] & reg_enb[2] ) | (KAM_OTP_HW_CONTROL_UART_DISABLE_q & (~reg_enb[2]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : SOC_DEBUG
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_SOC_DEBUG_q             <=1'd1;
            end
        else
            begin
            if (KAM_OTP_HW_CONTROL_SOC_DEBUG_in_enb)   // SOC_DEBUG : HW Write
                begin
                    KAM_OTP_HW_CONTROL_SOC_DEBUG_q <= KAM_OTP_HW_CONTROL_SOC_DEBUG_in;
                end
            else
                begin
                    
                if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // SOC_DEBUG : SW Write
                    begin
                        KAM_OTP_HW_CONTROL_SOC_DEBUG_q <=  ( wr_data[1] & reg_enb[1] ) | (KAM_OTP_HW_CONTROL_SOC_DEBUG_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ROT_DEBUG
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_OTP_HW_CONTROL_ROT_DEBUG_q             <=1'd1;
            end
        else
            begin
            if (KAM_OTP_HW_CONTROL_ROT_DEBUG_in_enb)   // ROT_DEBUG : HW Write
                begin
                    KAM_OTP_HW_CONTROL_ROT_DEBUG_q <= KAM_OTP_HW_CONTROL_ROT_DEBUG_in;
                end
            else
                begin
                    
                if (KAM_OTP_HW_CONTROL_wr_valid && !(KAM_OTP_HW_CONTROL_VALID_VALID_q))   // ROT_DEBUG : SW Write
                    begin
                        KAM_OTP_HW_CONTROL_ROT_DEBUG_q <=  ( wr_data[0] & reg_enb[0] ) | (KAM_OTP_HW_CONTROL_ROT_DEBUG_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_OTP_HW_CONTROL_HWC_VALID_r             =  KAM_OTP_HW_CONTROL_HWC_VALID_q            ;    // Field : HWC_VALID
    assign KAM_OTP_HW_CONTROL_HWC_VALID_q             = KAM_OTP_HW_CONTROL_HWC_VALID_in            ;    // Field: HWC_VALID
    assign KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_r        =  KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_q       ;    // Field : AUTOLOAD_VALID
    assign KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_r          =  KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_q         ;    // Field : AUTOLOAD_ERR
    assign KAM_OTP_HW_CONTROL_LCM_MODE_r              =  KAM_OTP_HW_CONTROL_LCM_MODE_q             ;    // Field : LCM_MODE
    assign KAM_OTP_HW_CONTROL_KAM_KV_EN_r             =  KAM_OTP_HW_CONTROL_KAM_KV_EN_q            ;    // Field : KAM_KV_EN
    assign KAM_OTP_HW_CONTROL_KAM_OAF_EN_r            =  KAM_OTP_HW_CONTROL_KAM_OAF_EN_q           ;    // Field : KAM_OAF_EN
    assign KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_r   =  KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_q  ;    // Field : KAM_HWC_LOCK_ENABLE
    assign KAM_OTP_HW_CONTROL_RESERVED_1_r            =  KAM_OTP_HW_CONTROL_RESERVED_1_q           ;    // Field : RESERVED_1
    assign KAM_OTP_HW_CONTROL_ROT_EXCLUSIVE_ACCESS_r  =  KAM_OTP_HW_CONTROL_ROT_EXCLUSIVE_ACCESS_q ;    // Field : ROT_EXCLUSIVE_ACCESS
    assign KAM_OTP_HW_CONTROL_RESERVED_0_r            =  KAM_OTP_HW_CONTROL_RESERVED_0_q           ;    // Field : RESERVED_0
    assign KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_r    =  KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_q   ;    // Field : SOFT_RESET_DISABLE
    assign KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_r  =  KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_q ;    // Field : SEC_LOAD_FAIL_REPORT
    assign KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_r      =  KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_q     ;    // Field : ROT_ROM_BOOT_SRC
    assign KAM_OTP_HW_CONTROL_UART_DISABLE_r          =  KAM_OTP_HW_CONTROL_UART_DISABLE_q         ;    // Field : UART_DISABLE
    assign KAM_OTP_HW_CONTROL_SOC_DEBUG_r             =  KAM_OTP_HW_CONTROL_SOC_DEBUG_q            ;    // Field : SOC_DEBUG
    assign KAM_OTP_HW_CONTROL_ROT_DEBUG_r             =  KAM_OTP_HW_CONTROL_ROT_DEBUG_q            ;    // Field : ROT_DEBUG
    
    
    assign KAM_OTP_HW_CONTROL_rd_data = KAM_OTP_HW_CONTROL_rd_valid ? {KAM_OTP_HW_CONTROL_HWC_VALID_q , KAM_OTP_HW_CONTROL_AUTOLOAD_VALID_q , KAM_OTP_HW_CONTROL_AUTOLOAD_ERR_q , 16'b0 ,KAM_OTP_HW_CONTROL_LCM_MODE_q , KAM_OTP_HW_CONTROL_KAM_KV_EN_q , KAM_OTP_HW_CONTROL_KAM_OAF_EN_q , KAM_OTP_HW_CONTROL_KAM_HWC_LOCK_ENABLE_q , KAM_OTP_HW_CONTROL_RESERVED_1_q , KAM_OTP_HW_CONTROL_ROT_EXCLUSIVE_ACCESS_q , KAM_OTP_HW_CONTROL_RESERVED_0_q , KAM_OTP_HW_CONTROL_SOFT_RESET_DISABLE_q , KAM_OTP_HW_CONTROL_SEC_LOAD_FAIL_REPORT_q , KAM_OTP_HW_CONTROL_ROT_ROM_BOOT_SRC_q , KAM_OTP_HW_CONTROL_UART_DISABLE_q , KAM_OTP_HW_CONTROL_SOC_DEBUG_q , KAM_OTP_HW_CONTROL_ROT_DEBUG_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_PMR_EXTEND_MEASUREMENT_SRC
    // ADDRESS       :  block_offset+'h620                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : ADDR  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_PMR_EXTEND_MEASUREMENT_SRC_wr_valid = KAM_PMR_EXTEND_MEASUREMENT_SRC_decode && wr_stb;
    assign KAM_PMR_EXTEND_MEASUREMENT_SRC_rd_valid = KAM_PMR_EXTEND_MEASUREMENT_SRC_decode && rd_stb;
    assign KAM_PMR_EXTEND_MEASUREMENT_SRC_offset = block_offset+'h620;
    assign KAM_PMR_EXTEND_MEASUREMENT_SRC_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_PMR_EXTEND_MEASUREMENT_SRC_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ADDR
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  address of Measurement source, MSMT. HW calulates SHA(PMR | MSMT)
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_EXTEND_MEASUREMENT_SRC_ADDR_q  <=32'd0;
            end
        else
            begin
                
            if (KAM_PMR_EXTEND_MEASUREMENT_SRC_wr_valid)   // ADDR : SW Write
                begin
                    KAM_PMR_EXTEND_MEASUREMENT_SRC_ADDR_q <=  ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (KAM_PMR_EXTEND_MEASUREMENT_SRC_ADDR_q & (~reg_enb[31 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_PMR_EXTEND_MEASUREMENT_SRC_ADDR_r  =  KAM_PMR_EXTEND_MEASUREMENT_SRC_ADDR_q ;    // Field : ADDR
    
    
    assign KAM_PMR_EXTEND_MEASUREMENT_SRC_rd_data = KAM_PMR_EXTEND_MEASUREMENT_SRC_rd_valid ? {KAM_PMR_EXTEND_MEASUREMENT_SRC_ADDR_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_PMR_EXTEND_TARGET
    // ADDRESS       :  block_offset+'h624                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      5:4 : PMR_SIZE   ( SW : Read-Write HW : Read-only )
    //      2:0 : PMR_INDEX  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  Writing this register starts the PMR Extend operation. PMR[PMR_INDEX] = SHA ( PMR[PMR_INDEX] | MSG ) when PMR[PMR_INDEX] is valid (i.e. PMR_ENRY_VALID[PMR_INDEX] are set for all words indicated by PMR_SIZE) otherwise (invalid PMR[PMR_INDEX]): PMR[PMR_INDEX] = SHA ( MSG )
    //
    
    
    assign KAM_PMR_EXTEND_TARGET_wr_valid = KAM_PMR_EXTEND_TARGET_decode && wr_stb;
    assign KAM_PMR_EXTEND_TARGET_rd_valid = KAM_PMR_EXTEND_TARGET_decode && rd_stb;
    assign KAM_PMR_EXTEND_TARGET_enb      = KAM_PMR_EXTEND_TARGET_wr_valid;
    assign KAM_PMR_EXTEND_TARGET_offset = block_offset+'h624;
    assign KAM_PMR_EXTEND_TARGET_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_PMR_EXTEND_TARGET_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PMR_SIZE
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :  encoded for number of 32-bit entries PMR extend operation. The MSG must be the size as the PMR. 3 is an illegal value
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_EXTEND_TARGET_PMR_SIZE_q   <=2'd0;
            end
        else
            begin
                
            if (KAM_PMR_EXTEND_TARGET_wr_valid)   // PMR_SIZE : SW Write
                begin
                    KAM_PMR_EXTEND_TARGET_PMR_SIZE_q <=  ( wr_data[5 : 4] & reg_enb[5 : 4] ) | (KAM_PMR_EXTEND_TARGET_PMR_SIZE_q & (~reg_enb[5 : 4]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PMR_INDEX
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_EXTEND_TARGET_PMR_INDEX_q  <=3'd0;
            end
        else
            begin
                
            if (KAM_PMR_EXTEND_TARGET_wr_valid)   // PMR_INDEX : SW Write
                begin
                    KAM_PMR_EXTEND_TARGET_PMR_INDEX_q <=  ( wr_data[2 : 0] & reg_enb[2 : 0] ) | (KAM_PMR_EXTEND_TARGET_PMR_INDEX_q & (~reg_enb[2 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_PMR_EXTEND_TARGET_PMR_SIZE_r   =  KAM_PMR_EXTEND_TARGET_PMR_SIZE_q  ;    // Field : PMR_SIZE
    assign KAM_PMR_EXTEND_TARGET_PMR_INDEX_r  =  KAM_PMR_EXTEND_TARGET_PMR_INDEX_q ;    // Field : PMR_INDEX
    
    
    assign KAM_PMR_EXTEND_TARGET_rd_data = KAM_PMR_EXTEND_TARGET_rd_valid ? {26'b0 ,KAM_PMR_EXTEND_TARGET_PMR_SIZE_q , 1'b0 ,KAM_PMR_EXTEND_TARGET_PMR_INDEX_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_PMR_SHA_CONFIG
    // ADDRESS       :  block_offset+'h628                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //    30:24 : MODE           ( SW : Read-Write HW : Read-Write )
    //    18:16 : KEY_SIZE       ( SW : Read-Write HW : Read-Write )
    //     15:8 : IN_LEVEL       ( SW : Read-Write HW : Read-only )
    //      4:4 : DMA_IN         ( SW : Read-Write HW : Read-Write )
    //      1:1 : BYTE_SWAP_IN   ( SW : Read-Write HW : Read-Write )
    //      0:0 : BYTE_SWAP_OUT  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  Writable only by KAM PMR Extend function. Readable by any
    //
    
    
    assign KAM_PMR_SHA_CONFIG_wr_valid = KAM_PMR_SHA_CONFIG_decode && wr_stb && KAM_PMR_SHA_CONFIG_wprot;
    assign KAM_PMR_SHA_CONFIG_rd_valid = KAM_PMR_SHA_CONFIG_decode && rd_stb && KAM_PMR_SHA_CONFIG_rprot;
    assign KAM_PMR_SHA_CONFIG_offset = block_offset+'h628;
    assign KAM_PMR_SHA_CONFIG_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_PMR_SHA_CONFIG_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : MODE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  7
    // SW ACCESS  :  READ-WRITE                          OFFSET :  24
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Mode of operaton of SHA. 7'b0000001: SHA_256 7'b0000010: SHA_384 7'b0000100: SHA_512 7'b0001000: HMAC_SHA_256 7'b0010000: HMAC_SHA_384 7'b0100000: HMAC_SHA_512
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_CONFIG_MODE_q           <=7'd1;
            end
        else
            begin
            if (KAM_PMR_SHA_CONFIG_MODE_in_enb)   // MODE : HW Write
                begin
                    KAM_PMR_SHA_CONFIG_MODE_q <= KAM_PMR_SHA_CONFIG_MODE_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_CONFIG_wr_valid)   // MODE : SW Write
                    begin
                        KAM_PMR_SHA_CONFIG_MODE_q <=  ( wr_data[30 : 24] & reg_enb[30 : 24] ) | (KAM_PMR_SHA_CONFIG_MODE_q & (~reg_enb[30 : 24]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KEY_SIZE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Size of HMAC key. <li>3'b001: KEY_128: Use 128-bit key size, input at HMAC_KEY[0-3] <li>3'b010: KEY_192: Use 192-bit key size, input at HMAC_KEY[0-5] <li>3'b100: KEY_256: Use 256-bit key size, input at HMAC_KEY[0-7]
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_CONFIG_KEY_SIZE_q       <=3'd1;
            end
        else
            begin
            if (KAM_PMR_SHA_CONFIG_KEY_SIZE_in_enb)   // KEY_SIZE : HW Write
                begin
                    KAM_PMR_SHA_CONFIG_KEY_SIZE_q <= KAM_PMR_SHA_CONFIG_KEY_SIZE_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_CONFIG_wr_valid)   // KEY_SIZE : SW Write
                    begin
                        KAM_PMR_SHA_CONFIG_KEY_SIZE_q <=  ( wr_data[18 : 16] & reg_enb[18 : 16] ) | (KAM_PMR_SHA_CONFIG_KEY_SIZE_q & (~reg_enb[18 : 16]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : IN_LEVEL
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  8
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Input FIFO threshold controls SHA_INTR_STATE.IN_FIFO_AE signal. SHA_INTR_STATE.IN_FIFO_AE is latched to 1 when IN_LEVEL <= in_fifo_bytes_available
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_CONFIG_IN_LEVEL_q       <=8'd0;
            end
        else
            begin
                
            if (KAM_PMR_SHA_CONFIG_wr_valid)   // IN_LEVEL : SW Write
                begin
                    KAM_PMR_SHA_CONFIG_IN_LEVEL_q <=  ( wr_data[15 : 8] & reg_enb[15 : 8] ) | (KAM_PMR_SHA_CONFIG_IN_LEVEL_q & (~reg_enb[15 : 8]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DMA_IN
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Enable for DMA request signal for writing input data Use to protect BE Gate signals for power 0: Disable 1: Enable
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_CONFIG_DMA_IN_q         <=1'd0;
            end
        else
            begin
            if (KAM_PMR_SHA_CONFIG_DMA_IN_in_enb)   // DMA_IN : HW Write
                begin
                    KAM_PMR_SHA_CONFIG_DMA_IN_q <= KAM_PMR_SHA_CONFIG_DMA_IN_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_CONFIG_wr_valid)   // DMA_IN : SW Write
                    begin
                        KAM_PMR_SHA_CONFIG_DMA_IN_q <=  ( wr_data[4] & reg_enb[4] ) | (KAM_PMR_SHA_CONFIG_DMA_IN_q & (~reg_enb[4]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : BYTE_SWAP_IN
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Enable endian byte swapping for input data Byte swapping based on this control applies to SHA_MSG, SHA_GEN_DIGEST, SHA_GEN_CONTEXT and SHA_VERIFY, SHA_DIGEST register writes 0: Disable 1: Enable
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_q   <=1'd0;
            end
        else
            begin
            if (KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_in_enb)   // BYTE_SWAP_IN : HW Write
                begin
                    KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_q <= KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_CONFIG_wr_valid)   // BYTE_SWAP_IN : SW Write
                    begin
                        KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_q <=  ( wr_data[1] & reg_enb[1] ) | (KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : BYTE_SWAP_OUT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Enable endian byte swapping for output data, applies to SHA_DIGEST register reads only 0: Disable 1: Enable
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_q  <=1'd0;
            end
        else
            begin
            if (KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_in_enb)   // BYTE_SWAP_OUT : HW Write
                begin
                    KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_q <= KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_CONFIG_wr_valid)   // BYTE_SWAP_OUT : SW Write
                    begin
                        KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_q <=  ( wr_data[0] & reg_enb[0] ) | (KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_PMR_SHA_CONFIG_MODE_r           =  KAM_PMR_SHA_CONFIG_MODE_q          ;    // Field : MODE
    assign KAM_PMR_SHA_CONFIG_KEY_SIZE_r       =  KAM_PMR_SHA_CONFIG_KEY_SIZE_q      ;    // Field : KEY_SIZE
    assign KAM_PMR_SHA_CONFIG_IN_LEVEL_r       =  KAM_PMR_SHA_CONFIG_IN_LEVEL_q      ;    // Field : IN_LEVEL
    assign KAM_PMR_SHA_CONFIG_DMA_IN_r         =  KAM_PMR_SHA_CONFIG_DMA_IN_q        ;    // Field : DMA_IN
    assign KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_r   =  KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_q  ;    // Field : BYTE_SWAP_IN
    assign KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_r  =  KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_q ;    // Field : BYTE_SWAP_OUT
    
    
    assign KAM_PMR_SHA_CONFIG_rd_data = KAM_PMR_SHA_CONFIG_rd_valid ? {1'b0 ,KAM_PMR_SHA_CONFIG_MODE_q , 5'b0 ,KAM_PMR_SHA_CONFIG_KEY_SIZE_q , KAM_PMR_SHA_CONFIG_IN_LEVEL_q , 3'b0 ,KAM_PMR_SHA_CONFIG_DMA_IN_q , 2'b0 ,KAM_PMR_SHA_CONFIG_BYTE_SWAP_IN_q , KAM_PMR_SHA_CONFIG_BYTE_SWAP_OUT_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_PMR_SHA_INTR
    // ADDRESS       :  block_offset+'h62C                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      4:4 : VERIFY_DONE  ( SW : Read-Write HW : Read-Write )
    //      3:3 : GEN_DONE     ( SW : Read-Write HW : Read-Write )
    //      2:2 : IN_FIFO_AE   ( SW : Read-Write HW : Read-Write )
    //      1:1 : ERR          ( SW : Read-Write HW : Read-Write )
    //      0:0 : ALERT        ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_PMR_SHA_INTR_wr_valid = KAM_PMR_SHA_INTR_decode && wr_stb && KAM_PMR_SHA_INTR_wprot;
    assign KAM_PMR_SHA_INTR_rd_valid = KAM_PMR_SHA_INTR_decode && rd_stb && KAM_PMR_SHA_INTR_rprot;
    assign KAM_PMR_SHA_INTR_offset = block_offset+'h62C;
    assign KAM_PMR_SHA_INTR_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_PMR_SHA_INTR_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : VERIFY_DONE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Verify done interrupt Status indicatinga hash digest verification following SHA_VERIFY command is complete.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_INTR_VERIFY_DONE_q  <=1'd0;
            end
        else
            begin
            if (KAM_PMR_SHA_INTR_VERIFY_DONE_in_enb)   // VERIFY_DONE : HW Write
                begin
                    KAM_PMR_SHA_INTR_VERIFY_DONE_q <= KAM_PMR_SHA_INTR_VERIFY_DONE_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_INTR_wr_valid)   // VERIFY_DONE : SW Write
                    begin
                        KAM_PMR_SHA_INTR_VERIFY_DONE_q <=  ( wr_data[4] & reg_enb[4] ) | (KAM_PMR_SHA_INTR_VERIFY_DONE_q & (~reg_enb[4]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : GEN_DONE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Generate done interrupt Status indicating a hash digest or context data is generated following SHA_GEN_DIGEST or SHA_GEN_CONTEXT commands
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_INTR_GEN_DONE_q     <=1'd0;
            end
        else
            begin
            if (KAM_PMR_SHA_INTR_GEN_DONE_in_enb)   // GEN_DONE : HW Write
                begin
                    KAM_PMR_SHA_INTR_GEN_DONE_q <= KAM_PMR_SHA_INTR_GEN_DONE_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_INTR_wr_valid)   // GEN_DONE : SW Write
                    begin
                        KAM_PMR_SHA_INTR_GEN_DONE_q <=  ( wr_data[3] & reg_enb[3] ) | (KAM_PMR_SHA_INTR_GEN_DONE_q & (~reg_enb[3]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : IN_FIFO_AE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Input FIFO almost empty interrupt The event driving this status can only be changed by software pushing the input FIFO or hardware popping the input FIFO
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_INTR_IN_FIFO_AE_q   <=1'd1;
            end
        else
            begin
            if (KAM_PMR_SHA_INTR_IN_FIFO_AE_in_enb)   // IN_FIFO_AE : HW Write
                begin
                    KAM_PMR_SHA_INTR_IN_FIFO_AE_q <= KAM_PMR_SHA_INTR_IN_FIFO_AE_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_INTR_wr_valid)   // IN_FIFO_AE : SW Write
                    begin
                        KAM_PMR_SHA_INTR_IN_FIFO_AE_q <=  ( wr_data[2] & reg_enb[2] ) | (KAM_PMR_SHA_INTR_IN_FIFO_AE_q & (~reg_enb[2]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ERR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Error interrupt Status indicating an error has been detected. This bit is a consolidation(OR)of all error events in SHA_ERR_STATUS. The event driving this status can only be changed by software resetting the block.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_INTR_ERR_q          <=1'd0;
            end
        else
            begin
            if (KAM_PMR_SHA_INTR_ERR_in_enb)   // ERR : HW Write
                begin
                    KAM_PMR_SHA_INTR_ERR_q <= KAM_PMR_SHA_INTR_ERR_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_INTR_wr_valid)   // ERR : SW Write
                    begin
                        KAM_PMR_SHA_INTR_ERR_q <=  ( wr_data[1] & reg_enb[1] ) | (KAM_PMR_SHA_INTR_ERR_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ALERT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  Alert interrupt An security relevant error has been detected. This bit is a consolidation (OR) of all alert events in SHA_ALERT_STATUS. The event driving this status can only be changed by software resetting the block.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_PMR_SHA_INTR_ALERT_q        <=1'd0;
            end
        else
            begin
            if (KAM_PMR_SHA_INTR_ALERT_in_enb)   // ALERT : HW Write
                begin
                    KAM_PMR_SHA_INTR_ALERT_q <= KAM_PMR_SHA_INTR_ALERT_in;
                end
            else
                begin
                    
                if (KAM_PMR_SHA_INTR_wr_valid)   // ALERT : SW Write
                    begin
                        KAM_PMR_SHA_INTR_ALERT_q <=  ( wr_data[0] & reg_enb[0] ) | (KAM_PMR_SHA_INTR_ALERT_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_PMR_SHA_INTR_VERIFY_DONE_r  =  KAM_PMR_SHA_INTR_VERIFY_DONE_q ;    // Field : VERIFY_DONE
    assign KAM_PMR_SHA_INTR_GEN_DONE_r     =  KAM_PMR_SHA_INTR_GEN_DONE_q    ;    // Field : GEN_DONE
    assign KAM_PMR_SHA_INTR_IN_FIFO_AE_r   =  KAM_PMR_SHA_INTR_IN_FIFO_AE_q  ;    // Field : IN_FIFO_AE
    assign KAM_PMR_SHA_INTR_ERR_r          =  KAM_PMR_SHA_INTR_ERR_q         ;    // Field : ERR
    assign KAM_PMR_SHA_INTR_ALERT_r        =  KAM_PMR_SHA_INTR_ALERT_q       ;    // Field : ALERT
    
    
    assign KAM_PMR_SHA_INTR_rd_data = KAM_PMR_SHA_INTR_rd_valid ? {27'b0 ,KAM_PMR_SHA_INTR_VERIFY_DONE_q , KAM_PMR_SHA_INTR_GEN_DONE_q , KAM_PMR_SHA_INTR_IN_FIFO_AE_q , KAM_PMR_SHA_INTR_ERR_q , KAM_PMR_SHA_INTR_ALERT_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_ECC_CTRL_PMR
    // ADDRESS       :  block_offset+'h630                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      3:3 : ERR_SB_INSERT  ( SW : Read-Write HW : Read-only )
    //      2:2 : ERR_DB_INSERT  ( SW : Read-Write HW : Read-only )
    //      1:1 : ERR_CLEAR      ( SW : Read-Write HW : Read-only )
    //      0:0 : ENABLE         ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_ECC_CTRL_PMR_wr_valid = KAM_ECC_CTRL_PMR_decode && wr_stb;
    assign KAM_ECC_CTRL_PMR_rd_valid = KAM_ECC_CTRL_PMR_decode && rd_stb;
    assign KAM_ECC_CTRL_PMR_offset = block_offset+'h630;
    assign KAM_ECC_CTRL_PMR_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_ECC_CTRL_PMR_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ERR_SB_INSERT
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :  When set, PMR write followed by read will cause correctable error on bit0 the PMR location
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_ECC_CTRL_PMR_ERR_SB_INSERT_q  <=1'd0;
            end
        else
            begin
                
            if (KAM_ECC_CTRL_PMR_wr_valid)   // ERR_SB_INSERT : SW Write
                begin
                    KAM_ECC_CTRL_PMR_ERR_SB_INSERT_q <=  ( wr_data[3] & reg_enb[3] ) | (KAM_ECC_CTRL_PMR_ERR_SB_INSERT_q & (~reg_enb[3]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ERR_DB_INSERT
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :  When set, PMR write followed by read will cause uncorrectable error on corresponding PMR location.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_ECC_CTRL_PMR_ERR_DB_INSERT_q  <=1'd0;
            end
        else
            begin
                
            if (KAM_ECC_CTRL_PMR_wr_valid)   // ERR_DB_INSERT : SW Write
                begin
                    KAM_ECC_CTRL_PMR_ERR_DB_INSERT_q <=  ( wr_data[2] & reg_enb[2] ) | (KAM_ECC_CTRL_PMR_ERR_DB_INSERT_q & (~reg_enb[2]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ERR_CLEAR
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :  When set, will clear any pending ERR_DB or ERR_SB status
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_ECC_CTRL_PMR_ERR_CLEAR_q      <=1'd0;
            end
        else
            begin
                
            if (KAM_ECC_CTRL_PMR_wr_valid)   // ERR_CLEAR : SW Write
                begin
                    KAM_ECC_CTRL_PMR_ERR_CLEAR_q <=  ( wr_data[1] & reg_enb[1] ) | (KAM_ECC_CTRL_PMR_ERR_CLEAR_q & (~reg_enb[1]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ENABLE
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :  1: enables ECC checking on the Instruction RAM memory. The PMR is protected with a 7-bit ECC per 32-bit word. Partial writes can never occur on PMR memory since PMR writes are only done by a hardware state machine.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_ECC_CTRL_PMR_ENABLE_q         <=1'd0;
            end
        else
            begin
                
            if (KAM_ECC_CTRL_PMR_wr_valid)   // ENABLE : SW Write
                begin
                    KAM_ECC_CTRL_PMR_ENABLE_q <=  ( wr_data[0] & reg_enb[0] ) | (KAM_ECC_CTRL_PMR_ENABLE_q & (~reg_enb[0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_ECC_CTRL_PMR_ERR_SB_INSERT_r  =  KAM_ECC_CTRL_PMR_ERR_SB_INSERT_q ;    // Field : ERR_SB_INSERT
    assign KAM_ECC_CTRL_PMR_ERR_DB_INSERT_r  =  KAM_ECC_CTRL_PMR_ERR_DB_INSERT_q ;    // Field : ERR_DB_INSERT
    assign KAM_ECC_CTRL_PMR_ERR_CLEAR_r      =  KAM_ECC_CTRL_PMR_ERR_CLEAR_q     ;    // Field : ERR_CLEAR
    assign KAM_ECC_CTRL_PMR_ENABLE_r         =  KAM_ECC_CTRL_PMR_ENABLE_q        ;    // Field : ENABLE
    
    
    assign KAM_ECC_CTRL_PMR_rd_data = KAM_ECC_CTRL_PMR_rd_valid ? {28'b0 ,KAM_ECC_CTRL_PMR_ERR_SB_INSERT_q , KAM_ECC_CTRL_PMR_ERR_DB_INSERT_q , KAM_ECC_CTRL_PMR_ERR_CLEAR_q , KAM_ECC_CTRL_PMR_ENABLE_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_ECC_STATUS_PMR
    // ADDRESS       :  block_offset+'h634                WIDTH : 32
    // HW ACCESS     :  WRITE-ONLY
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //    31:31 : ERR_DB     ( SW : Read-only HW : Write-only )
    //    30:30 : ERR_SB     ( SW : Read-only HW : Write-only )
    //    27:24 : ERR_COUNT  ( SW : Read-only HW : Write-only )
    //    22:16 : ECC        ( SW : Read-only HW : Write-only )
    //     14:0 : ADDR       ( SW : Read-only HW : Write-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign KAM_ECC_STATUS_PMR_rd_valid = KAM_ECC_STATUS_PMR_decode && rd_stb;
    assign KAM_ECC_STATUS_PMR_offset = block_offset+'h634;
    assign KAM_ECC_STATUS_PMR_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_ECC_STATUS_PMR_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    assign KAM_ECC_STATUS_PMR_ERR_DB_q     = KAM_ECC_STATUS_PMR_ERR_DB_in    ;    // Field: ERR_DB
    assign KAM_ECC_STATUS_PMR_ERR_SB_q     = KAM_ECC_STATUS_PMR_ERR_SB_in    ;    // Field: ERR_SB
    assign KAM_ECC_STATUS_PMR_ERR_COUNT_q  = KAM_ECC_STATUS_PMR_ERR_COUNT_in ;    // Field: ERR_COUNT
    assign KAM_ECC_STATUS_PMR_ECC_q        = KAM_ECC_STATUS_PMR_ECC_in       ;    // Field: ECC
    assign KAM_ECC_STATUS_PMR_ADDR_q       = KAM_ECC_STATUS_PMR_ADDR_in      ;    // Field: ADDR
    
    
    assign KAM_ECC_STATUS_PMR_rd_data = KAM_ECC_STATUS_PMR_rd_valid ? {KAM_ECC_STATUS_PMR_ERR_DB_q , KAM_ECC_STATUS_PMR_ERR_SB_q , 2'b0 ,KAM_ECC_STATUS_PMR_ERR_COUNT_q , 1'b0 ,KAM_ECC_STATUS_PMR_ECC_q , 1'b0 ,KAM_ECC_STATUS_PMR_ADDR_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_ECC_LOG_PMR
    // ADDRESS       :  block_offset+'h638                WIDTH : 32
    // HW ACCESS     :  WRITE-ONLY
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     31:0 : DATA  ( SW : Read-only HW : Write-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    assign KAM_ECC_LOG_PMR_rd_valid = KAM_ECC_LOG_PMR_decode && rd_stb;
    assign KAM_ECC_LOG_PMR_offset = block_offset+'h638;
    assign KAM_ECC_LOG_PMR_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_ECC_LOG_PMR_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    assign KAM_ECC_LOG_PMR_DATA_q  = KAM_ECC_LOG_PMR_DATA_in ;    // Field: DATA
    
    
    assign KAM_ECC_LOG_PMR_rd_data = KAM_ECC_LOG_PMR_rd_valid ? {KAM_ECC_LOG_PMR_DATA_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_ERR_STATUS
    // ADDRESS       :  block_offset+'h63C                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:0 : SHA_UNAUTHORIZED  ( SW : Read-Write One to Clear HW : Read-Write )
    //      1:1 : PMR_EXTEND_ABORT  ( SW : Read-Write One to Clear HW : Read-Write )
    //      2:2 : ECC_SB_PMR        ( SW : Read-only               HW : Read-Write )
    //      3:3 : ECC_DB_PMR        ( SW : Read-only               HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_ERR_STATUS_wr_valid = KAM_ERR_STATUS_decode && wr_stb;
    assign KAM_ERR_STATUS_rd_valid = KAM_ERR_STATUS_decode && rd_stb;
    assign KAM_ERR_STATUS_offset = block_offset+'h63C;
    assign KAM_ERR_STATUS_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_ERR_STATUS_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : SHA_UNAUTHORIZED
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_ERR_STATUS_SHA_UNAUTHORIZED_q  <=1'd0;
            end
        else
            begin
                
            if( KAM_ERR_STATUS_SHA_UNAUTHORIZED_hw_set)    //set
                begin
                    KAM_ERR_STATUS_SHA_UNAUTHORIZED_q <= 1'b1;
                end
            else if (KAM_ERR_STATUS_SHA_UNAUTHORIZED_in_enb)   // SHA_UNAUTHORIZED : HW Write
                begin
                    KAM_ERR_STATUS_SHA_UNAUTHORIZED_q <= KAM_ERR_STATUS_SHA_UNAUTHORIZED_in;
                end
            else
                begin
                if (KAM_ERR_STATUS_wr_valid)   // SHA_UNAUTHORIZED : SW Write One to Clear
                    begin
                        KAM_ERR_STATUS_SHA_UNAUTHORIZED_q <=  KAM_ERR_STATUS_SHA_UNAUTHORIZED_q & ( ~( wr_data[0] & reg_enb[0] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PMR_EXTEND_ABORT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_ERR_STATUS_PMR_EXTEND_ABORT_q  <=1'd0;
            end
        else
            begin
                
            if( KAM_ERR_STATUS_PMR_EXTEND_ABORT_hw_set)    //set
                begin
                    KAM_ERR_STATUS_PMR_EXTEND_ABORT_q <= 1'b1;
                end
            else if (KAM_ERR_STATUS_PMR_EXTEND_ABORT_in_enb)   // PMR_EXTEND_ABORT : HW Write
                begin
                    KAM_ERR_STATUS_PMR_EXTEND_ABORT_q <= KAM_ERR_STATUS_PMR_EXTEND_ABORT_in;
                end
            else
                begin
                if (KAM_ERR_STATUS_wr_valid)   // PMR_EXTEND_ABORT : SW Write One to Clear
                    begin
                        KAM_ERR_STATUS_PMR_EXTEND_ABORT_q <=  KAM_ERR_STATUS_PMR_EXTEND_ABORT_q & ( ~( wr_data[1] & reg_enb[1] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ECC_SB_PMR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-ONLY                           OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_ERR_STATUS_ECC_SB_PMR_q        <=1'd0;
            end
        else
            begin
            if (KAM_ERR_STATUS_ECC_SB_PMR_in_enb)   // ECC_SB_PMR : HW Write
                begin
                    KAM_ERR_STATUS_ECC_SB_PMR_q <= KAM_ERR_STATUS_ECC_SB_PMR_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ECC_DB_PMR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-ONLY                           OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_ERR_STATUS_ECC_DB_PMR_q        <=1'd0;
            end
        else
            begin
            if (KAM_ERR_STATUS_ECC_DB_PMR_in_enb)   // ECC_DB_PMR : HW Write
                begin
                    KAM_ERR_STATUS_ECC_DB_PMR_q <= KAM_ERR_STATUS_ECC_DB_PMR_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_ERR_STATUS_SHA_UNAUTHORIZED_r  =  KAM_ERR_STATUS_SHA_UNAUTHORIZED_q ;    // Field : SHA_UNAUTHORIZED
    assign KAM_ERR_STATUS_PMR_EXTEND_ABORT_r  =  KAM_ERR_STATUS_PMR_EXTEND_ABORT_q ;    // Field : PMR_EXTEND_ABORT
    assign KAM_ERR_STATUS_ECC_SB_PMR_r        =  KAM_ERR_STATUS_ECC_SB_PMR_q       ;    // Field : ECC_SB_PMR
    assign KAM_ERR_STATUS_ECC_DB_PMR_r        =  KAM_ERR_STATUS_ECC_DB_PMR_q       ;    // Field : ECC_DB_PMR
    
    
    assign KAM_ERR_STATUS_rd_data = KAM_ERR_STATUS_rd_valid ? {28'b0 ,KAM_ERR_STATUS_ECC_DB_PMR_q , KAM_ERR_STATUS_ECC_SB_PMR_q , KAM_ERR_STATUS_PMR_EXTEND_ABORT_q , KAM_ERR_STATUS_SHA_UNAUTHORIZED_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_INTR_STATE
    // ADDRESS       :  block_offset+'h640                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      7:7 : OTPC_INT             ( SW : Read-Write One to Clear HW : Read-Write )
    //      6:6 : OTP_WRITE_DENY       ( SW : Read-Write One to Clear HW : Read-Write )
    //      5:5 : OTP_READ_DENY        ( SW : Read-Write One to Clear HW : Read-Write )
    //      4:4 : KV_WRITE_DENY        ( SW : Read-Write One to Clear HW : Read-Write )
    //      3:3 : KV_READ_DENY         ( SW : Read-Write One to Clear HW : Read-Write )
    //      2:2 : PMR_EXTEND_COMPLETE  ( SW : Read-Write One to Clear HW : Read-Write )
    //      1:1 : ERR                  ( SW : Read-Write One to Clear HW : Read-Write )
    //      0:0 : ALERT                ( SW : Read-Write One to Clear HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_INTR_STATE_wr_valid = KAM_INTR_STATE_decode && wr_stb;
    assign KAM_INTR_STATE_rd_valid = KAM_INTR_STATE_decode && rd_stb;
    assign KAM_INTR_STATE_offset = block_offset+'h640;
    assign KAM_INTR_STATE_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_INTR_STATE_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTPC_INT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_STATE_OTPC_INT_q             <=1'd0;
            end
        else
            begin
                
            if( KAM_INTR_STATE_OTPC_INT_hw_set)    //set
                begin
                    KAM_INTR_STATE_OTPC_INT_q <= 1'b1;
                end
            else if (KAM_INTR_STATE_OTPC_INT_in_enb)   // OTPC_INT : HW Write
                begin
                    KAM_INTR_STATE_OTPC_INT_q <= KAM_INTR_STATE_OTPC_INT_in;
                end
            else
                begin
                if (KAM_INTR_STATE_wr_valid)   // OTPC_INT : SW Write One to Clear
                    begin
                        KAM_INTR_STATE_OTPC_INT_q <=  KAM_INTR_STATE_OTPC_INT_q & ( ~( wr_data[7] & reg_enb[7] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTP_WRITE_DENY
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  6
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_STATE_OTP_WRITE_DENY_q       <=1'd0;
            end
        else
            begin
                
            if( KAM_INTR_STATE_OTP_WRITE_DENY_hw_set)    //set
                begin
                    KAM_INTR_STATE_OTP_WRITE_DENY_q <= 1'b1;
                end
            else if (KAM_INTR_STATE_OTP_WRITE_DENY_in_enb)   // OTP_WRITE_DENY : HW Write
                begin
                    KAM_INTR_STATE_OTP_WRITE_DENY_q <= KAM_INTR_STATE_OTP_WRITE_DENY_in;
                end
            else
                begin
                if (KAM_INTR_STATE_wr_valid)   // OTP_WRITE_DENY : SW Write One to Clear
                    begin
                        KAM_INTR_STATE_OTP_WRITE_DENY_q <=  KAM_INTR_STATE_OTP_WRITE_DENY_q & ( ~( wr_data[6] & reg_enb[6] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTP_READ_DENY
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  5
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_STATE_OTP_READ_DENY_q        <=1'd0;
            end
        else
            begin
                
            if( KAM_INTR_STATE_OTP_READ_DENY_hw_set)    //set
                begin
                    KAM_INTR_STATE_OTP_READ_DENY_q <= 1'b1;
                end
            else if (KAM_INTR_STATE_OTP_READ_DENY_in_enb)   // OTP_READ_DENY : HW Write
                begin
                    KAM_INTR_STATE_OTP_READ_DENY_q <= KAM_INTR_STATE_OTP_READ_DENY_in;
                end
            else
                begin
                if (KAM_INTR_STATE_wr_valid)   // OTP_READ_DENY : SW Write One to Clear
                    begin
                        KAM_INTR_STATE_OTP_READ_DENY_q <=  KAM_INTR_STATE_OTP_READ_DENY_q & ( ~( wr_data[5] & reg_enb[5] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KV_WRITE_DENY
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_STATE_KV_WRITE_DENY_q        <=1'd0;
            end
        else
            begin
                
            if( KAM_INTR_STATE_KV_WRITE_DENY_hw_set)    //set
                begin
                    KAM_INTR_STATE_KV_WRITE_DENY_q <= 1'b1;
                end
            else if (KAM_INTR_STATE_KV_WRITE_DENY_in_enb)   // KV_WRITE_DENY : HW Write
                begin
                    KAM_INTR_STATE_KV_WRITE_DENY_q <= KAM_INTR_STATE_KV_WRITE_DENY_in;
                end
            else
                begin
                if (KAM_INTR_STATE_wr_valid)   // KV_WRITE_DENY : SW Write One to Clear
                    begin
                        KAM_INTR_STATE_KV_WRITE_DENY_q <=  KAM_INTR_STATE_KV_WRITE_DENY_q & ( ~( wr_data[4] & reg_enb[4] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KV_READ_DENY
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_STATE_KV_READ_DENY_q         <=1'd0;
            end
        else
            begin
                
            if( KAM_INTR_STATE_KV_READ_DENY_hw_set)    //set
                begin
                    KAM_INTR_STATE_KV_READ_DENY_q <= 1'b1;
                end
            else if (KAM_INTR_STATE_KV_READ_DENY_in_enb)   // KV_READ_DENY : HW Write
                begin
                    KAM_INTR_STATE_KV_READ_DENY_q <= KAM_INTR_STATE_KV_READ_DENY_in;
                end
            else
                begin
                if (KAM_INTR_STATE_wr_valid)   // KV_READ_DENY : SW Write One to Clear
                    begin
                        KAM_INTR_STATE_KV_READ_DENY_q <=  KAM_INTR_STATE_KV_READ_DENY_q & ( ~( wr_data[3] & reg_enb[3] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PMR_EXTEND_COMPLETE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_STATE_PMR_EXTEND_COMPLETE_q  <=1'd0;
            end
        else
            begin
                
            if( KAM_INTR_STATE_PMR_EXTEND_COMPLETE_hw_set)    //set
                begin
                    KAM_INTR_STATE_PMR_EXTEND_COMPLETE_q <= 1'b1;
                end
            else if (KAM_INTR_STATE_PMR_EXTEND_COMPLETE_in_enb)   // PMR_EXTEND_COMPLETE : HW Write
                begin
                    KAM_INTR_STATE_PMR_EXTEND_COMPLETE_q <= KAM_INTR_STATE_PMR_EXTEND_COMPLETE_in;
                end
            else
                begin
                if (KAM_INTR_STATE_wr_valid)   // PMR_EXTEND_COMPLETE : SW Write One to Clear
                    begin
                        KAM_INTR_STATE_PMR_EXTEND_COMPLETE_q <=  KAM_INTR_STATE_PMR_EXTEND_COMPLETE_q & ( ~( wr_data[2] & reg_enb[2] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ERR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_STATE_ERR_q                  <=1'd0;
            end
        else
            begin
                
            if( KAM_INTR_STATE_ERR_hw_set)    //set
                begin
                    KAM_INTR_STATE_ERR_q <= 1'b1;
                end
            else if (KAM_INTR_STATE_ERR_in_enb)   // ERR : HW Write
                begin
                    KAM_INTR_STATE_ERR_q <= KAM_INTR_STATE_ERR_in;
                end
            else
                begin
                if (KAM_INTR_STATE_wr_valid)   // ERR : SW Write One to Clear
                    begin
                        KAM_INTR_STATE_ERR_q <=  KAM_INTR_STATE_ERR_q & ( ~( wr_data[1] & reg_enb[1] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ALERT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_STATE_ALERT_q                <=1'd0;
            end
        else
            begin
                
            if( KAM_INTR_STATE_ALERT_hw_set)    //set
                begin
                    KAM_INTR_STATE_ALERT_q <= 1'b1;
                end
            else if (KAM_INTR_STATE_ALERT_in_enb)   // ALERT : HW Write
                begin
                    KAM_INTR_STATE_ALERT_q <= KAM_INTR_STATE_ALERT_in;
                end
            else
                begin
                if (KAM_INTR_STATE_wr_valid)   // ALERT : SW Write One to Clear
                    begin
                        KAM_INTR_STATE_ALERT_q <=  KAM_INTR_STATE_ALERT_q & ( ~( wr_data[0] & reg_enb[0] ));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_INTR_STATE_OTPC_INT_r             =  KAM_INTR_STATE_OTPC_INT_q            ;    // Field : OTPC_INT
    assign KAM_INTR_STATE_OTP_WRITE_DENY_r       =  KAM_INTR_STATE_OTP_WRITE_DENY_q      ;    // Field : OTP_WRITE_DENY
    assign KAM_INTR_STATE_OTP_READ_DENY_r        =  KAM_INTR_STATE_OTP_READ_DENY_q       ;    // Field : OTP_READ_DENY
    assign KAM_INTR_STATE_KV_WRITE_DENY_r        =  KAM_INTR_STATE_KV_WRITE_DENY_q       ;    // Field : KV_WRITE_DENY
    assign KAM_INTR_STATE_KV_READ_DENY_r         =  KAM_INTR_STATE_KV_READ_DENY_q        ;    // Field : KV_READ_DENY
    assign KAM_INTR_STATE_PMR_EXTEND_COMPLETE_r  =  KAM_INTR_STATE_PMR_EXTEND_COMPLETE_q ;    // Field : PMR_EXTEND_COMPLETE
    assign KAM_INTR_STATE_ERR_r                  =  KAM_INTR_STATE_ERR_q                 ;    // Field : ERR
    assign KAM_INTR_STATE_ALERT_r                =  KAM_INTR_STATE_ALERT_q               ;    // Field : ALERT
    
    
    assign KAM_INTR_STATE_rd_data = KAM_INTR_STATE_rd_valid ? {24'b0 ,KAM_INTR_STATE_OTPC_INT_q , KAM_INTR_STATE_OTP_WRITE_DENY_q , KAM_INTR_STATE_OTP_READ_DENY_q , KAM_INTR_STATE_KV_WRITE_DENY_q , KAM_INTR_STATE_KV_READ_DENY_q , KAM_INTR_STATE_PMR_EXTEND_COMPLETE_q , KAM_INTR_STATE_ERR_q , KAM_INTR_STATE_ALERT_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_INTR_ENABLE
    // ADDRESS       :  block_offset+'h644                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      7:7 : OTPC_INT             ( SW : Read-Write HW : Read-only )
    //      6:6 : OTP_WRITE_DENY       ( SW : Read-Write HW : Read-only )
    //      5:5 : OTP_READ_DENY        ( SW : Read-Write HW : Read-only )
    //      4:4 : KV_WRITE_DENY        ( SW : Read-Write HW : Read-only )
    //      3:3 : KV_READ_DENY         ( SW : Read-Write HW : Read-only )
    //      2:2 : PMR_EXTEND_COMPLETE  ( SW : Read-Write HW : Read-only )
    //      1:1 : ERR                  ( SW : Read-Write HW : Read-only )
    //      0:0 : ALERT                ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_INTR_ENABLE_wr_valid = KAM_INTR_ENABLE_decode && wr_stb;
    assign KAM_INTR_ENABLE_rd_valid = KAM_INTR_ENABLE_decode && rd_stb;
    assign KAM_INTR_ENABLE_offset = block_offset+'h644;
    assign KAM_INTR_ENABLE_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_INTR_ENABLE_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTPC_INT
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_ENABLE_OTPC_INT_q             <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_ENABLE_wr_valid)   // OTPC_INT : SW Write
                begin
                    KAM_INTR_ENABLE_OTPC_INT_q <=  ( wr_data[7] & reg_enb[7] ) | (KAM_INTR_ENABLE_OTPC_INT_q & (~reg_enb[7]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTP_WRITE_DENY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  6
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_ENABLE_OTP_WRITE_DENY_q       <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_ENABLE_wr_valid)   // OTP_WRITE_DENY : SW Write
                begin
                    KAM_INTR_ENABLE_OTP_WRITE_DENY_q <=  ( wr_data[6] & reg_enb[6] ) | (KAM_INTR_ENABLE_OTP_WRITE_DENY_q & (~reg_enb[6]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTP_READ_DENY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  5
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_ENABLE_OTP_READ_DENY_q        <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_ENABLE_wr_valid)   // OTP_READ_DENY : SW Write
                begin
                    KAM_INTR_ENABLE_OTP_READ_DENY_q <=  ( wr_data[5] & reg_enb[5] ) | (KAM_INTR_ENABLE_OTP_READ_DENY_q & (~reg_enb[5]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KV_WRITE_DENY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_ENABLE_KV_WRITE_DENY_q        <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_ENABLE_wr_valid)   // KV_WRITE_DENY : SW Write
                begin
                    KAM_INTR_ENABLE_KV_WRITE_DENY_q <=  ( wr_data[4] & reg_enb[4] ) | (KAM_INTR_ENABLE_KV_WRITE_DENY_q & (~reg_enb[4]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KV_READ_DENY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_ENABLE_KV_READ_DENY_q         <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_ENABLE_wr_valid)   // KV_READ_DENY : SW Write
                begin
                    KAM_INTR_ENABLE_KV_READ_DENY_q <=  ( wr_data[3] & reg_enb[3] ) | (KAM_INTR_ENABLE_KV_READ_DENY_q & (~reg_enb[3]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PMR_EXTEND_COMPLETE
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_ENABLE_PMR_EXTEND_COMPLETE_q  <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_ENABLE_wr_valid)   // PMR_EXTEND_COMPLETE : SW Write
                begin
                    KAM_INTR_ENABLE_PMR_EXTEND_COMPLETE_q <=  ( wr_data[2] & reg_enb[2] ) | (KAM_INTR_ENABLE_PMR_EXTEND_COMPLETE_q & (~reg_enb[2]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ERR
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_ENABLE_ERR_q                  <=1'd1;
            end
        else
            begin
                
            if (KAM_INTR_ENABLE_wr_valid)   // ERR : SW Write
                begin
                    KAM_INTR_ENABLE_ERR_q <=  ( wr_data[1] & reg_enb[1] ) | (KAM_INTR_ENABLE_ERR_q & (~reg_enb[1]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ALERT
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_ENABLE_ALERT_q                <=1'd1;
            end
        else
            begin
                
            if (KAM_INTR_ENABLE_wr_valid)   // ALERT : SW Write
                begin
                    KAM_INTR_ENABLE_ALERT_q <=  ( wr_data[0] & reg_enb[0] ) | (KAM_INTR_ENABLE_ALERT_q & (~reg_enb[0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_INTR_ENABLE_OTPC_INT_r             =  KAM_INTR_ENABLE_OTPC_INT_q            ;    // Field : OTPC_INT
    assign KAM_INTR_ENABLE_OTP_WRITE_DENY_r       =  KAM_INTR_ENABLE_OTP_WRITE_DENY_q      ;    // Field : OTP_WRITE_DENY
    assign KAM_INTR_ENABLE_OTP_READ_DENY_r        =  KAM_INTR_ENABLE_OTP_READ_DENY_q       ;    // Field : OTP_READ_DENY
    assign KAM_INTR_ENABLE_KV_WRITE_DENY_r        =  KAM_INTR_ENABLE_KV_WRITE_DENY_q       ;    // Field : KV_WRITE_DENY
    assign KAM_INTR_ENABLE_KV_READ_DENY_r         =  KAM_INTR_ENABLE_KV_READ_DENY_q        ;    // Field : KV_READ_DENY
    assign KAM_INTR_ENABLE_PMR_EXTEND_COMPLETE_r  =  KAM_INTR_ENABLE_PMR_EXTEND_COMPLETE_q ;    // Field : PMR_EXTEND_COMPLETE
    assign KAM_INTR_ENABLE_ERR_r                  =  KAM_INTR_ENABLE_ERR_q                 ;    // Field : ERR
    assign KAM_INTR_ENABLE_ALERT_r                =  KAM_INTR_ENABLE_ALERT_q               ;    // Field : ALERT
    
    
    assign KAM_INTR_ENABLE_rd_data = KAM_INTR_ENABLE_rd_valid ? {24'b0 ,KAM_INTR_ENABLE_OTPC_INT_q , KAM_INTR_ENABLE_OTP_WRITE_DENY_q , KAM_INTR_ENABLE_OTP_READ_DENY_q , KAM_INTR_ENABLE_KV_WRITE_DENY_q , KAM_INTR_ENABLE_KV_READ_DENY_q , KAM_INTR_ENABLE_PMR_EXTEND_COMPLETE_q , KAM_INTR_ENABLE_ERR_q , KAM_INTR_ENABLE_ALERT_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_INTR_TEST
    // ADDRESS       :  block_offset+'h648                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      7:7 : OTPC_INT             ( SW : Read-Write HW : Read-only )
    //      6:6 : OTP_WRITE_DENY       ( SW : Read-Write HW : Read-only )
    //      5:5 : OTP_READ_DENY        ( SW : Read-Write HW : Read-only )
    //      4:4 : KV_WRITE_DENY        ( SW : Read-Write HW : Read-only )
    //      3:3 : KV_READ_DENY         ( SW : Read-Write HW : Read-only )
    //      2:2 : PMR_EXTEND_COMPLETE  ( SW : Read-Write HW : Read-only )
    //      1:1 : ERR                  ( SW : Read-Write HW : Read-only )
    //      0:0 : ALERT                ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_INTR_TEST_wr_valid = KAM_INTR_TEST_decode && wr_stb;
    assign KAM_INTR_TEST_rd_valid = KAM_INTR_TEST_decode && rd_stb;
    assign KAM_INTR_TEST_offset = block_offset+'h648;
    assign KAM_INTR_TEST_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_INTR_TEST_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTPC_INT
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_TEST_OTPC_INT_q             <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_TEST_wr_valid)   // OTPC_INT : SW Write
                begin
                    KAM_INTR_TEST_OTPC_INT_q <=  ( wr_data[7] & reg_enb[7] ) | (KAM_INTR_TEST_OTPC_INT_q & (~reg_enb[7]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTP_WRITE_DENY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  6
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_TEST_OTP_WRITE_DENY_q       <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_TEST_wr_valid)   // OTP_WRITE_DENY : SW Write
                begin
                    KAM_INTR_TEST_OTP_WRITE_DENY_q <=  ( wr_data[6] & reg_enb[6] ) | (KAM_INTR_TEST_OTP_WRITE_DENY_q & (~reg_enb[6]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OTP_READ_DENY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  5
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_TEST_OTP_READ_DENY_q        <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_TEST_wr_valid)   // OTP_READ_DENY : SW Write
                begin
                    KAM_INTR_TEST_OTP_READ_DENY_q <=  ( wr_data[5] & reg_enb[5] ) | (KAM_INTR_TEST_OTP_READ_DENY_q & (~reg_enb[5]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KV_WRITE_DENY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_TEST_KV_WRITE_DENY_q        <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_TEST_wr_valid)   // KV_WRITE_DENY : SW Write
                begin
                    KAM_INTR_TEST_KV_WRITE_DENY_q <=  ( wr_data[4] & reg_enb[4] ) | (KAM_INTR_TEST_KV_WRITE_DENY_q & (~reg_enb[4]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : KV_READ_DENY
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_TEST_KV_READ_DENY_q         <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_TEST_wr_valid)   // KV_READ_DENY : SW Write
                begin
                    KAM_INTR_TEST_KV_READ_DENY_q <=  ( wr_data[3] & reg_enb[3] ) | (KAM_INTR_TEST_KV_READ_DENY_q & (~reg_enb[3]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PMR_EXTEND_COMPLETE
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_TEST_PMR_EXTEND_COMPLETE_q  <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_TEST_wr_valid)   // PMR_EXTEND_COMPLETE : SW Write
                begin
                    KAM_INTR_TEST_PMR_EXTEND_COMPLETE_q <=  ( wr_data[2] & reg_enb[2] ) | (KAM_INTR_TEST_PMR_EXTEND_COMPLETE_q & (~reg_enb[2]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ERR
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_TEST_ERR_q                  <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_TEST_wr_valid)   // ERR : SW Write
                begin
                    KAM_INTR_TEST_ERR_q <=  ( wr_data[1] & reg_enb[1] ) | (KAM_INTR_TEST_ERR_q & (~reg_enb[1]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ALERT
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_INTR_TEST_ALERT_q                <=1'd0;
            end
        else
            begin
                
            if (KAM_INTR_TEST_wr_valid)   // ALERT : SW Write
                begin
                    KAM_INTR_TEST_ALERT_q <=  ( wr_data[0] & reg_enb[0] ) | (KAM_INTR_TEST_ALERT_q & (~reg_enb[0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign KAM_INTR_TEST_OTPC_INT_r             =  KAM_INTR_TEST_OTPC_INT_q            ;    // Field : OTPC_INT
    assign KAM_INTR_TEST_OTP_WRITE_DENY_r       =  KAM_INTR_TEST_OTP_WRITE_DENY_q      ;    // Field : OTP_WRITE_DENY
    assign KAM_INTR_TEST_OTP_READ_DENY_r        =  KAM_INTR_TEST_OTP_READ_DENY_q       ;    // Field : OTP_READ_DENY
    assign KAM_INTR_TEST_KV_WRITE_DENY_r        =  KAM_INTR_TEST_KV_WRITE_DENY_q       ;    // Field : KV_WRITE_DENY
    assign KAM_INTR_TEST_KV_READ_DENY_r         =  KAM_INTR_TEST_KV_READ_DENY_q        ;    // Field : KV_READ_DENY
    assign KAM_INTR_TEST_PMR_EXTEND_COMPLETE_r  =  KAM_INTR_TEST_PMR_EXTEND_COMPLETE_q ;    // Field : PMR_EXTEND_COMPLETE
    assign KAM_INTR_TEST_ERR_r                  =  KAM_INTR_TEST_ERR_q                 ;    // Field : ERR
    assign KAM_INTR_TEST_ALERT_r                =  KAM_INTR_TEST_ALERT_q               ;    // Field : ALERT
    
    
    assign KAM_INTR_TEST_rd_data = KAM_INTR_TEST_rd_valid ? {24'b0 ,KAM_INTR_TEST_OTPC_INT_q , KAM_INTR_TEST_OTP_WRITE_DENY_q , KAM_INTR_TEST_OTP_READ_DENY_q , KAM_INTR_TEST_KV_WRITE_DENY_q , KAM_INTR_TEST_KV_READ_DENY_q , KAM_INTR_TEST_PMR_EXTEND_COMPLETE_q , KAM_INTR_TEST_ERR_q , KAM_INTR_TEST_ALERT_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_SCRATCH
    // ADDRESS       :  block_offset+'h64C                WIDTH : 32
    // HW ACCESS     :  NA
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : DATA  ( SW : Read-Write HW : NA )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign KAM_SCRATCH_wr_valid = KAM_SCRATCH_decode && wr_stb;
    assign KAM_SCRATCH_rd_valid = KAM_SCRATCH_decode && rd_stb;
    assign KAM_SCRATCH_offset = block_offset+'h64C;
    assign KAM_SCRATCH_decode  = (address[ROT_KAM_regs_address_width-1 : 0]    == KAM_SCRATCH_offset[ROT_KAM_regs_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DATA
    // HW ACCESS  :  NA                          WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                
                KAM_SCRATCH_DATA_q  <=32'd0;
            end
        else
            begin
                
            if (KAM_SCRATCH_wr_valid)   // DATA : SW Write
                begin
                    KAM_SCRATCH_DATA_q <=  ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (KAM_SCRATCH_DATA_q & (~reg_enb[31 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    
    assign KAM_SCRATCH_rd_data = KAM_SCRATCH_rd_valid ? {KAM_SCRATCH_DATA_q} : 32'b00000000000000000000000000000000;
    
    
    generate
        genvar KAM_PMR_STATUS_i;
        for( KAM_PMR_STATUS_i = 0; KAM_PMR_STATUS_i < KAM_PMR_STATUS_count; KAM_PMR_STATUS_i = KAM_PMR_STATUS_i + 1)
        begin : KAM_PMR_STATUS_gen
            
            
            //----------------------------------------------------------------------------------------------------
            // REGISTER      :  KAM_PMR_STATUS
            // ADDRESS       :  block_offset+'h600 + KAM_PMR_STATUS_i * 'h4                WIDTH : 32
            // HW ACCESS     :  WRITE-ONLY
            // SW ACCESS     :  READ-ONLY
            //
            // FIELDS   :
            //     15:0 : PMR_VALID  ( SW : Read-only HW : Write-only )
            
            //-----------------------------------------------------------------------------
            // DESCRIPTION  :  NA
            //
            
            assign KAM_PMR_STATUS_rd_valid[KAM_PMR_STATUS_i] = KAM_PMR_STATUS_decode[KAM_PMR_STATUS_i] && rd_stb;
            assign KAM_PMR_STATUS_offset[KAM_PMR_STATUS_i] = block_offset+'h600 + KAM_PMR_STATUS_i * 'h4;
            assign KAM_PMR_STATUS_decode[KAM_PMR_STATUS_i]  = (address[KAM_PMR_STATUS_address_width-1 : 0]    == KAM_PMR_STATUS_offset[KAM_PMR_STATUS_i][KAM_PMR_STATUS_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            
            assign KAM_PMR_STATUS_PMR_VALID_q[KAM_PMR_STATUS_i]  = KAM_PMR_STATUS_PMR_VALID_in[(KAM_PMR_STATUS_i) *16+15 :  (KAM_PMR_STATUS_i) *16 ] ;    // Field: PMR_VALID
            
            
            assign KAM_PMR_STATUS_rd_data[KAM_PMR_STATUS_i] = KAM_PMR_STATUS_rd_valid[KAM_PMR_STATUS_i] ? {16'b0 ,KAM_PMR_STATUS_PMR_VALID_q[KAM_PMR_STATUS_i]} : 32'b00000000000000000000000000000000;
            
            
        end //KAM_PMR_STATUS_gen
    endgenerate
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_OTPC_CONTROL
    // ADDRESS       :  block_offset+'h0 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      1:1 : OTP_SOFT_RST     ( SW : Read-Write HW : Read-only )
    //      0:0 : OTP_CPU_MODE_EN  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_offset       = block_offset +'h0 + 'h0;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_decode &&  wr_stb;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_valid;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_valid;
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_data      = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_ack_in ? KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_OTPC_ADDRESS
    // ADDRESS       :  block_offset+'h0 + 'h4                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      6:0 : OTP_ADDR  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_offset       = block_offset +'h0 + 'h4;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_decode &&  wr_stb;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_valid;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_valid;
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_data      = KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_ack_in ? KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_OTPC_CONTROL0
    // ADDRESS       :  block_offset+'h0 + 'h8                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      5:1 : OTP_CMD  ( SW : Read-Write HW : Read-only )
    //      0:0 : START    ( SW : NA-Write   HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_offset       = block_offset +'h0 + 'h8;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_decode &&  wr_stb;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_valid;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_valid;
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_data      = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_ack_in ? KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_OTPC_STATUS0
    // ADDRESS       :  block_offset+'h0 + 'hC                WIDTH : 32
    // HW ACCESS     :  WRITE-ONLY
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //    23:23 : ECC_DED_FLAG_STATUS    ( SW : Read-only HW : Write-only )
    //    22:22 : ECC_SEC_FLAG_STATUS    ( SW : Read-only HW : Write-only )
    //    21:21 : ECC_CORRECTION_STATUS  ( SW : Read-only HW : Write-only )
    //    20:20 : PRESCREEN_FAIL         ( SW : Read-only HW : Write-only )
    //    19:19 : ADDR_IN_ILLEGAL_RANGE  ( SW : Read-only HW : Write-only )
    //    18:18 : MAX_SW                 ( SW : Read-only HW : Write-only )
    //    17:17 : AUTO_RW_MAX_SET        ( SW : Read-only HW : Write-only )
    //    16:16 : MAX_RWP                ( SW : Read-only HW : Write-only )
    //    15:15 : MAX_RW                 ( SW : Read-only HW : Write-only )
    //    14:14 : PRGM_WD_RP_FAIL        ( SW : Read-only HW : Write-only )
    //    13:13 : PROG_EN                ( SW : Read-only HW : Write-only )
    //    12:12 : PROG_BLOCK_CMD         ( SW : Read-only HW : Write-only )
    //    11:11 : PROG_SCREEN_FAIL       ( SW : Read-only HW : Write-only )
    //    10:10 : PROG_WORD_FAIL         ( SW : Read-only HW : Write-only )
    //      9:9 : INVALID_ADDR           ( SW : Read-only HW : Write-only )
    //      8:8 : DEBUG_ENABLE           ( SW : Read-only HW : Write-only )
    //      7:7 : MST_FSM_ERROR          ( SW : Read-only HW : Write-only )
    //      6:6 : DEBUG_MODE_SET         ( SW : Read-only HW : Write-only )
    //      5:5 : REFOK                  ( SW : Read-only HW : Write-only )
    //      4:4 : CMD_FAIL               ( SW : Read-only HW : Write-only )
    //      3:3 : FDONE                  ( SW : Read-only HW : Write-only )
    //      2:2 : PROGOK                 ( SW : Read-only HW : Write-only )
    //      1:1 : CMD_DONE               ( SW : Read-only HW : Write-only )
    //      0:0 : DATA_VALID             ( SW : Read-only HW : Write-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_offset       = block_offset +'h0 + 'hC;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_valid;
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_data      = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_ack_in ? KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_data_in : 32'b00000000000000000000000000000000;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_write_error  = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_decode && wr_stb;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_error = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_write_error;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_OTPC_STATUS1
    // ADDRESS       :  block_offset+'h0 + 'h10                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      0:0 : COMMAND_DONE  ( SW : Read-Write One to Clear HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_offset       = block_offset +'h0 + 'h10;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_decode &&  wr_stb;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_valid;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_valid;
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_data      = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_ack_in ? KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_offset       = (block_offset/'h8) +'h8;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_decode  = (address[ROT_KAM_regs_address_width - 1:3]  == KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_offset[(ROT_KAM_regs_address_width - 3) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_decode &&  wr_stb;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_valid;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_valid;
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_data      = KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_ack_in ? KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_READ_offset       = (block_offset/'h8) +'h10;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_READ_decode  = (address[ROT_KAM_regs_address_width - 1:3]  == KAM_OTP_OTPC_KAM_OTP_OTPC_READ_offset[(ROT_KAM_regs_address_width - 3) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_valid     = KAM_OTP_OTPC_KAM_OTP_OTPC_READ_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_valid_out = KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_valid;
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_data      = KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_ack_in ? KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_data_in : 32'b00000000000000000000000000000000;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_READ_write_error  = KAM_OTP_OTPC_KAM_OTP_OTPC_READ_decode && wr_stb;
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_EFC_CONTROL
    // ADDRESS       :  block_offset+'h100 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      6:6 : MR           ( SW : Read-Write HW : Read-only )
    //      5:5 : SWR          ( SW : Read-Write HW : Read-only )
    //      4:4 : IRQ_MODE     ( SW : Read-Write HW : Read-only )
    //      3:3 : IRQ_EN       ( SW : Read-Write HW : Read-only )
    //      2:2 : BYPASS_MODE  ( SW : Read-Write HW : Read-only )
    //      1:1 : START_RD     ( SW : Read-Write HW : Read-only )
    //      0:0 : START_PGM    ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_offset       = block_offset +'h100 + 'h0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_valid     = KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_decode &&  wr_stb;
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_valid     = KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_valid;
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_valid;
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_data      = KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_ack_in ? KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_EFC_BYPASS_CONTROL
    // ADDRESS       :  block_offset+'h100 + 'h4                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //    19:19 : PGEN     ( SW : Read-Write HW : Read-only )
    //    18:18 : LOAD     ( SW : Read-Write HW : Read-only )
    //    17:17 : STB      ( SW : Read-Write HW : Read-only )
    //    16:16 : CSB      ( SW : Read-Write HW : Read-only )
    //     15:0 : ADDRESS  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_offset       = block_offset +'h100 + 'h4;
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_valid     = KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_decode &&  wr_stb;
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_valid     = KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_valid;
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_valid;
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_data      = KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_ack_in ? KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_EFC_STATUS
    // ADDRESS       :  block_offset+'h100 + 'h8                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //    23:16 : CALCULATED_CRC_DATA  ( SW : Read-only               HW : Read-only )
    //      8:8 : CRC_MATCH            ( SW : Read-only               HW : Read-only )
    //      4:4 : IRQ_ST_RD_DONE       ( SW : Read-Write One to Clear HW : Read-only )
    //      3:3 : IRQ_ST_PGM_DONE      ( SW : Read-Write One to Clear HW : Read-only )
    //      2:2 : RD_FSM_BUSY          ( SW : Read-only               HW : Read-only )
    //      1:1 : PGM_FSM_BUSY         ( SW : Read-only               HW : Read-only )
    //      0:0 : FSM_BUSY             ( SW : Read-only               HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_offset       = block_offset +'h100 + 'h8;
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_EFC_KAM_OTP_EFC_STATUS_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_valid     = KAM_OTP_EFC_KAM_OTP_EFC_STATUS_decode &&  wr_stb;
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_valid     = KAM_OTP_EFC_KAM_OTP_EFC_STATUS_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_valid;
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_valid;
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_data      = KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_ack_in ? KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_EFC_POWER_CONTROLS
    // ADDRESS       :  block_offset+'h100 + 'hC                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      1:1 : PD  ( SW : Read-Write HW : Read-only )
    //      0:0 : PS  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_offset       = block_offset +'h100 + 'hC;
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_valid     = KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_decode &&  wr_stb;
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_valid     = KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_valid;
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_valid;
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_data      = KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_ack_in ? KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_EFC_ACCESS_TIMERS
    // ADDRESS       :  block_offset+'h100 + 'h10                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //    23:16 : HOLD_STROBE_1_TIMING   ( SW : Read-Write HW : Read-only )
    //     15:8 : SETUP_STROBE_0_TIMING  ( SW : Read-Write HW : Read-only )
    //      7:4 : CTRL_TO_STROBE_TIMING  ( SW : Read-Write HW : Read-only )
    //      3:0 : SETUP_HOLD_TIMING      ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_offset       = block_offset +'h100 + 'h10;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_valid     = KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_decode &&  wr_stb;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_valid     = KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_valid;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_valid;
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_data      = KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_ack_in ? KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_EFC_ADDRESS
    // ADDRESS       :  block_offset+'h100 + 'h14                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      7:0 : EFC_DW_ADDRESS  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_offset       = block_offset +'h100 + 'h14;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_valid     = KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_decode &&  wr_stb;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_valid     = KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_valid;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_valid;
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_data      = KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_ack_in ? KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_EFC_PGM_DATA
    // ADDRESS       :  block_offset+'h100 + 'h18                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : PGM_DATA  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_offset       = block_offset +'h100 + 'h18;
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_valid     = KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_decode &&  wr_stb;
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_valid     = KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_valid;
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_valid;
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_data      = KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_ack_in ? KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  KAM_OTP_EFC_RD_DATA
    // ADDRESS       :  block_offset+'h100 + 'h1C                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     31:0 : RD_DATA  ( SW : Read-only HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_offset       = block_offset +'h100 + 'h1C;
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_decode  = (address[ROT_KAM_regs_address_width - 1:0]  == KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_offset[(ROT_KAM_regs_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_valid     = KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_decode && rd_stb && rd_wait_state;
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_valid_out = KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_valid;
    
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_data      = KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_ack_in ? KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_data_in : 32'b00000000000000000000000000000000;
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_write_error  = KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_decode && wr_stb;
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_error = KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_write_error;
    
    
    
    
    
    
    
    
    
    
    generate
        genvar KAM_OTP_LANE_i;
        for( KAM_OTP_LANE_i = 0; KAM_OTP_LANE_i < KAM_OTP_LANE_count; KAM_OTP_LANE_i = KAM_OTP_LANE_i + 1)
        begin : KAM_OTP_LANE_gen
            
            
            //----------------------------------------------------------------------------------------------------
            // REGISTER      :  CONFIG
            // ADDRESS       :  block_offset+'h200 + KAM_OTP_LANE_i * 'hC + 'h0                WIDTH : 32
            // HW ACCESS     :  READ-ONLY
            // SW ACCESS     :  READ-WRITE
            //
            // FIELDS   :
            //    31:31 : LANE_ENABLE  ( SW : Read-Write HW : Read-only )
            //    21:16 : LANE_COUNT   ( SW : Read-Write HW : Read-only )
            //      9:0 : LANE_START   ( SW : Read-Write HW : Read-only )
            
            //-----------------------------------------------------------------------------
            // DESCRIPTION  :  Define a range of OTP rows for the OTP Access Filter. These fields cannot be written when KAM_LANE_ACCESS.OTP_LANE_LOCK is set. OTP Lanes should not overlap (i.e. and OTP Row should reside in 0 or 1 OTP Lanes) - but if an OTP row resides in more than one lane, any READ/PROPGRAM restriction in one lane will be honored
            //
            
            
            assign KAM_OTP_LANE_CONFIG_wr_valid[KAM_OTP_LANE_i] = KAM_OTP_LANE_CONFIG_decode[KAM_OTP_LANE_i] && wr_stb;
            assign KAM_OTP_LANE_CONFIG_rd_valid[KAM_OTP_LANE_i] = KAM_OTP_LANE_CONFIG_decode[KAM_OTP_LANE_i] && rd_stb;
            assign KAM_OTP_LANE_CONFIG_offset[KAM_OTP_LANE_i] = block_offset+'h200 + KAM_OTP_LANE_i * 'hC + 'h0;
            assign KAM_OTP_LANE_CONFIG_decode[KAM_OTP_LANE_i]  = (address[KAM_OTP_LANE_address_width-1 : 0]    == KAM_OTP_LANE_CONFIG_offset[KAM_OTP_LANE_i][KAM_OTP_LANE_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            
            
            //----------------------------------------------------------------------------
            // FIELD  : LANE_ENABLE
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
            // SW ACCESS  :  READ-WRITE                          OFFSET :  31
            //-----------------------------------------------------------------
            // DESCRIPTION   :  The OTP Lane range defined by ( LANE_START,LANE_COUNT ) is enabled
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_OTP_LANE_CONFIG_LANE_ENABLE_q[KAM_OTP_LANE_i] <=1'd0;
                    end
                else
                    begin
                        
                    if (KAM_OTP_LANE_CONFIG_wr_valid[KAM_OTP_LANE_i] && !((KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_i]) == 1'b1))   // LANE_ENABLE : SW Write FIXME manual hack for compile
                        begin
                            KAM_OTP_LANE_CONFIG_LANE_ENABLE_q[KAM_OTP_LANE_i] <=  ( wr_data[31] & reg_enb[31] ) | (KAM_OTP_LANE_CONFIG_LANE_ENABLE_q[KAM_OTP_LANE_i] & (~reg_enb[31]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : LANE_COUNT
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  6
            // SW ACCESS  :  READ-WRITE                          OFFSET :  16
            //-----------------------------------------------------------------
            // DESCRIPTION   :  LANE_COUNT specifies the number of OTP rows in the LANE Range
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_OTP_LANE_CONFIG_LANE_COUNT_q[KAM_OTP_LANE_i] <=6'd0;
                    end
                else
                    begin
                        
                    if (KAM_OTP_LANE_CONFIG_wr_valid[KAM_OTP_LANE_i] && !((KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_i]) == 1'b1))   // LANE_COUNT : SW Write FIXME manual hack for compile
                        begin
                            KAM_OTP_LANE_CONFIG_LANE_COUNT_q[KAM_OTP_LANE_i] <=  ( wr_data[21 : 16] & reg_enb[21 : 16] ) | (KAM_OTP_LANE_CONFIG_LANE_COUNT_q[KAM_OTP_LANE_i] & (~reg_enb[21 : 16]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : LANE_START
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  10
            // SW ACCESS  :  READ-WRITE                          OFFSET :  0
            //-----------------------------------------------------------------
            // DESCRIPTION   :  LANE_START field specifies OTP Row address of the OTP lane range.
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_OTP_LANE_CONFIG_LANE_START_q[KAM_OTP_LANE_i] <=10'd0;
                    end
                else
                    begin
                        
                    if (KAM_OTP_LANE_CONFIG_wr_valid[KAM_OTP_LANE_i] && !((KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_i]) == 1'b1))   // LANE_START : SW Write FIXME manual hack for compile
                        begin
                            KAM_OTP_LANE_CONFIG_LANE_START_q[KAM_OTP_LANE_i] <=  ( wr_data[9 : 0] & reg_enb[9 : 0] ) | (KAM_OTP_LANE_CONFIG_LANE_START_q[KAM_OTP_LANE_i] & (~reg_enb[9 : 0]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            // ===================================================
            // HW OUTPUT READ DATA FOR EACH FIELD
            assign KAM_OTP_LANE_CONFIG_LANE_ENABLE_r[KAM_OTP_LANE_i] =  KAM_OTP_LANE_CONFIG_LANE_ENABLE_q[KAM_OTP_LANE_i];    // Field : LANE_ENABLE
            assign KAM_OTP_LANE_CONFIG_LANE_COUNT_r[(KAM_OTP_LANE_i) *6+5 :  (KAM_OTP_LANE_i) *6 ] =  KAM_OTP_LANE_CONFIG_LANE_COUNT_q[KAM_OTP_LANE_i];    // Field : LANE_COUNT
            assign KAM_OTP_LANE_CONFIG_LANE_START_r[(KAM_OTP_LANE_i) *10+9 :  (KAM_OTP_LANE_i) *10 ] =  KAM_OTP_LANE_CONFIG_LANE_START_q[KAM_OTP_LANE_i];    // Field : LANE_START
            
            
            assign KAM_OTP_LANE_CONFIG_rd_data[KAM_OTP_LANE_i] = KAM_OTP_LANE_CONFIG_rd_valid[KAM_OTP_LANE_i] ? {KAM_OTP_LANE_CONFIG_LANE_ENABLE_q[KAM_OTP_LANE_i] , 9'b0 ,KAM_OTP_LANE_CONFIG_LANE_COUNT_q[KAM_OTP_LANE_i] , 6'b0 ,KAM_OTP_LANE_CONFIG_LANE_START_q[KAM_OTP_LANE_i]} : 32'b00000000000000000000000000000000;
            
            
            //----------------------------------------------------------------------------------------------------
            // REGISTER      :  ACCESS
            // ADDRESS       :  block_offset+'h200 + KAM_OTP_LANE_i * 'hC + 'h4                WIDTH : 32
            // HW ACCESS     :  READ-ONLY
            // SW ACCESS     :  READ-WRITE
            //
            // FIELDS   :
            //      2:2 : OTP_LANE_LOCK  ( SW : Read-Write HW : NA )
            //      1:1 : RE             ( SW : Read-Write HW : Read-only )
            //      0:0 : WE             ( SW : Read-Write HW : Read-only )
            
            //-----------------------------------------------------------------------------
            // DESCRIPTION  :  Firmware programs the accesibility of OTP LANE[i] . When LCM_MODE == PRODUCTION, and when the KAM_OAF_EN OTP Hardware Control bit is set, <li> when 0, RE and WE restrict read and write access of an OTP Lane <li> once RE/WE = 0, they are latched low
            //
            
            
            assign KAM_OTP_LANE_ACCESS_wr_valid[KAM_OTP_LANE_i] = KAM_OTP_LANE_ACCESS_decode[KAM_OTP_LANE_i] && wr_stb;
            assign KAM_OTP_LANE_ACCESS_rd_valid[KAM_OTP_LANE_i] = KAM_OTP_LANE_ACCESS_decode[KAM_OTP_LANE_i] && rd_stb;
            assign KAM_OTP_LANE_ACCESS_offset[KAM_OTP_LANE_i] = block_offset+'h200 + KAM_OTP_LANE_i * 'hC + 'h4;
            assign KAM_OTP_LANE_ACCESS_decode[KAM_OTP_LANE_i]  = (address[KAM_OTP_LANE_address_width-1 : 0]    == KAM_OTP_LANE_ACCESS_offset[KAM_OTP_LANE_i][KAM_OTP_LANE_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            
            
            //----------------------------------------------------------------------------
            // FIELD  : OTP_LANE_LOCK
            // HW ACCESS  :  NA                          WIDTH  :  1
            // SW ACCESS  :  READ-WRITE                          OFFSET :  2
            //-----------------------------------------------------------------
            // DESCRIPTION   :  When this bit is set, KAM_OTP_LANE cannot be modified Like RE and WE, this field cannot be cleared when LCM_MODE==PRODUCTION and HW Control KAM_OAF_EN == 1
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_i] <=1'd0;
                    end
                else
                    begin
                        
                    if (KAM_OTP_LANE_ACCESS_wr_valid[KAM_OTP_LANE_i] && !((((KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_i]) == 1'b0) && ((KAM_OTP_HW_CONTROL_LCM_MODE_q) == 1'b1)) && ((KAM_OTP_HW_CONTROL_KAM_OAF_EN_q) == 1'b1)))   // OTP_LANE_LOCK : SW Write FIXME manual hack for compile
                        begin
                            KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_i] <=  ( wr_data[2] & reg_enb[2] ) | (KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_i] & (~reg_enb[2]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : RE
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
            // SW ACCESS  :  READ-WRITE                          OFFSET :  1
            //-----------------------------------------------------------------
            // DESCRIPTION   :  1: Enabled range has read permissions 0: Enable range is not readable (i.e. reads return 0 + read_deny interrupt)
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_OTP_LANE_ACCESS_RE_q[KAM_OTP_LANE_i] <=1'd1;
                    end
                else
                    begin
                        
                    if (KAM_OTP_LANE_ACCESS_wr_valid[KAM_OTP_LANE_i] && !((((KAM_OTP_LANE_ACCESS_RE_q[KAM_OTP_LANE_i]) == 1'b0) && ((KAM_OTP_HW_CONTROL_LCM_MODE_q) == 1'b1)) && ((KAM_OTP_HW_CONTROL_KAM_OAF_EN_q) == 1'b1)))   // RE : SW Write FIXME manual hack for compile
                        begin
                            KAM_OTP_LANE_ACCESS_RE_q[KAM_OTP_LANE_i] <=  ( wr_data[1] & reg_enb[1] ) | (KAM_OTP_LANE_ACCESS_RE_q[KAM_OTP_LANE_i] & (~reg_enb[1]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : WE
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
            // SW ACCESS  :  READ-WRITE                          OFFSET :  0
            //-----------------------------------------------------------------
            // DESCRIPTION   :  1: Enabled range has write permissions 0: Enable range is not writable (i.e. write ignored + write_deny interrupt)
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_OTP_LANE_ACCESS_WE_q[KAM_OTP_LANE_i] <=1'd1;
                    end
                else
                    begin
                        
                    if (KAM_OTP_LANE_ACCESS_wr_valid[KAM_OTP_LANE_i] && !((((KAM_OTP_LANE_ACCESS_WE_q[KAM_OTP_LANE_i]) == 1'b0) && ((KAM_OTP_HW_CONTROL_LCM_MODE_q) == 1'b1)) && ((KAM_OTP_HW_CONTROL_KAM_OAF_EN_q) == 1'b1)))   // WE : SW Write FIXME manual hack for compile
                        begin
                            KAM_OTP_LANE_ACCESS_WE_q[KAM_OTP_LANE_i] <=  ( wr_data[0] & reg_enb[0] ) | (KAM_OTP_LANE_ACCESS_WE_q[KAM_OTP_LANE_i] & (~reg_enb[0]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            // ===================================================
            // HW OUTPUT READ DATA FOR EACH FIELD
            assign KAM_OTP_LANE_ACCESS_RE_r[KAM_OTP_LANE_i] =  KAM_OTP_LANE_ACCESS_RE_q[KAM_OTP_LANE_i];    // Field : RE
            assign KAM_OTP_LANE_ACCESS_WE_r[KAM_OTP_LANE_i] =  KAM_OTP_LANE_ACCESS_WE_q[KAM_OTP_LANE_i];    // Field : WE
            
            
            assign KAM_OTP_LANE_ACCESS_rd_data[KAM_OTP_LANE_i] = KAM_OTP_LANE_ACCESS_rd_valid[KAM_OTP_LANE_i] ? {29'b0 ,KAM_OTP_LANE_ACCESS_OTP_LANE_LOCK_q[KAM_OTP_LANE_i] , KAM_OTP_LANE_ACCESS_RE_q[KAM_OTP_LANE_i] , KAM_OTP_LANE_ACCESS_WE_q[KAM_OTP_LANE_i]} : 32'b00000000000000000000000000000000;
            
            
            //----------------------------------------------------------------------------------------------------
            // REGISTER      :  STATUS
            // ADDRESS       :  block_offset+'h200 + KAM_OTP_LANE_i * 'hC + 'h8                WIDTH : 32
            // HW ACCESS     :  READ-WRITE
            // SW ACCESS     :  READ-WRITE
            //
            // FIELDS   :
            //      1:1 : WRITE_DENY  ( SW : Read-Write One to Clear HW : Read-Write )
            //      0:0 : READ_DENY   ( SW : Read-Write One to Clear HW : Read-Write )
            
            //-----------------------------------------------------------------------------
            // DESCRIPTION  :  NA
            //
            
            
            assign KAM_OTP_LANE_STATUS_wr_valid[KAM_OTP_LANE_i] = KAM_OTP_LANE_STATUS_decode[KAM_OTP_LANE_i] && wr_stb;
            assign KAM_OTP_LANE_STATUS_rd_valid[KAM_OTP_LANE_i] = KAM_OTP_LANE_STATUS_decode[KAM_OTP_LANE_i] && rd_stb;
            assign KAM_OTP_LANE_STATUS_offset[KAM_OTP_LANE_i] = block_offset+'h200 + KAM_OTP_LANE_i * 'hC + 'h8;
            assign KAM_OTP_LANE_STATUS_decode[KAM_OTP_LANE_i]  = (address[KAM_OTP_LANE_address_width-1 : 0]    == KAM_OTP_LANE_STATUS_offset[KAM_OTP_LANE_i][KAM_OTP_LANE_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            
            
            //----------------------------------------------------------------------------
            // FIELD  : WRITE_DENY
            // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
            // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  1
            //-----------------------------------------------------------------
            // DESCRIPTION   :  A program command to OTP matched OTP LANE[i] with LANE_ENABLE == 1 && WE == 0
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_OTP_LANE_STATUS_WRITE_DENY_q[KAM_OTP_LANE_i] <=1'd0;
                    end
                else
                    begin
                        
                    if( KAM_OTP_LANE_STATUS_WRITE_DENY_hw_set[KAM_OTP_LANE_i])    //set
                        begin
                            KAM_OTP_LANE_STATUS_WRITE_DENY_q[KAM_OTP_LANE_i] <= 1'b1;
                        end
                    else if (KAM_OTP_LANE_STATUS_WRITE_DENY_in_enb[KAM_OTP_LANE_i])   // WRITE_DENY : HW Write
                        begin
                            KAM_OTP_LANE_STATUS_WRITE_DENY_q[KAM_OTP_LANE_i] <= KAM_OTP_LANE_STATUS_WRITE_DENY_in[KAM_OTP_LANE_i];
                        end
                    else
                        begin
                        if (KAM_OTP_LANE_STATUS_wr_valid[KAM_OTP_LANE_i])   // WRITE_DENY : SW Write One to Clear
                            begin
                                KAM_OTP_LANE_STATUS_WRITE_DENY_q[KAM_OTP_LANE_i] <=  KAM_OTP_LANE_STATUS_WRITE_DENY_q[KAM_OTP_LANE_i] & ( ~( wr_data[1] & reg_enb[1] ));
                            end
                            
                        end  // sw_write_close
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : READ_DENY
            // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
            // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  0
            //-----------------------------------------------------------------
            // DESCRIPTION   :  A read command to OTP matched an OTP LANE[i] with LANE_ENABLE == 1 && RE == 0
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_OTP_LANE_STATUS_READ_DENY_q[KAM_OTP_LANE_i] <=1'd0;
                    end
                else
                    begin
                        
                    if( KAM_OTP_LANE_STATUS_READ_DENY_hw_set[KAM_OTP_LANE_i])    //set
                        begin
                            KAM_OTP_LANE_STATUS_READ_DENY_q[KAM_OTP_LANE_i] <= 1'b1;
                        end
                    else if (KAM_OTP_LANE_STATUS_READ_DENY_in_enb[KAM_OTP_LANE_i])   // READ_DENY : HW Write
                        begin
                            KAM_OTP_LANE_STATUS_READ_DENY_q[KAM_OTP_LANE_i] <= KAM_OTP_LANE_STATUS_READ_DENY_in[KAM_OTP_LANE_i];
                        end
                    else
                        begin
                        if (KAM_OTP_LANE_STATUS_wr_valid[KAM_OTP_LANE_i])   // READ_DENY : SW Write One to Clear
                            begin
                                KAM_OTP_LANE_STATUS_READ_DENY_q[KAM_OTP_LANE_i] <=  KAM_OTP_LANE_STATUS_READ_DENY_q[KAM_OTP_LANE_i] & ( ~( wr_data[0] & reg_enb[0] ));
                            end
                            
                        end  // sw_write_close
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            // ===================================================
            // HW OUTPUT READ DATA FOR EACH FIELD
            assign KAM_OTP_LANE_STATUS_WRITE_DENY_r[KAM_OTP_LANE_i] =  KAM_OTP_LANE_STATUS_WRITE_DENY_q[KAM_OTP_LANE_i];    // Field : WRITE_DENY
            assign KAM_OTP_LANE_STATUS_READ_DENY_r[KAM_OTP_LANE_i] =  KAM_OTP_LANE_STATUS_READ_DENY_q[KAM_OTP_LANE_i];    // Field : READ_DENY
            
            
            assign KAM_OTP_LANE_STATUS_rd_data[KAM_OTP_LANE_i] = KAM_OTP_LANE_STATUS_rd_valid[KAM_OTP_LANE_i] ? {30'b0 ,KAM_OTP_LANE_STATUS_WRITE_DENY_q[KAM_OTP_LANE_i] , KAM_OTP_LANE_STATUS_READ_DENY_q[KAM_OTP_LANE_i]} : 32'b00000000000000000000000000000000;
            
            
        end //KAM_OTP_LANE_gen
    endgenerate
    
    
    
    
    
    
    
    
    
    generate
        genvar KAM_KV_i;
        for( KAM_KV_i = 0; KAM_KV_i < KAM_KV_count; KAM_KV_i = KAM_KV_i + 1)
        begin : KAM_KV_gen
            
            
            //----------------------------------------------------------------------------------------------------
            // REGISTER      :  RANGE
            // ADDRESS       :  block_offset+'h300 + KAM_KV_i * 'hC + 'h0                WIDTH : 32
            // HW ACCESS     :  READ-ONLY
            // SW ACCESS     :  READ-WRITE
            //
            // FIELDS   :
            //    31:31 : KV_ENABLE  ( SW : Read-Write HW : Read-only )
            //    23:16 : KV_COUNT   ( SW : Read-Write HW : Read-only )
            //     11:4 : KV_START   ( SW : Read-Write HW : Read-only )
            
            //-----------------------------------------------------------------------------
            // DESCRIPTION  :  Define a range in SCRATCH memory for Key Vault. These fields cannot be written when KAM_KV[i].ACCESS.KV_RANGE_LOCK is set
            //
            
            
            assign KAM_KV_RANGE_wr_valid[KAM_KV_i] = KAM_KV_RANGE_decode[KAM_KV_i] && wr_stb;
            assign KAM_KV_RANGE_rd_valid[KAM_KV_i] = KAM_KV_RANGE_decode[KAM_KV_i] && rd_stb;
            assign KAM_KV_RANGE_offset[KAM_KV_i] = block_offset+'h300 + KAM_KV_i * 'hC + 'h0;
            assign KAM_KV_RANGE_decode[KAM_KV_i]  = (address[KAM_KV_address_width-1 : 0]    == KAM_KV_RANGE_offset[KAM_KV_i][KAM_KV_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            
            
            //----------------------------------------------------------------------------
            // FIELD  : KV_ENABLE
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
            // SW ACCESS  :  READ-WRITE                          OFFSET :  31
            //-----------------------------------------------------------------
            // DESCRIPTION   :  The range defined by ( KV_START,KV_COUNT ) is enabled
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_KV_RANGE_KV_ENABLE_q[KAM_KV_i] <=1'd0;
                    end
                else
                    begin
                        
                    if (KAM_KV_RANGE_wr_valid[KAM_KV_i] && !((KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_i]) == 1'b1))   // KV_ENABLE : SW Write FIXME
                        begin
                            KAM_KV_RANGE_KV_ENABLE_q[KAM_KV_i] <=  ( wr_data[31] & reg_enb[31] ) | (KAM_KV_RANGE_KV_ENABLE_q[KAM_KV_i] & (~reg_enb[31]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : KV_COUNT
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  8
            // SW ACCESS  :  READ-WRITE                          OFFSET :  16
            //-----------------------------------------------------------------
            // DESCRIPTION   :  KV_COUNT specifies the number of 128-bit SCRATCH entries in the KV Range
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_KV_RANGE_KV_COUNT_q[KAM_KV_i] <=8'd0;
                    end
                else
                    begin
                        
                    if (KAM_KV_RANGE_wr_valid[KAM_KV_i] && !((KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_i]) == 1'b1))   // KV_COUNT : SW Write FIXME
                        begin
                            KAM_KV_RANGE_KV_COUNT_q[KAM_KV_i] <=  ( wr_data[23 : 16] & reg_enb[23 : 16] ) | (KAM_KV_RANGE_KV_COUNT_q[KAM_KV_i] & (~reg_enb[23 : 16]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : KV_START
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  8
            // SW ACCESS  :  READ-WRITE                          OFFSET :  4
            //-----------------------------------------------------------------
            // DESCRIPTION   :  KV_START field specifies the 128-bit start address of the range from the start of SCRATCH memory. The byte address may be written from [11:0] and the bottom 4 bits will be zero regardless of what was written.
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_KV_RANGE_KV_START_q[KAM_KV_i] <=8'd0;
                    end
                else
                    begin
                        
                    if (KAM_KV_RANGE_wr_valid[KAM_KV_i] && !((KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_i]) == 1'b1))   // KV_START : SW Write FIXME
                        begin
                            KAM_KV_RANGE_KV_START_q[KAM_KV_i] <=  ( wr_data[11 : 4] & reg_enb[11 : 4] ) | (KAM_KV_RANGE_KV_START_q[KAM_KV_i] & (~reg_enb[11 : 4]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            // ===================================================
            // HW OUTPUT READ DATA FOR EACH FIELD
            assign KAM_KV_RANGE_KV_ENABLE_r[KAM_KV_i] =  KAM_KV_RANGE_KV_ENABLE_q[KAM_KV_i];    // Field : KV_ENABLE
            assign KAM_KV_RANGE_KV_COUNT_r[(KAM_KV_i) *8+7 :  (KAM_KV_i) *8 ] =  KAM_KV_RANGE_KV_COUNT_q[KAM_KV_i];    // Field : KV_COUNT
            assign KAM_KV_RANGE_KV_START_r[(KAM_KV_i) *8+7 :  (KAM_KV_i) *8 ] =  KAM_KV_RANGE_KV_START_q[KAM_KV_i];    // Field : KV_START
            
            
            assign KAM_KV_RANGE_rd_data[KAM_KV_i] = KAM_KV_RANGE_rd_valid[KAM_KV_i] ? {KAM_KV_RANGE_KV_ENABLE_q[KAM_KV_i] , 7'b0 ,KAM_KV_RANGE_KV_COUNT_q[KAM_KV_i] , 4'b0 ,KAM_KV_RANGE_KV_START_q[KAM_KV_i] , 4'b0} : 32'b00000000000000000000000000000000;
            
            
            //----------------------------------------------------------------------------------------------------
            // REGISTER      :  ACCESS
            // ADDRESS       :  block_offset+'h300 + KAM_KV_i * 'hC + 'h4                WIDTH : 32
            // HW ACCESS     :  READ-ONLY
            // SW ACCESS     :  READ-WRITE
            //
            // FIELDS   :
            //      2:2 : KV_RANGE_LOCK  ( SW : Read-Write HW : NA )
            //      1:1 : RE             ( SW : Read-Write HW : Read-only )
            //      0:0 : WE             ( SW : Read-Write HW : Read-only )
            
            //-----------------------------------------------------------------------------
            // DESCRIPTION  :  Firmware programs the accesibility of KV range[i] (in SCRATCH RAM). When LCM_MODE == PRODUCTION, and when the KAM_KV_EN OTP Hardware Control bit is set, <li> RE and WE restrict read and write access of a range when not set <li> once RE/WE = 0, they are latched low
            //
            
            
            assign KAM_KV_ACCESS_wr_valid[KAM_KV_i] = KAM_KV_ACCESS_decode[KAM_KV_i] && wr_stb;
            assign KAM_KV_ACCESS_rd_valid[KAM_KV_i] = KAM_KV_ACCESS_decode[KAM_KV_i] && rd_stb;
            assign KAM_KV_ACCESS_offset[KAM_KV_i] = block_offset+'h300 + KAM_KV_i * 'hC + 'h4;
            assign KAM_KV_ACCESS_decode[KAM_KV_i]  = (address[KAM_KV_address_width-1 : 0]    == KAM_KV_ACCESS_offset[KAM_KV_i][KAM_KV_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            
            
            //----------------------------------------------------------------------------
            // FIELD  : KV_RANGE_LOCK
            // HW ACCESS  :  NA                          WIDTH  :  1
            // SW ACCESS  :  READ-WRITE                          OFFSET :  2
            //-----------------------------------------------------------------
            // DESCRIPTION   :  When this bit is set, KAM_KV_RANGE cannot be modified Like RE and WE, this field cannot be cleared when LCM_MODE==PRODUCTION and HW Control KAM_KV_EN == 1
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_i] <=1'd0;
                    end
                else
                    begin
                        
                    if (KAM_KV_ACCESS_wr_valid[KAM_KV_i] && !((((KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_i]) == 1'b0) && ((KAM_OTP_HW_CONTROL_LCM_MODE_q) == 1'b1)) && ((KAM_OTP_HW_CONTROL_KAM_KV_EN_q) == 1'b1)))   // KV_RANGE_LOCK : SW Write FIXME
                        begin
                            KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_i] <=  ( wr_data[2] & reg_enb[2] ) | (KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_i] & (~reg_enb[2]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : RE
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
            // SW ACCESS  :  READ-WRITE                          OFFSET :  1
            //-----------------------------------------------------------------
            // DESCRIPTION   :  1: Enabled range has read permissions 0: Enable range is not readable (i.e. reads return 0 + read_deny interrupt)
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_KV_ACCESS_RE_q[KAM_KV_i]      <=1'd1;
                    end
                else
                    begin
                        
                    if (KAM_KV_ACCESS_wr_valid[KAM_KV_i] && !((((KAM_KV_ACCESS_RE_q[KAM_KV_i]) == 1'b0) && ((KAM_OTP_HW_CONTROL_LCM_MODE_q) == 1'b1)) && ((KAM_OTP_HW_CONTROL_KAM_KV_EN_q) == 1'b1)))   // RE : SW Write FIXME
                        begin
                            KAM_KV_ACCESS_RE_q[KAM_KV_i] <=  ( wr_data[1] & reg_enb[1] ) | (KAM_KV_ACCESS_RE_q[KAM_KV_i] & (~reg_enb[1]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : WE
            // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
            // SW ACCESS  :  READ-WRITE                          OFFSET :  0
            //-----------------------------------------------------------------
            // DESCRIPTION   :  1: Enabled range has write permissions 0: Enable range is not writable (i.e. write ignored + write_deny interrupt)
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_KV_ACCESS_WE_q[KAM_KV_i]      <=1'd1;
                    end
                else
                    begin
                        
                    if (KAM_KV_ACCESS_wr_valid[KAM_KV_i] && !((((KAM_KV_ACCESS_WE_q[KAM_KV_i]) == 1'b0) && ((KAM_OTP_HW_CONTROL_LCM_MODE_q) == 1'b1)) && ((KAM_OTP_HW_CONTROL_KAM_KV_EN_q) == 1'b1)))   // WE : SW Write FIXME
                        begin
                            KAM_KV_ACCESS_WE_q[KAM_KV_i] <=  ( wr_data[0] & reg_enb[0] ) | (KAM_KV_ACCESS_WE_q[KAM_KV_i] & (~reg_enb[0]));
                        end
                        
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            // ===================================================
            // HW OUTPUT READ DATA FOR EACH FIELD
            assign KAM_KV_ACCESS_RE_r[KAM_KV_i]      =  KAM_KV_ACCESS_RE_q[KAM_KV_i]     ;    // Field : RE
            assign KAM_KV_ACCESS_WE_r[KAM_KV_i]      =  KAM_KV_ACCESS_WE_q[KAM_KV_i]     ;    // Field : WE
            
            
            assign KAM_KV_ACCESS_rd_data[KAM_KV_i] = KAM_KV_ACCESS_rd_valid[KAM_KV_i] ? {29'b0 ,KAM_KV_ACCESS_KV_RANGE_LOCK_q[KAM_KV_i] , KAM_KV_ACCESS_RE_q[KAM_KV_i] , KAM_KV_ACCESS_WE_q[KAM_KV_i]} : 32'b00000000000000000000000000000000;
            
            
            //----------------------------------------------------------------------------------------------------
            // REGISTER      :  STATUS
            // ADDRESS       :  block_offset+'h300 + KAM_KV_i * 'hC + 'h8                WIDTH : 32
            // HW ACCESS     :  READ-WRITE
            // SW ACCESS     :  READ-WRITE
            //
            // FIELDS   :
            //      1:1 : WRITE_DENY  ( SW : Read-Write One to Clear HW : Read-Write )
            //      0:0 : READ_DENY   ( SW : Read-Write One to Clear HW : Read-Write )
            
            //-----------------------------------------------------------------------------
            // DESCRIPTION  :  NA
            //
            
            
            assign KAM_KV_STATUS_wr_valid[KAM_KV_i] = KAM_KV_STATUS_decode[KAM_KV_i] && wr_stb;
            assign KAM_KV_STATUS_rd_valid[KAM_KV_i] = KAM_KV_STATUS_decode[KAM_KV_i] && rd_stb;
            assign KAM_KV_STATUS_offset[KAM_KV_i] = block_offset+'h300 + KAM_KV_i * 'hC + 'h8;
            assign KAM_KV_STATUS_decode[KAM_KV_i]  = (address[KAM_KV_address_width-1 : 0]    == KAM_KV_STATUS_offset[KAM_KV_i][KAM_KV_address_width-1 : 0] ) ? 1'b1 : 1'b0;
            
            
            //----------------------------------------------------------------------------
            // FIELD  : WRITE_DENY
            // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
            // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  1
            //-----------------------------------------------------------------
            // DESCRIPTION   :  A write to SCRATCH RAM matched a KV Range with KV_ENABLE == 1 && WE == 0
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_KV_STATUS_WRITE_DENY_q[KAM_KV_i] <=1'd0;
                    end
                else
                    begin
                        
                    if( KAM_KV_STATUS_WRITE_DENY_hw_set[KAM_KV_i])    //set
                        begin
                            KAM_KV_STATUS_WRITE_DENY_q[KAM_KV_i] <= 1'b1;
                        end
                    else if (KAM_KV_STATUS_WRITE_DENY_in_enb[KAM_KV_i])   // WRITE_DENY : HW Write
                        begin
                            KAM_KV_STATUS_WRITE_DENY_q[KAM_KV_i] <= KAM_KV_STATUS_WRITE_DENY_in[KAM_KV_i];
                        end
                    else
                        begin
                        if (KAM_KV_STATUS_wr_valid[KAM_KV_i])   // WRITE_DENY : SW Write One to Clear
                            begin
                                KAM_KV_STATUS_WRITE_DENY_q[KAM_KV_i] <=  KAM_KV_STATUS_WRITE_DENY_q[KAM_KV_i] & ( ~( wr_data[1] & reg_enb[1] ));
                            end
                            
                        end  // sw_write_close
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            
            //----------------------------------------------------------------------------
            // FIELD  : READ_DENY
            // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
            // SW ACCESS  :  READ-WRITE ONE TO CLEAR             OFFSET :  0
            //-----------------------------------------------------------------
            // DESCRIPTION   :  A read from SCRATCH RAM matched a KV Range with KV_ENABLE == 1 && RE == 0
            //
            
            always @(posedge clk or negedge reset_l)
                begin
                if (!reset_l)
                    begin
                        
                        
                        KAM_KV_STATUS_READ_DENY_q[KAM_KV_i] <=1'd0;
                    end
                else
                    begin
                        
                    if( KAM_KV_STATUS_READ_DENY_hw_set[KAM_KV_i])    //set
                        begin
                            KAM_KV_STATUS_READ_DENY_q[KAM_KV_i] <= 1'b1;
                        end
                    else if (KAM_KV_STATUS_READ_DENY_in_enb[KAM_KV_i])   // READ_DENY : HW Write
                        begin
                            KAM_KV_STATUS_READ_DENY_q[KAM_KV_i] <= KAM_KV_STATUS_READ_DENY_in[KAM_KV_i];
                        end
                    else
                        begin
                        if (KAM_KV_STATUS_wr_valid[KAM_KV_i])   // READ_DENY : SW Write One to Clear
                            begin
                                KAM_KV_STATUS_READ_DENY_q[KAM_KV_i] <=  KAM_KV_STATUS_READ_DENY_q[KAM_KV_i] & ( ~( wr_data[0] & reg_enb[0] ));
                            end
                            
                        end  // sw_write_close
                    end
            end // always clk
            
            //----------------------------------------------------------------------------
            
            
            // ===================================================
            // HW OUTPUT READ DATA FOR EACH FIELD
            assign KAM_KV_STATUS_WRITE_DENY_r[KAM_KV_i] =  KAM_KV_STATUS_WRITE_DENY_q[KAM_KV_i];    // Field : WRITE_DENY
            assign KAM_KV_STATUS_READ_DENY_r[KAM_KV_i] =  KAM_KV_STATUS_READ_DENY_q[KAM_KV_i];    // Field : READ_DENY
            
            
            assign KAM_KV_STATUS_rd_data[KAM_KV_i] = KAM_KV_STATUS_rd_valid[KAM_KV_i] ? {30'b0 ,KAM_KV_STATUS_WRITE_DENY_q[KAM_KV_i] , KAM_KV_STATUS_READ_DENY_q[KAM_KV_i]} : 32'b00000000000000000000000000000000;
            
            
        end //KAM_KV_gen
    endgenerate
    
    
    generate
        genvar KAM_PMR_LIST_i;
        for( KAM_PMR_LIST_i = 0; KAM_PMR_LIST_i < KAM_PMR_LIST_count; KAM_PMR_LIST_i = KAM_PMR_LIST_i + 1)
        begin : KAM_PMR_LIST_gen
            
            
            assign KAM_PMR_LIST_KAM_PMR_ENTRY_offset[KAM_PMR_LIST_i]       = (block_offset/'h40) +('h400 + KAM_PMR_LIST_i * 'h40 + 'h0)>>6;
            assign KAM_PMR_LIST_KAM_PMR_ENTRY_decode[KAM_PMR_LIST_i]  = (address[ROT_KAM_regs_address_width - 1:6]  == KAM_PMR_LIST_KAM_PMR_ENTRY_offset[KAM_PMR_LIST_i][(ROT_KAM_regs_address_width - 6) - 1 :0]) ? 1'b1 : 1'b0;
            assign KAM_PMR_LIST_KAM_PMR_ENTRY_wr_valid[KAM_PMR_LIST_i]     = KAM_PMR_LIST_KAM_PMR_ENTRY_decode[KAM_PMR_LIST_i] &&  wr_stb && KAM_PMR_LIST_KAM_PMR_ENTRY_wprot;
            assign KAM_PMR_LIST_KAM_PMR_ENTRY_rd_valid[KAM_PMR_LIST_i]     = KAM_PMR_LIST_KAM_PMR_ENTRY_decode[KAM_PMR_LIST_i] && rd_stb && rd_wait_state;
            assign KAM_PMR_LIST_KAM_PMR_ENTRY_wr_valid_out[KAM_PMR_LIST_i] = KAM_PMR_LIST_KAM_PMR_ENTRY_wr_valid[KAM_PMR_LIST_i];
            assign KAM_PMR_LIST_KAM_PMR_ENTRY_rd_valid_out[KAM_PMR_LIST_i] = KAM_PMR_LIST_KAM_PMR_ENTRY_rd_valid[KAM_PMR_LIST_i];
            
            assign KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[KAM_PMR_LIST_i]      = KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[KAM_PMR_LIST_i] ? KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data_in[(KAM_PMR_LIST_i)* bus_width + bus_width - 1 : (KAM_PMR_LIST_i) * bus_width] : 32'b00000000000000000000000000000000;
            assign KAM_PMR_LIST_KAM_PMR_ENTRY_write_error[KAM_PMR_LIST_i]  = KAM_PMR_LIST_KAM_PMR_ENTRY_decode[KAM_PMR_LIST_i] && wr_stb && ~KAM_PMR_LIST_KAM_PMR_ENTRY_wprot;
            
            
        end //KAM_PMR_LIST_gen
    endgenerate
    
    
    
    assign KAM_OTP_LANE_CONFIG_rd_data_wire = KAM_OTP_LANE_CONFIG_rd_data[0] | KAM_OTP_LANE_CONFIG_rd_data[1] | KAM_OTP_LANE_CONFIG_rd_data[2] | KAM_OTP_LANE_CONFIG_rd_data[3] | KAM_OTP_LANE_CONFIG_rd_data[4] | KAM_OTP_LANE_CONFIG_rd_data[5] | KAM_OTP_LANE_CONFIG_rd_data[6] | KAM_OTP_LANE_CONFIG_rd_data[7];
    
    assign KAM_OTP_LANE_ACCESS_rd_data_wire = KAM_OTP_LANE_ACCESS_rd_data[0] | KAM_OTP_LANE_ACCESS_rd_data[1] | KAM_OTP_LANE_ACCESS_rd_data[2] | KAM_OTP_LANE_ACCESS_rd_data[3] | KAM_OTP_LANE_ACCESS_rd_data[4] | KAM_OTP_LANE_ACCESS_rd_data[5] | KAM_OTP_LANE_ACCESS_rd_data[6] | KAM_OTP_LANE_ACCESS_rd_data[7];
    
    assign KAM_OTP_LANE_STATUS_rd_data_wire = KAM_OTP_LANE_STATUS_rd_data[0] | KAM_OTP_LANE_STATUS_rd_data[1] | KAM_OTP_LANE_STATUS_rd_data[2] | KAM_OTP_LANE_STATUS_rd_data[3] | KAM_OTP_LANE_STATUS_rd_data[4] | KAM_OTP_LANE_STATUS_rd_data[5] | KAM_OTP_LANE_STATUS_rd_data[6] | KAM_OTP_LANE_STATUS_rd_data[7];
    
    
    
    assign KAM_KV_RANGE_rd_data_wire = KAM_KV_RANGE_rd_data[0] | KAM_KV_RANGE_rd_data[1];
    
    assign KAM_KV_ACCESS_rd_data_wire = KAM_KV_ACCESS_rd_data[0] | KAM_KV_ACCESS_rd_data[1];
    
    assign KAM_KV_STATUS_rd_data_wire = KAM_KV_STATUS_rd_data[0] | KAM_KV_STATUS_rd_data[1];
    
    assign KAM_PMR_STATUS_rd_data_wire = KAM_PMR_STATUS_rd_data[0] | KAM_PMR_STATUS_rd_data[1] | KAM_PMR_STATUS_rd_data[2] | KAM_PMR_STATUS_rd_data[3] | KAM_PMR_STATUS_rd_data[4] | KAM_PMR_STATUS_rd_data[5] | KAM_PMR_STATUS_rd_data[6] | KAM_PMR_STATUS_rd_data[7];
    
    
    
    
    
    
    
    
    
    
    
    
    
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_req_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_req_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_ack_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_ack_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_decode_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_decode;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_req_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_req_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_ack_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_ack_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_decode_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_decode;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_req_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_req_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_ack_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_ack_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_decode_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_decode;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_ack_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_ack_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_decode_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_decode;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_req_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_req_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_ack_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_ack_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_decode_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_decode;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_req_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_req_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_ack_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_ack_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_decode_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_decode;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_ack_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_ack_in;
    assign KAM_OTP_OTPC_KAM_OTP_OTPC_READ_decode_wire = KAM_OTP_OTPC_KAM_OTP_OTPC_READ_decode;
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_req_wire = KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_req_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_ack_wire = KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_ack_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_decode_wire = KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_decode;
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_req_wire = KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_req_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_ack_wire = KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_ack_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_decode_wire = KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_decode;
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_req_wire = KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_req_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_ack_wire = KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_ack_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_STATUS_decode_wire = KAM_OTP_EFC_KAM_OTP_EFC_STATUS_decode;
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_req_wire = KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_req_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_ack_wire = KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_ack_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_decode_wire = KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_decode;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_req_wire = KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_req_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_ack_wire = KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_ack_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_decode_wire = KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_decode;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_req_wire = KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_req_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_ack_wire = KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_ack_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_decode_wire = KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_decode;
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_req_wire = KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_req_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_ack_wire = KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_ack_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_decode_wire = KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_decode;
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_ack_wire = KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_ack_in;
    assign KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_decode_wire = KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_decode;
    assign KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_wire = KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in[0] | KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in[1] | KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in[2] | KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in[3] | KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in[4] | KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in[5] | KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in[6] | KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_in[7];
    assign KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_wire = KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[0] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[1] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[2] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[3] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[4] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[5] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[6] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_in[7];
    assign KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data_wire = KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[0] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[1] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[2] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[3] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[4] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[5] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[6] | KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data[7];
    assign KAM_PMR_LIST_KAM_PMR_ENTRY_decode_wire = KAM_PMR_LIST_KAM_PMR_ENTRY_decode[0] | KAM_PMR_LIST_KAM_PMR_ENTRY_decode[1] | KAM_PMR_LIST_KAM_PMR_ENTRY_decode[2] | KAM_PMR_LIST_KAM_PMR_ENTRY_decode[3] | KAM_PMR_LIST_KAM_PMR_ENTRY_decode[4] | KAM_PMR_LIST_KAM_PMR_ENTRY_decode[5] | KAM_PMR_LIST_KAM_PMR_ENTRY_decode[6] | KAM_PMR_LIST_KAM_PMR_ENTRY_decode[7];
    
    
    assign rd_data = int_rd_data | ext_rd_data ;
    
    assign int_rd_data = (rd_wait_state & ~external_access)? ( KAM_OTP_LANE_CONFIG_rd_data_wire |
    KAM_OTP_LANE_ACCESS_rd_data_wire |
    KAM_OTP_LANE_STATUS_rd_data_wire |
    KAM_OTP_HW_CONTROL_VALID_rd_data |
    KAM_OTP_HW_CONTROL_rd_data |
    KAM_KV_RANGE_rd_data_wire |
    KAM_KV_ACCESS_rd_data_wire |
    KAM_KV_STATUS_rd_data_wire |
    KAM_PMR_STATUS_rd_data_wire |
    KAM_PMR_EXTEND_MEASUREMENT_SRC_rd_data |
    KAM_PMR_EXTEND_TARGET_rd_data |
    KAM_PMR_SHA_CONFIG_rd_data |
    KAM_PMR_SHA_INTR_rd_data |
    KAM_ECC_CTRL_PMR_rd_data |
    KAM_ECC_STATUS_PMR_rd_data |
    KAM_ECC_LOG_PMR_rd_data |
    KAM_ERR_STATUS_rd_data |
    KAM_INTR_STATE_rd_data |
    KAM_INTR_ENABLE_rd_data |
    KAM_INTR_TEST_rd_data |
    KAM_SCRATCH_rd_data) : {bus_width{1'b0}};
    
    assign ext_rd_data = (external_rd_ack == 1'b1)? ( KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_data |
    KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_data |
    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_data |
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_data |
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_data |
    KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_data |
    KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_data |
    KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_data |
    KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_data |
    KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_data |
    KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_data |
    KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_data |
    KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_data |
    KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_data |
    KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_data |
    KAM_PMR_LIST_KAM_PMR_ENTRY_rd_data_wire ): {bus_width{1'b0}} ;
    
    
    
  assign error = '0;// KAM_PMR_SHA_CONFIG_error | FIXME manual hack
//    KAM_PMR_SHA_INTR_error |
//    KAM_PMR_LIST_KAM_PMR_ENTRY_error_wire;
    
    assign external_rd_valid = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_valid |
    KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_valid |
    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_valid |
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_valid |
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_valid |
    KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_valid |
    KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_valid |
    KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_valid |
    KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_valid |
    KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_valid |
    KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_valid |
    KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_valid |
    KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_valid |
    KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_valid |
    KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_valid |
    (|KAM_PMR_LIST_KAM_PMR_ENTRY_rd_valid);
    // END external_rd_valid
    
    assign external_rd_ack = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_rd_ack_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_rd_ack_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_rd_ack_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_rd_ack_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_rd_ack_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_rd_ack_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_READ_rd_ack_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_rd_ack_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_rd_ack_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_STATUS_rd_ack_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_rd_ack_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_rd_ack_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_rd_ack_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_rd_ack_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_rd_ack_wire |
    KAM_PMR_LIST_KAM_PMR_ENTRY_rd_ack_wire;
    // END external_rd_ack
    
    assign external_wr_req = KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_wr_req_wire &
    KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_wr_req_wire &
    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_wr_req_wire &
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_wr_req_wire &
    KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_wr_req_wire &
    KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_wr_req_wire &
    KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_wr_req_wire &
    KAM_OTP_EFC_KAM_OTP_EFC_STATUS_wr_req_wire &
    KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_wr_req_wire &
    KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_wr_req_wire &
    KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_wr_req_wire &
    KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_wr_req_wire &
    KAM_PMR_LIST_KAM_PMR_ENTRY_wr_req_wire;
    // END external_wr_req
    
    assign external_access = (KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL_decode_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_ADDRESS_decode_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_CONTROL0_decode_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS0_decode_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_STATUS1_decode_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_WRITE_decode_wire |
    KAM_OTP_OTPC_KAM_OTP_OTPC_READ_decode_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_CONTROL_decode_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_BYPASS_CONTROL_decode_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_STATUS_decode_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_POWER_CONTROLS_decode_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_ACCESS_TIMERS_decode_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_ADDRESS_decode_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_PGM_DATA_decode_wire |
    KAM_OTP_EFC_KAM_OTP_EFC_RD_DATA_decode_wire |
    KAM_PMR_LIST_KAM_PMR_ENTRY_decode_wire) & (rd_stb | wr_stb);
    // END external_access
    
    always @(posedge clk or negedge reset_l)
        begin
        if ( !reset_l )
            begin
                rd_wait_state <= 1'b1;
            end
        else
            begin
                case(rd_wait_state)
                    1'b1:
                    begin
                    if (external_rd_valid == 1'b1 && external_rd_ack == 1'b0 )
                        begin
                            rd_wait_state <= 1'b0;
                        end
                    end
                    1'b0:
                    begin
                    if (external_rd_ack == 1'b1)
                        begin
                            rd_wait_state <= 1'b1;
                        end
                    end
                endcase
            end
    end // always END
    
    
    assign request     = external_wr_req;
    assign rd_data_vld = external_rd_ack |(~external_access & rd_stb & rd_wait_state);
    assign rd_wait     = external_rd_valid ? external_rd_ack : ( rd_data_vld | rd_wait_state);
    
    
    
    
endmodule
