/* SCALINX SAS ***** Copyright (c) SCALINX 2022 - All rights reserved *****

*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
IDesignSpec ver     : 7.44.14.0

**** This code is generated with the following settings ***
Reg Width                  : 32
Address Unit               : 8
C++ Types int              : uint%d_t
Bus Type                   : APB
BigEndian                  : false
LittleEndian               : true
Dist. Decode and Readback  : false
------------------------------------------------------------ */

/*--------------------------------------------------
MODULE    :    MTU_REGS MODULE
*/
module mtu_regs #(
    
    // PARAMETERS
    
    
    
    parameter bus_width = 32,
    parameter addr_width = 12,
    parameter block_size = 'h1000,
    
    parameter [addr_width-1 : 0] block_offset = {(addr_width){1'b0}}
    
    )
    
    (
    
    
    // REGISTER : MTU_CTRL_0 PORT SIGNAL
    input  MTU_CTRL_0_CTRL_ENABLE_in,
    output  MTU_CTRL_0_CTRL_ENABLE_r,
    output  MTU_CTRL_0_CTRL_MODE_r,
    output [8 : 0] MTU_CTRL_0_CTRL_DIV_r,
    
    // REGISTER : MTU_LOAD_VALUE_0 PORT SIGNAL
    output reg  MTU_LOAD_VALUE_0_COUNTER_VALUE_wr_pulse, // REGISTER WRITE PULSE
    output [31 : 0] MTU_LOAD_VALUE_0_COUNTER_VALUE_r,
    
    // REGISTER : MTU_BACK_LOAD_VALUE_0 PORT SIGNAL
    output reg  MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_wr_pulse, // REGISTER WRITE PULSE
    output [31 : 0] MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_r,
    
    // REGISTER : MTU_STATUS_0 PORT SIGNAL
    input  MTU_STATUS_0_IRQ_in,
    
    // REGISTER : MTU_CTRL_1 PORT SIGNAL
    input  MTU_CTRL_1_CTRL_ENABLE_in,
    output  MTU_CTRL_1_CTRL_ENABLE_r,
    output  MTU_CTRL_1_CTRL_MODE_r,
    output [8 : 0] MTU_CTRL_1_CTRL_DIV_r,
    
    // REGISTER : MTU_LOAD_VALUE_1 PORT SIGNAL
    output reg  MTU_LOAD_VALUE_1_COUNTER_VALUE_wr_pulse, // REGISTER WRITE PULSE
    output [31 : 0] MTU_LOAD_VALUE_1_COUNTER_VALUE_r,
    
    // REGISTER : MTU_BACK_LOAD_VALUE_1 PORT SIGNAL
    output reg  MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_wr_pulse, // REGISTER WRITE PULSE
    output [31 : 0] MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_r,
    
    // REGISTER : MTU_STATUS_1 PORT SIGNAL
    input  MTU_STATUS_1_IRQ_in,
    
    // REGISTER : MTU_CTRL_2 PORT SIGNAL
    input  MTU_CTRL_2_CTRL_ENABLE_in,
    output  MTU_CTRL_2_CTRL_ENABLE_r,
    output  MTU_CTRL_2_CTRL_MODE_r,
    output [8 : 0] MTU_CTRL_2_CTRL_DIV_r,
    
    // REGISTER : MTU_LOAD_VALUE_2 PORT SIGNAL
    output reg  MTU_LOAD_VALUE_2_COUNTER_VALUE_wr_pulse, // REGISTER WRITE PULSE
    output [31 : 0] MTU_LOAD_VALUE_2_COUNTER_VALUE_r,
    
    // REGISTER : MTU_BACK_LOAD_VALUE_2 PORT SIGNAL
    output reg  MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_wr_pulse, // REGISTER WRITE PULSE
    output [31 : 0] MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_r,
    
    // REGISTER : MTU_STATUS_2 PORT SIGNAL
    input  MTU_STATUS_2_IRQ_in,
    
    // REGISTER : MTU_CTRL_3 PORT SIGNAL
    input  MTU_CTRL_3_CTRL_ENABLE_in,
    output  MTU_CTRL_3_CTRL_ENABLE_r,
    output  MTU_CTRL_3_CTRL_MODE_r,
    output [8 : 0] MTU_CTRL_3_CTRL_DIV_r,
    
    // REGISTER : MTU_LOAD_VALUE_3 PORT SIGNAL
    output reg  MTU_LOAD_VALUE_3_COUNTER_VALUE_wr_pulse, // REGISTER WRITE PULSE
    output [31 : 0] MTU_LOAD_VALUE_3_COUNTER_VALUE_r,
    
    // REGISTER : MTU_BACK_LOAD_VALUE_3 PORT SIGNAL
    output reg  MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_wr_pulse, // REGISTER WRITE PULSE
    output [31 : 0] MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_r,
    
    // REGISTER : MTU_STATUS_3 PORT SIGNAL
    input  MTU_STATUS_3_IRQ_in,
    
    //APB signals
    input pclk,     //Bus clock
    input presetn,     //Reset
    input psel,     //Select    : It indicates that the slave device is selected and a data transfer is required
    input penable,     //Enable    : This signal indicates the second and subsequent cycles of an APB transfer
    input pwrite,     //Direction : This signal indicates an APB write access when HIGH and an APB read access when LOW
    input [2 : 0] pprot,     //Protection type : This signal indicates the normal, privileged, or secure protection level of the transaction
    input [bus_width/8-1 : 0] pstrb,     //Write strobes : This signal indicates which byte lanes to update during a write transfer
    input [bus_width-1 : 0] pwdata,     //Write data
    input [addr_width-1 : 0] paddr,     //Address bus
    output pready,     //Ready     : The slave uses this signal to extend an APB transfer
    output [bus_width-1 : 0] prdata,     //Read data
    output pslverr     //pslverr : This signal indicates a transfer failure.
    );
    
    
    
    wire MTU_CTRL_0_decode;        // Write Decode
    wire MTU_CTRL_0_wr_valid;        // Write Valid
    wire [63 : 0] MTU_CTRL_0_offset;        // Offset
    wire MTU_CTRL_0_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_CTRL_0_rd_data;        // Read Data
    reg MTU_CTRL_0_CTRL_ENABLE_q; // FIELD : CTRL_ENABLE
    reg MTU_CTRL_0_CTRL_MODE_q; // FIELD : CTRL_MODE
    reg [8 : 0] MTU_CTRL_0_CTRL_DIV_q; // FIELD : CTRL_DIV
    wire MTU_LOAD_VALUE_0_decode;        // Write Decode
    wire MTU_LOAD_VALUE_0_wr_valid;        // Write Valid
    wire [63 : 0] MTU_LOAD_VALUE_0_offset;        // Offset
    wire MTU_LOAD_VALUE_0_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_LOAD_VALUE_0_rd_data;        // Read Data
    wire        MTU_LOAD_VALUE_0_COUNTER_VALUE_q_wr_pulse; // PULSE BUFFER SIGNAL
    reg [31 : 0] MTU_LOAD_VALUE_0_COUNTER_VALUE_q; // FIELD : COUNTER_VALUE
    wire MTU_BACK_LOAD_VALUE_0_decode;        // Write Decode
    wire MTU_BACK_LOAD_VALUE_0_wr_valid;        // Write Valid
    wire [63 : 0] MTU_BACK_LOAD_VALUE_0_offset;        // Offset
    wire MTU_BACK_LOAD_VALUE_0_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_BACK_LOAD_VALUE_0_rd_data;        // Read Data
    wire        MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q_wr_pulse; // PULSE BUFFER SIGNAL
    reg [31 : 0] MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q; // FIELD : BACKGROUND_COUNTER_VALUE
    wire MTU_STATUS_0_decode;        // Write Decode
    wire MTU_STATUS_0_wr_valid;        // Write Valid
    wire [63 : 0] MTU_STATUS_0_offset;        // Offset
    wire MTU_STATUS_0_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_STATUS_0_rd_data;        // Read Data
    reg MTU_STATUS_0_IRQ_q; // FIELD : IRQ
    wire MTU_CTRL_1_decode;        // Write Decode
    wire MTU_CTRL_1_wr_valid;        // Write Valid
    wire [63 : 0] MTU_CTRL_1_offset;        // Offset
    wire MTU_CTRL_1_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_CTRL_1_rd_data;        // Read Data
    reg MTU_CTRL_1_CTRL_ENABLE_q; // FIELD : CTRL_ENABLE
    reg MTU_CTRL_1_CTRL_MODE_q; // FIELD : CTRL_MODE
    reg [8 : 0] MTU_CTRL_1_CTRL_DIV_q; // FIELD : CTRL_DIV
    wire MTU_LOAD_VALUE_1_decode;        // Write Decode
    wire MTU_LOAD_VALUE_1_wr_valid;        // Write Valid
    wire [63 : 0] MTU_LOAD_VALUE_1_offset;        // Offset
    wire MTU_LOAD_VALUE_1_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_LOAD_VALUE_1_rd_data;        // Read Data
    wire        MTU_LOAD_VALUE_1_COUNTER_VALUE_q_wr_pulse; // PULSE BUFFER SIGNAL
    reg [31 : 0] MTU_LOAD_VALUE_1_COUNTER_VALUE_q; // FIELD : COUNTER_VALUE
    wire MTU_BACK_LOAD_VALUE_1_decode;        // Write Decode
    wire MTU_BACK_LOAD_VALUE_1_wr_valid;        // Write Valid
    wire [63 : 0] MTU_BACK_LOAD_VALUE_1_offset;        // Offset
    wire MTU_BACK_LOAD_VALUE_1_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_BACK_LOAD_VALUE_1_rd_data;        // Read Data
    wire        MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q_wr_pulse; // PULSE BUFFER SIGNAL
    reg [31 : 0] MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q; // FIELD : BACKGROUND_COUNTER_VALUE
    wire MTU_STATUS_1_decode;        // Write Decode
    wire MTU_STATUS_1_wr_valid;        // Write Valid
    wire [63 : 0] MTU_STATUS_1_offset;        // Offset
    wire MTU_STATUS_1_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_STATUS_1_rd_data;        // Read Data
    reg MTU_STATUS_1_IRQ_q; // FIELD : IRQ
    wire MTU_CTRL_2_decode;        // Write Decode
    wire MTU_CTRL_2_wr_valid;        // Write Valid
    wire [63 : 0] MTU_CTRL_2_offset;        // Offset
    wire MTU_CTRL_2_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_CTRL_2_rd_data;        // Read Data
    reg MTU_CTRL_2_CTRL_ENABLE_q; // FIELD : CTRL_ENABLE
    reg MTU_CTRL_2_CTRL_MODE_q; // FIELD : CTRL_MODE
    reg [8 : 0] MTU_CTRL_2_CTRL_DIV_q; // FIELD : CTRL_DIV
    wire MTU_LOAD_VALUE_2_decode;        // Write Decode
    wire MTU_LOAD_VALUE_2_wr_valid;        // Write Valid
    wire [63 : 0] MTU_LOAD_VALUE_2_offset;        // Offset
    wire MTU_LOAD_VALUE_2_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_LOAD_VALUE_2_rd_data;        // Read Data
    wire        MTU_LOAD_VALUE_2_COUNTER_VALUE_q_wr_pulse; // PULSE BUFFER SIGNAL
    reg [31 : 0] MTU_LOAD_VALUE_2_COUNTER_VALUE_q; // FIELD : COUNTER_VALUE
    wire MTU_BACK_LOAD_VALUE_2_decode;        // Write Decode
    wire MTU_BACK_LOAD_VALUE_2_wr_valid;        // Write Valid
    wire [63 : 0] MTU_BACK_LOAD_VALUE_2_offset;        // Offset
    wire MTU_BACK_LOAD_VALUE_2_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_BACK_LOAD_VALUE_2_rd_data;        // Read Data
    wire        MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q_wr_pulse; // PULSE BUFFER SIGNAL
    reg [31 : 0] MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q; // FIELD : BACKGROUND_COUNTER_VALUE
    wire MTU_STATUS_2_decode;        // Write Decode
    wire MTU_STATUS_2_wr_valid;        // Write Valid
    wire [63 : 0] MTU_STATUS_2_offset;        // Offset
    wire MTU_STATUS_2_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_STATUS_2_rd_data;        // Read Data
    reg MTU_STATUS_2_IRQ_q; // FIELD : IRQ
    wire MTU_CTRL_3_decode;        // Write Decode
    wire MTU_CTRL_3_wr_valid;        // Write Valid
    wire [63 : 0] MTU_CTRL_3_offset;        // Offset
    wire MTU_CTRL_3_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_CTRL_3_rd_data;        // Read Data
    reg MTU_CTRL_3_CTRL_ENABLE_q; // FIELD : CTRL_ENABLE
    reg MTU_CTRL_3_CTRL_MODE_q; // FIELD : CTRL_MODE
    reg [8 : 0] MTU_CTRL_3_CTRL_DIV_q; // FIELD : CTRL_DIV
    wire MTU_LOAD_VALUE_3_decode;        // Write Decode
    wire MTU_LOAD_VALUE_3_wr_valid;        // Write Valid
    wire [63 : 0] MTU_LOAD_VALUE_3_offset;        // Offset
    wire MTU_LOAD_VALUE_3_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_LOAD_VALUE_3_rd_data;        // Read Data
    wire        MTU_LOAD_VALUE_3_COUNTER_VALUE_q_wr_pulse; // PULSE BUFFER SIGNAL
    reg [31 : 0] MTU_LOAD_VALUE_3_COUNTER_VALUE_q; // FIELD : COUNTER_VALUE
    wire MTU_BACK_LOAD_VALUE_3_decode;        // Write Decode
    wire MTU_BACK_LOAD_VALUE_3_wr_valid;        // Write Valid
    wire [63 : 0] MTU_BACK_LOAD_VALUE_3_offset;        // Offset
    wire MTU_BACK_LOAD_VALUE_3_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_BACK_LOAD_VALUE_3_rd_data;        // Read Data
    wire        MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q_wr_pulse; // PULSE BUFFER SIGNAL
    reg [31 : 0] MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q; // FIELD : BACKGROUND_COUNTER_VALUE
    wire MTU_STATUS_3_decode;        // Write Decode
    wire MTU_STATUS_3_wr_valid;        // Write Valid
    wire [63 : 0] MTU_STATUS_3_offset;        // Offset
    wire MTU_STATUS_3_rd_valid;        // Read Valid
    wire [bus_width-1 : 0] MTU_STATUS_3_rd_data;        // Read Data
    reg MTU_STATUS_3_IRQ_q; // FIELD : IRQ
    
    wire [63:0] emptyaddress0_error_l;
    wire [63:0] emptyaddress0_error_h;
    wire emptyaddress0_error;
    
    wire invalid_address_error;
    
    wire [2 : 0] pprot_i;
    
    
    wire [bus_width-1 : 0] reg_enb;
    wire clk;
    wire reset_l;
    wire rd_stb;
    wire rd_wait;
    wire wr_stb;
    wire [addr_width-1 : 0] address;
    wire  [bus_width/8 -1 : 0] byte_enb;
    wire [bus_width-1 : 0] wr_data;
    wire request;
    wire [bus_width-1 : 0] rd_data;
    wire rd_data_vld;
    wire error;
    
    mtu_regs_apb_widget # (.addr_width(addr_width), .bus_width(bus_width) , .reset_type("async"))apb (
            .pclk(pclk),
            .presetn(presetn),
            .pwdata(pwdata),
            .paddr(paddr),
            .prdata(prdata),
            .pready(pready),
            .pwrite(pwrite),
            .pprot(pprot),
            .pprot_i(pprot_i),
            .pstrb(pstrb),
            .psel(psel),
            .penable(penable),
            .pslverr(pslverr),
            
            .clk(clk),
            .reset_l(reset_l),
            .request(request),
            .wr_stb(wr_stb),
            .rd_stb(rd_stb),
            .rd_data(rd_data),
            .wr_data(wr_data),
            .rd_wait(rd_wait),
            .address(address),
            .rd_data_vld(rd_data_vld),
            .byte_enb(byte_enb),
            .error(error));
    // end widget
    
    assign reg_enb = {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_CTRL_0
    // ADDRESS       :  block_offset +'h0		WIDTH : 32
    // HW ACCESS     :  RW RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     0 : CTRL_ENABLE  ( SW : RW HW : RW )
    //     1 : CTRL_MODE  ( SW : RW HW : RO )
    //     10:2 : CTRL_DIV  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_CTRL_0_wr_valid = MTU_CTRL_0_decode && wr_stb  ;
    assign MTU_CTRL_0_offset = block_offset +'h0;
    assign MTU_CTRL_0_decode = (address[addr_width-1 : 0] == MTU_CTRL_0_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_CTRL_0_rd_valid = MTU_CTRL_0_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_ENABLE
    // HW ACCESS  : RW                          WIDTH : 1
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Enable counter 0
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_0_CTRL_ENABLE_q <= 1'd0;
        end
    else
        begin
        if (MTU_CTRL_0_wr_valid)	 //CTRL_ENABLE : SW Write
            begin
                MTU_CTRL_0_CTRL_ENABLE_q <= (wr_data [0]  & reg_enb  [0] ) | (MTU_CTRL_0_CTRL_ENABLE_q & (~reg_enb  [0] ));
            end
        else
            begin
                
                MTU_CTRL_0_CTRL_ENABLE_q <= MTU_CTRL_0_CTRL_ENABLE_in;
            end
        end
    end //end always
    
    assign MTU_CTRL_0_CTRL_ENABLE_r = MTU_CTRL_0_CTRL_ENABLE_q; // Field : CTRL_ENABLE
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_MODE
    // HW ACCESS  : RO                          WIDTH : 1
    // SW ACCESS  : RW                          OFFSET : 1
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Select mode of counter_0 :
    0 -> periodic (free-running)
    1 -> One shot
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_0_CTRL_MODE_q <= 1'd0;
        end
    else
        begin
        if (MTU_CTRL_0_wr_valid)	 //CTRL_MODE : SW Write
            begin
                MTU_CTRL_0_CTRL_MODE_q <= (wr_data [1]  & reg_enb  [1] ) | (MTU_CTRL_0_CTRL_MODE_q & (~reg_enb  [1] ));
            end
        end
    end //end always
    
    assign MTU_CTRL_0_CTRL_MODE_r = MTU_CTRL_0_CTRL_MODE_q; // Field : CTRL_MODE
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_DIV
    // HW ACCESS  : RO                          WIDTH : 9
    // SW ACCESS  : RW                          OFFSET : 2
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Clock divider 1 ... 256
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_0_CTRL_DIV_q <= 9'd0;
        end
    else
        begin
        if (MTU_CTRL_0_wr_valid)	 //CTRL_DIV : SW Write
            begin
                MTU_CTRL_0_CTRL_DIV_q <= (wr_data [10 : 2]  & reg_enb  [10 : 2] ) | (MTU_CTRL_0_CTRL_DIV_q & (~reg_enb  [10 : 2] ));
            end
        end
    end //end always
    
    assign MTU_CTRL_0_CTRL_DIV_r = MTU_CTRL_0_CTRL_DIV_q; // Field : CTRL_DIV
    assign MTU_CTRL_0_rd_data  = MTU_CTRL_0_rd_valid ? {21'h0, MTU_CTRL_0_CTRL_DIV_q, MTU_CTRL_0_CTRL_MODE_q, MTU_CTRL_0_CTRL_ENABLE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_LOAD_VALUE_0
    // ADDRESS       :  block_offset +'h4		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : COUNTER_VALUE  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_LOAD_VALUE_0_wr_valid = MTU_LOAD_VALUE_0_decode && wr_stb  ;
    assign MTU_LOAD_VALUE_0_offset = block_offset +'h4;
    assign MTU_LOAD_VALUE_0_decode = (address[addr_width-1 : 0] == MTU_LOAD_VALUE_0_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_LOAD_VALUE_0_rd_valid = MTU_LOAD_VALUE_0_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : COUNTER_VALUE
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Value to start count
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_LOAD_VALUE_0_COUNTER_VALUE_q <= 32'd0;
        end
    else
        begin
        if (MTU_LOAD_VALUE_0_wr_valid)	 //COUNTER_VALUE : SW Write
            begin
                MTU_LOAD_VALUE_0_COUNTER_VALUE_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (MTU_LOAD_VALUE_0_COUNTER_VALUE_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign MTU_LOAD_VALUE_0_COUNTER_VALUE_r = MTU_LOAD_VALUE_0_COUNTER_VALUE_q; // Field : COUNTER_VALUE
    
    
    // ===================================================
    // HW OUTPUT WRITE PULSE
    
    assign MTU_LOAD_VALUE_0_COUNTER_VALUE_q_wr_pulse = MTU_LOAD_VALUE_0_wr_valid ; //COUNTER_VALUE  : Write pulse
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_LOAD_VALUE_0_COUNTER_VALUE_wr_pulse <= 1'b0 ;
        end
        
    else
        begin
            MTU_LOAD_VALUE_0_COUNTER_VALUE_wr_pulse <= MTU_LOAD_VALUE_0_COUNTER_VALUE_q_wr_pulse ;
        end
    end
    
    
    assign MTU_LOAD_VALUE_0_rd_data  = MTU_LOAD_VALUE_0_rd_valid ? {MTU_LOAD_VALUE_0_COUNTER_VALUE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_BACK_LOAD_VALUE_0
    // ADDRESS       :  block_offset +'h8		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : BACKGROUND_COUNTER_VALUE  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_BACK_LOAD_VALUE_0_wr_valid = MTU_BACK_LOAD_VALUE_0_decode && wr_stb  ;
    assign MTU_BACK_LOAD_VALUE_0_offset = block_offset +'h8;
    assign MTU_BACK_LOAD_VALUE_0_decode = (address[addr_width-1 : 0] == MTU_BACK_LOAD_VALUE_0_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_BACK_LOAD_VALUE_0_rd_valid = MTU_BACK_LOAD_VALUE_0_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : BACKGROUND_COUNTER_VALUE
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Value to start count after end of counter
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q <= 32'd0;
        end
    else
        begin
        if (MTU_BACK_LOAD_VALUE_0_wr_valid)	 //BACKGROUND_COUNTER_VALUE : SW Write
            begin
                MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_r = MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q; // Field : BACKGROUND_COUNTER_VALUE
    
    
    // ===================================================
    // HW OUTPUT WRITE PULSE
    
    assign MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q_wr_pulse = MTU_BACK_LOAD_VALUE_0_wr_valid ; //BACKGROUND_COUNTER_VALUE  : Write pulse
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_wr_pulse <= 1'b0 ;
        end
        
    else
        begin
            MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_wr_pulse <= MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q_wr_pulse ;
        end
    end
    
    
    assign MTU_BACK_LOAD_VALUE_0_rd_data  = MTU_BACK_LOAD_VALUE_0_rd_valid ? {MTU_BACK_LOAD_VALUE_0_BACKGROUND_COUNTER_VALUE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_STATUS_0
    // ADDRESS       :  block_offset +'hC		WIDTH : 32
    // HW ACCESS     :  WO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     0 : IRQ  ( SW : WC HW : WO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_STATUS_0_wr_valid = MTU_STATUS_0_decode && wr_stb  ;
    assign MTU_STATUS_0_offset = block_offset +'hC;
    assign MTU_STATUS_0_decode = (address[addr_width-1 : 0] == MTU_STATUS_0_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_STATUS_0_rd_valid = MTU_STATUS_0_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : IRQ
    // HW ACCESS  : WO                          WIDTH : 1
    // SW ACCESS  : WC                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Rise when counter_0 value is zero
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_STATUS_0_IRQ_q <= 1'd0;
        end
    else
        begin
        if (MTU_STATUS_0_wr_valid)	 //IRQ : SW Write to Clear
            begin
                MTU_STATUS_0_IRQ_q <= MTU_STATUS_0_IRQ_q & (~reg_enb  [0] );
            end
        else
            begin
                
                MTU_STATUS_0_IRQ_q <= MTU_STATUS_0_IRQ_in;
            else
                begin
                    MTU_STATUS_0_IRQ_q <= 1'h0 ;
                end
            end
        end
    end //end always
    assign MTU_STATUS_0_rd_data  = MTU_STATUS_0_rd_valid ? {31'h0, MTU_STATUS_0_IRQ_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_CTRL_1
    // ADDRESS       :  block_offset +'h10		WIDTH : 32
    // HW ACCESS     :  RW RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     0 : CTRL_ENABLE  ( SW : RW HW : RW )
    //     1 : CTRL_MODE  ( SW : RW HW : RO )
    //     10:2 : CTRL_DIV  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_CTRL_1_wr_valid = MTU_CTRL_1_decode && wr_stb  ;
    assign MTU_CTRL_1_offset = block_offset +'h10;
    assign MTU_CTRL_1_decode = (address[addr_width-1 : 0] == MTU_CTRL_1_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_CTRL_1_rd_valid = MTU_CTRL_1_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_ENABLE
    // HW ACCESS  : RW                          WIDTH : 1
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Enable counter 1
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_1_CTRL_ENABLE_q <= 1'd0;
        end
    else
        begin
        if (MTU_CTRL_1_wr_valid)	 //CTRL_ENABLE : SW Write
            begin
                MTU_CTRL_1_CTRL_ENABLE_q <= (wr_data [0]  & reg_enb  [0] ) | (MTU_CTRL_1_CTRL_ENABLE_q & (~reg_enb  [0] ));
            end
        else
            begin
                
                MTU_CTRL_1_CTRL_ENABLE_q <= MTU_CTRL_1_CTRL_ENABLE_in;
            end
        end
    end //end always
    
    assign MTU_CTRL_1_CTRL_ENABLE_r = MTU_CTRL_1_CTRL_ENABLE_q; // Field : CTRL_ENABLE
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_MODE
    // HW ACCESS  : RO                          WIDTH : 1
    // SW ACCESS  : RW                          OFFSET : 1
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Select mode of counter_1 :
    0 -> periodic (free-running)
    1 -> One shot
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_1_CTRL_MODE_q <= 1'd0;
        end
    else
        begin
        if (MTU_CTRL_1_wr_valid)	 //CTRL_MODE : SW Write
            begin
                MTU_CTRL_1_CTRL_MODE_q <= (wr_data [1]  & reg_enb  [1] ) | (MTU_CTRL_1_CTRL_MODE_q & (~reg_enb  [1] ));
            end
        end
    end //end always
    
    assign MTU_CTRL_1_CTRL_MODE_r = MTU_CTRL_1_CTRL_MODE_q; // Field : CTRL_MODE
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_DIV
    // HW ACCESS  : RO                          WIDTH : 9
    // SW ACCESS  : RW                          OFFSET : 2
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Clock divider 1 ... 256
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_1_CTRL_DIV_q <= 9'd0;
        end
    else
        begin
        if (MTU_CTRL_1_wr_valid)	 //CTRL_DIV : SW Write
            begin
                MTU_CTRL_1_CTRL_DIV_q <= (wr_data [10 : 2]  & reg_enb  [10 : 2] ) | (MTU_CTRL_1_CTRL_DIV_q & (~reg_enb  [10 : 2] ));
            end
        end
    end //end always
    
    assign MTU_CTRL_1_CTRL_DIV_r = MTU_CTRL_1_CTRL_DIV_q; // Field : CTRL_DIV
    assign MTU_CTRL_1_rd_data  = MTU_CTRL_1_rd_valid ? {21'h0, MTU_CTRL_1_CTRL_DIV_q, MTU_CTRL_1_CTRL_MODE_q, MTU_CTRL_1_CTRL_ENABLE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_LOAD_VALUE_1
    // ADDRESS       :  block_offset +'h14		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : COUNTER_VALUE  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_LOAD_VALUE_1_wr_valid = MTU_LOAD_VALUE_1_decode && wr_stb  ;
    assign MTU_LOAD_VALUE_1_offset = block_offset +'h14;
    assign MTU_LOAD_VALUE_1_decode = (address[addr_width-1 : 0] == MTU_LOAD_VALUE_1_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_LOAD_VALUE_1_rd_valid = MTU_LOAD_VALUE_1_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : COUNTER_VALUE
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Value to start count
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_LOAD_VALUE_1_COUNTER_VALUE_q <= 32'd0;
        end
    else
        begin
        if (MTU_LOAD_VALUE_1_wr_valid)	 //COUNTER_VALUE : SW Write
            begin
                MTU_LOAD_VALUE_1_COUNTER_VALUE_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (MTU_LOAD_VALUE_1_COUNTER_VALUE_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign MTU_LOAD_VALUE_1_COUNTER_VALUE_r = MTU_LOAD_VALUE_1_COUNTER_VALUE_q; // Field : COUNTER_VALUE
    
    
    // ===================================================
    // HW OUTPUT WRITE PULSE
    
    assign MTU_LOAD_VALUE_1_COUNTER_VALUE_q_wr_pulse = MTU_LOAD_VALUE_1_wr_valid ; //COUNTER_VALUE  : Write pulse
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_LOAD_VALUE_1_COUNTER_VALUE_wr_pulse <= 1'b0 ;
        end
        
    else
        begin
            MTU_LOAD_VALUE_1_COUNTER_VALUE_wr_pulse <= MTU_LOAD_VALUE_1_COUNTER_VALUE_q_wr_pulse ;
        end
    end
    
    
    assign MTU_LOAD_VALUE_1_rd_data  = MTU_LOAD_VALUE_1_rd_valid ? {MTU_LOAD_VALUE_1_COUNTER_VALUE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_BACK_LOAD_VALUE_1
    // ADDRESS       :  block_offset +'h18		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : BACKGROUND_COUNTER_VALUE  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_BACK_LOAD_VALUE_1_wr_valid = MTU_BACK_LOAD_VALUE_1_decode && wr_stb  ;
    assign MTU_BACK_LOAD_VALUE_1_offset = block_offset +'h18;
    assign MTU_BACK_LOAD_VALUE_1_decode = (address[addr_width-1 : 0] == MTU_BACK_LOAD_VALUE_1_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_BACK_LOAD_VALUE_1_rd_valid = MTU_BACK_LOAD_VALUE_1_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : BACKGROUND_COUNTER_VALUE
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Value to start count after end of counter
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q <= 32'd0;
        end
    else
        begin
        if (MTU_BACK_LOAD_VALUE_1_wr_valid)	 //BACKGROUND_COUNTER_VALUE : SW Write
            begin
                MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_r = MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q; // Field : BACKGROUND_COUNTER_VALUE
    
    
    // ===================================================
    // HW OUTPUT WRITE PULSE
    
    assign MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q_wr_pulse = MTU_BACK_LOAD_VALUE_1_wr_valid ; //BACKGROUND_COUNTER_VALUE  : Write pulse
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_wr_pulse <= 1'b0 ;
        end
        
    else
        begin
            MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_wr_pulse <= MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q_wr_pulse ;
        end
    end
    
    
    assign MTU_BACK_LOAD_VALUE_1_rd_data  = MTU_BACK_LOAD_VALUE_1_rd_valid ? {MTU_BACK_LOAD_VALUE_1_BACKGROUND_COUNTER_VALUE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_STATUS_1
    // ADDRESS       :  block_offset +'h1C		WIDTH : 32
    // HW ACCESS     :  WO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     0 : IRQ  ( SW : WC HW : WO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_STATUS_1_wr_valid = MTU_STATUS_1_decode && wr_stb  ;
    assign MTU_STATUS_1_offset = block_offset +'h1C;
    assign MTU_STATUS_1_decode = (address[addr_width-1 : 0] == MTU_STATUS_1_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_STATUS_1_rd_valid = MTU_STATUS_1_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : IRQ
    // HW ACCESS  : WO                          WIDTH : 1
    // SW ACCESS  : WC                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Rise when counter_1 value is zero
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_STATUS_1_IRQ_q <= 1'd0;
        end
    else
        begin
        if (MTU_STATUS_1_wr_valid)	 //IRQ : SW Write to Clear
            begin
                MTU_STATUS_1_IRQ_q <= MTU_STATUS_1_IRQ_q & (~reg_enb  [0] );
            end
        else
            begin
                
                MTU_STATUS_1_IRQ_q <= MTU_STATUS_1_IRQ_in;
            end
        end
    end //end always
    assign MTU_STATUS_1_rd_data  = MTU_STATUS_1_rd_valid ? {31'h0, MTU_STATUS_1_IRQ_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_CTRL_2
    // ADDRESS       :  block_offset +'h20		WIDTH : 32
    // HW ACCESS     :  RW RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     0 : CTRL_ENABLE  ( SW : RW HW : RW )
    //     1 : CTRL_MODE  ( SW : RW HW : RO )
    //     10:2 : CTRL_DIV  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_CTRL_2_wr_valid = MTU_CTRL_2_decode && wr_stb  ;
    assign MTU_CTRL_2_offset = block_offset +'h20;
    assign MTU_CTRL_2_decode = (address[addr_width-1 : 0] == MTU_CTRL_2_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_CTRL_2_rd_valid = MTU_CTRL_2_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_ENABLE
    // HW ACCESS  : RW                          WIDTH : 1
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Enable counter 2
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_2_CTRL_ENABLE_q <= 1'd0;
        end
    else
        begin
        if (MTU_CTRL_2_wr_valid)	 //CTRL_ENABLE : SW Write
            begin
                MTU_CTRL_2_CTRL_ENABLE_q <= (wr_data [0]  & reg_enb  [0] ) | (MTU_CTRL_2_CTRL_ENABLE_q & (~reg_enb  [0] ));
            end
        else
            begin
                
                MTU_CTRL_2_CTRL_ENABLE_q <= MTU_CTRL_2_CTRL_ENABLE_in;
            end
        end
    end //end always
    
    assign MTU_CTRL_2_CTRL_ENABLE_r = MTU_CTRL_2_CTRL_ENABLE_q; // Field : CTRL_ENABLE
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_MODE
    // HW ACCESS  : RO                          WIDTH : 1
    // SW ACCESS  : RW                          OFFSET : 1
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Select mode of counter_2:
    0 -> periodic (free-running)
    1 -> One shot
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_2_CTRL_MODE_q <= 1'd0;
        end
    else
        begin
        if (MTU_CTRL_2_wr_valid)	 //CTRL_MODE : SW Write
            begin
                MTU_CTRL_2_CTRL_MODE_q <= (wr_data [1]  & reg_enb  [1] ) | (MTU_CTRL_2_CTRL_MODE_q & (~reg_enb  [1] ));
            end
        end
    end //end always
    
    assign MTU_CTRL_2_CTRL_MODE_r = MTU_CTRL_2_CTRL_MODE_q; // Field : CTRL_MODE
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_DIV
    // HW ACCESS  : RO                          WIDTH : 9
    // SW ACCESS  : RW                          OFFSET : 2
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Clock divider 1 ... 256
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_2_CTRL_DIV_q <= 9'd0;
        end
    else
        begin
        if (MTU_CTRL_2_wr_valid)	 //CTRL_DIV : SW Write
            begin
                MTU_CTRL_2_CTRL_DIV_q <= (wr_data [10 : 2]  & reg_enb  [10 : 2] ) | (MTU_CTRL_2_CTRL_DIV_q & (~reg_enb  [10 : 2] ));
            end
        end
    end //end always
    
    assign MTU_CTRL_2_CTRL_DIV_r = MTU_CTRL_2_CTRL_DIV_q; // Field : CTRL_DIV
    assign MTU_CTRL_2_rd_data  = MTU_CTRL_2_rd_valid ? {21'h0, MTU_CTRL_2_CTRL_DIV_q, MTU_CTRL_2_CTRL_MODE_q, MTU_CTRL_2_CTRL_ENABLE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_LOAD_VALUE_2
    // ADDRESS       :  block_offset +'h24		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : COUNTER_VALUE  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_LOAD_VALUE_2_wr_valid = MTU_LOAD_VALUE_2_decode && wr_stb  ;
    assign MTU_LOAD_VALUE_2_offset = block_offset +'h24;
    assign MTU_LOAD_VALUE_2_decode = (address[addr_width-1 : 0] == MTU_LOAD_VALUE_2_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_LOAD_VALUE_2_rd_valid = MTU_LOAD_VALUE_2_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : COUNTER_VALUE
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Value to start count
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_LOAD_VALUE_2_COUNTER_VALUE_q <= 32'd0;
        end
    else
        begin
        if (MTU_LOAD_VALUE_2_wr_valid)	 //COUNTER_VALUE : SW Write
            begin
                MTU_LOAD_VALUE_2_COUNTER_VALUE_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (MTU_LOAD_VALUE_2_COUNTER_VALUE_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign MTU_LOAD_VALUE_2_COUNTER_VALUE_r = MTU_LOAD_VALUE_2_COUNTER_VALUE_q; // Field : COUNTER_VALUE
    
    
    // ===================================================
    // HW OUTPUT WRITE PULSE
    
    assign MTU_LOAD_VALUE_2_COUNTER_VALUE_q_wr_pulse = MTU_LOAD_VALUE_2_wr_valid ; //COUNTER_VALUE  : Write pulse
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_LOAD_VALUE_2_COUNTER_VALUE_wr_pulse <= 1'b0 ;
        end
        
    else
        begin
            MTU_LOAD_VALUE_2_COUNTER_VALUE_wr_pulse <= MTU_LOAD_VALUE_2_COUNTER_VALUE_q_wr_pulse ;
        end
    end
    
    
    assign MTU_LOAD_VALUE_2_rd_data  = MTU_LOAD_VALUE_2_rd_valid ? {MTU_LOAD_VALUE_2_COUNTER_VALUE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_BACK_LOAD_VALUE_2
    // ADDRESS       :  block_offset +'h28		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : BACKGROUND_COUNTER_VALUE  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_BACK_LOAD_VALUE_2_wr_valid = MTU_BACK_LOAD_VALUE_2_decode && wr_stb  ;
    assign MTU_BACK_LOAD_VALUE_2_offset = block_offset +'h28;
    assign MTU_BACK_LOAD_VALUE_2_decode = (address[addr_width-1 : 0] == MTU_BACK_LOAD_VALUE_2_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_BACK_LOAD_VALUE_2_rd_valid = MTU_BACK_LOAD_VALUE_2_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : BACKGROUND_COUNTER_VALUE
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Value to start count after end of counter
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q <= 32'd0;
        end
    else
        begin
        if (MTU_BACK_LOAD_VALUE_2_wr_valid)	 //BACKGROUND_COUNTER_VALUE : SW Write
            begin
                MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_r = MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q; // Field : BACKGROUND_COUNTER_VALUE
    
    
    // ===================================================
    // HW OUTPUT WRITE PULSE
    
    assign MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q_wr_pulse = MTU_BACK_LOAD_VALUE_2_wr_valid ; //BACKGROUND_COUNTER_VALUE  : Write pulse
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_wr_pulse <= 1'b0 ;
        end
        
    else
        begin
            MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_wr_pulse <= MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q_wr_pulse ;
        end
    end
    
    
    assign MTU_BACK_LOAD_VALUE_2_rd_data  = MTU_BACK_LOAD_VALUE_2_rd_valid ? {MTU_BACK_LOAD_VALUE_2_BACKGROUND_COUNTER_VALUE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_STATUS_2
    // ADDRESS       :  block_offset +'h2C		WIDTH : 32
    // HW ACCESS     :  WO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     0 : IRQ  ( SW : WC HW : WO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_STATUS_2_wr_valid = MTU_STATUS_2_decode && wr_stb  ;
    assign MTU_STATUS_2_offset = block_offset +'h2C;
    assign MTU_STATUS_2_decode = (address[addr_width-1 : 0] == MTU_STATUS_2_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_STATUS_2_rd_valid = MTU_STATUS_2_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : IRQ
    // HW ACCESS  : WO                          WIDTH : 1
    // SW ACCESS  : WC                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Rise when counter_2 value is zero
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_STATUS_2_IRQ_q <= 1'd0;
        end
    else
        begin
        if (MTU_STATUS_2_wr_valid)	 //IRQ : SW Write to Clear
            begin
                MTU_STATUS_2_IRQ_q <= MTU_STATUS_2_IRQ_q & (~reg_enb  [0] );
            end
        else
            begin
                
                MTU_STATUS_2_IRQ_q <= MTU_STATUS_2_IRQ_in;
            else
                begin
                    MTU_STATUS_2_IRQ_q <= 1'h0 ;
                end
            end
        end
    end //end always
    assign MTU_STATUS_2_rd_data  = MTU_STATUS_2_rd_valid ? {31'h0, MTU_STATUS_2_IRQ_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_CTRL_3
    // ADDRESS       :  block_offset +'h30		WIDTH : 32
    // HW ACCESS     :  RW RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     0 : CTRL_ENABLE  ( SW : RW HW : RW )
    //     1 : CTRL_MODE  ( SW : RW HW : RO )
    //     10:2 : CTRL_DIV  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_CTRL_3_wr_valid = MTU_CTRL_3_decode && wr_stb  ;
    assign MTU_CTRL_3_offset = block_offset +'h30;
    assign MTU_CTRL_3_decode = (address[addr_width-1 : 0] == MTU_CTRL_3_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_CTRL_3_rd_valid = MTU_CTRL_3_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_ENABLE
    // HW ACCESS  : RW                          WIDTH : 1
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Enable counter 3
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_3_CTRL_ENABLE_q <= 1'd0;
        end
    else
        begin
        if (MTU_CTRL_3_wr_valid)	 //CTRL_ENABLE : SW Write
            begin
                MTU_CTRL_3_CTRL_ENABLE_q <= (wr_data [0]  & reg_enb  [0] ) | (MTU_CTRL_3_CTRL_ENABLE_q & (~reg_enb  [0] ));
            end
        else
            begin
                
                MTU_CTRL_3_CTRL_ENABLE_q <= MTU_CTRL_3_CTRL_ENABLE_in;
            end
        end
    end //end always
    
    assign MTU_CTRL_3_CTRL_ENABLE_r = MTU_CTRL_3_CTRL_ENABLE_q; // Field : CTRL_ENABLE
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_MODE
    // HW ACCESS  : RO                          WIDTH : 1
    // SW ACCESS  : RW                          OFFSET : 1
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Select mode of counter_3:
    0 -> periodic (free-running)
    1 -> One shot
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_3_CTRL_MODE_q <= 1'd0;
        end
    else
        begin
        if (MTU_CTRL_3_wr_valid)	 //CTRL_MODE : SW Write
            begin
                MTU_CTRL_3_CTRL_MODE_q <= (wr_data [1]  & reg_enb  [1] ) | (MTU_CTRL_3_CTRL_MODE_q & (~reg_enb  [1] ));
            end
        end
    end //end always
    
    assign MTU_CTRL_3_CTRL_MODE_r = MTU_CTRL_3_CTRL_MODE_q; // Field : CTRL_MODE
    
    //----------------------------------------------------------------------------
    // FIELD  : CTRL_DIV
    // HW ACCESS  : RO                          WIDTH : 9
    // SW ACCESS  : RW                          OFFSET : 2
    //-----------------------------------------------------------------
    /*DESCRIPTION    : Clock divider 1 ... 256
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_CTRL_3_CTRL_DIV_q <= 9'd0;
        end
    else
        begin
        if (MTU_CTRL_3_wr_valid)	 //CTRL_DIV : SW Write
            begin
                MTU_CTRL_3_CTRL_DIV_q <= (wr_data [10 : 2]  & reg_enb  [10 : 2] ) | (MTU_CTRL_3_CTRL_DIV_q & (~reg_enb  [10 : 2] ));
            end
        end
    end //end always
    
    assign MTU_CTRL_3_CTRL_DIV_r = MTU_CTRL_3_CTRL_DIV_q; // Field : CTRL_DIV
    assign MTU_CTRL_3_rd_data  = MTU_CTRL_3_rd_valid ? {21'h0, MTU_CTRL_3_CTRL_DIV_q, MTU_CTRL_3_CTRL_MODE_q, MTU_CTRL_3_CTRL_ENABLE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_LOAD_VALUE_3
    // ADDRESS       :  block_offset +'h34		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : COUNTER_VALUE  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_LOAD_VALUE_3_wr_valid = MTU_LOAD_VALUE_3_decode && wr_stb  ;
    assign MTU_LOAD_VALUE_3_offset = block_offset +'h34;
    assign MTU_LOAD_VALUE_3_decode = (address[addr_width-1 : 0] == MTU_LOAD_VALUE_3_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_LOAD_VALUE_3_rd_valid = MTU_LOAD_VALUE_3_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : COUNTER_VALUE
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Value to start count
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_LOAD_VALUE_3_COUNTER_VALUE_q <= 32'd0;
        end
    else
        begin
        if (MTU_LOAD_VALUE_3_wr_valid)	 //COUNTER_VALUE : SW Write
            begin
                MTU_LOAD_VALUE_3_COUNTER_VALUE_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (MTU_LOAD_VALUE_3_COUNTER_VALUE_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign MTU_LOAD_VALUE_3_COUNTER_VALUE_r = MTU_LOAD_VALUE_3_COUNTER_VALUE_q; // Field : COUNTER_VALUE
    
    
    // ===================================================
    // HW OUTPUT WRITE PULSE
    
    assign MTU_LOAD_VALUE_3_COUNTER_VALUE_q_wr_pulse = MTU_LOAD_VALUE_3_wr_valid ; //COUNTER_VALUE  : Write pulse
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_LOAD_VALUE_3_COUNTER_VALUE_wr_pulse <= 1'b0 ;
        end
        
    else
        begin
            MTU_LOAD_VALUE_3_COUNTER_VALUE_wr_pulse <= MTU_LOAD_VALUE_3_COUNTER_VALUE_q_wr_pulse ;
        end
    end
    
    
    assign MTU_LOAD_VALUE_3_rd_data  = MTU_LOAD_VALUE_3_rd_valid ? {MTU_LOAD_VALUE_3_COUNTER_VALUE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_BACK_LOAD_VALUE_3
    // ADDRESS       :  block_offset +'h38		WIDTH : 32
    // HW ACCESS     :  RO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : BACKGROUND_COUNTER_VALUE  ( SW : RW HW : RO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_BACK_LOAD_VALUE_3_wr_valid = MTU_BACK_LOAD_VALUE_3_decode && wr_stb  ;
    assign MTU_BACK_LOAD_VALUE_3_offset = block_offset +'h38;
    assign MTU_BACK_LOAD_VALUE_3_decode = (address[addr_width-1 : 0] == MTU_BACK_LOAD_VALUE_3_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_BACK_LOAD_VALUE_3_rd_valid = MTU_BACK_LOAD_VALUE_3_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : BACKGROUND_COUNTER_VALUE
    // HW ACCESS  : RO                          WIDTH : 32
    // SW ACCESS  : RW                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Value to start count after end of counter
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q <= 32'd0;
        end
    else
        begin
        if (MTU_BACK_LOAD_VALUE_3_wr_valid)	 //BACKGROUND_COUNTER_VALUE : SW Write
            begin
                MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q <= (wr_data [31 : 0]  & reg_enb  [31 : 0] ) | (MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q & (~reg_enb  [31 : 0] ));
            end
        end
    end //end always
    
    assign MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_r = MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q; // Field : BACKGROUND_COUNTER_VALUE
    
    
    // ===================================================
    // HW OUTPUT WRITE PULSE
    
    assign MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q_wr_pulse = MTU_BACK_LOAD_VALUE_3_wr_valid ; //BACKGROUND_COUNTER_VALUE  : Write pulse
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_wr_pulse <= 1'b0 ;
        end
        
    else
        begin
            MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_wr_pulse <= MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q_wr_pulse ;
        end
    end
    
    
    assign MTU_BACK_LOAD_VALUE_3_rd_data  = MTU_BACK_LOAD_VALUE_3_rd_valid ? {MTU_BACK_LOAD_VALUE_3_BACKGROUND_COUNTER_VALUE_q} : 32'd0;
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MTU_STATUS_3
    // ADDRESS       :  block_offset +'h3C		WIDTH : 32
    // HW ACCESS     :  WO
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     0 : IRQ  ( SW : WC HW : WO )
    //-----------------------------------------------------------------------------
    /* DESCRIPTION  :  NA
    */
    assign MTU_STATUS_3_wr_valid = MTU_STATUS_3_decode && wr_stb  ;
    assign MTU_STATUS_3_offset = block_offset +'h3C;
    assign MTU_STATUS_3_decode = (address[addr_width-1 : 0] == MTU_STATUS_3_offset[addr_width-1 : 0]) ? 1'b1 : 1'b0;
    assign MTU_STATUS_3_rd_valid = MTU_STATUS_3_decode && rd_stb ;
    
    //----------------------------------------------------------------------------
    // FIELD  : IRQ
    // HW ACCESS  : WO                          WIDTH : 1
    // SW ACCESS  : WC                          OFFSET : 0
    //-----------------------------------------------------------------
    /*DESCRIPTION    :
    Rise when counter_3 value is zero
    */
    
    always @(posedge clk or negedge reset_l)  begin
    if (!reset_l)
        begin
            MTU_STATUS_3_IRQ_q <= 1'd0;
        end
    else
        begin
        if (MTU_STATUS_3_wr_valid)	 //IRQ : SW Write to Clear
            begin
                MTU_STATUS_3_IRQ_q <= MTU_STATUS_3_IRQ_q & (~reg_enb  [0] );
            end
        else
            begin
                
                MTU_STATUS_3_IRQ_q <= MTU_STATUS_3_IRQ_in;
            else
                begin
                    MTU_STATUS_3_IRQ_q <= 1'h0 ;
                end
            end
        end
    end //end always
    assign MTU_STATUS_3_rd_data  = MTU_STATUS_3_rd_valid ? {31'h0, MTU_STATUS_3_IRQ_q} : 32'd0;
    assign emptyaddress0_error_l = block_offset + 'h40;
    assign emptyaddress0_error_h = block_offset + block_size-1;
    assign emptyaddress0_error = ((address[addr_width - 1 : 0]  >= emptyaddress0_error_l[addr_width - 1 : 0]) && (address[addr_width - 1 : 0]  <= emptyaddress0_error_h[addr_width - 1 : 0])) ? 1'b1 : 1'b0 ;
    
    
    
    assign rd_data_vld = rd_stb;
    assign rd_data = MTU_CTRL_0_rd_data  |
    MTU_LOAD_VALUE_0_rd_data  |
    MTU_BACK_LOAD_VALUE_0_rd_data  |
    MTU_STATUS_0_rd_data  |
    MTU_CTRL_1_rd_data  |
    MTU_LOAD_VALUE_1_rd_data  |
    MTU_BACK_LOAD_VALUE_1_rd_data  |
    MTU_STATUS_1_rd_data  |
    MTU_CTRL_2_rd_data  |
    MTU_LOAD_VALUE_2_rd_data  |
    MTU_BACK_LOAD_VALUE_2_rd_data  |
    MTU_STATUS_2_rd_data  |
    MTU_CTRL_3_rd_data  |
    MTU_LOAD_VALUE_3_rd_data  |
    MTU_BACK_LOAD_VALUE_3_rd_data  |
    MTU_STATUS_3_rd_data ;
    assign request = 1'b1;
    assign rd_wait = 1'b1;
    
    assign invalid_address_error = emptyaddress0_error ;
    
    assign error = invalid_address_error;
    
endmodule

